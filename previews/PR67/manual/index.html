<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Basics ¬∑ Quaternionic.jl</title><meta name="title" content="Basics ¬∑ Quaternionic.jl"/><meta property="og:title" content="Basics ¬∑ Quaternionic.jl"/><meta property="twitter:title" content="Basics ¬∑ Quaternionic.jl"/><meta name="description" content="Documentation for Quaternionic.jl."/><meta property="og:description" content="Documentation for Quaternionic.jl."/><meta property="twitter:description" content="Documentation for Quaternionic.jl."/><meta property="og:url" content="https://moble.github.io/Quaternionic.jl/stable/manual/"/><meta property="twitter:url" content="https://moble.github.io/Quaternionic.jl/stable/manual/"/><link rel="canonical" href="https://moble.github.io/Quaternionic.jl/stable/manual/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/citations.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">Quaternionic.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction</a></li><li class="is-active"><a class="tocitem" href>Basics</a><ul class="internal"><li><a class="tocitem" href="#Constructors,-constants,-and-conversions"><span>Constructors, constants, and conversions</span></a></li><li><a class="tocitem" href="#Number-functions-from-Base"><span>Number functions from Base</span></a></li><li><a class="tocitem" href="#Algebra-and-mathematical-functions"><span>Algebra and mathematical functions</span></a></li><li><a class="tocitem" href="#Random-quaternions"><span>Random quaternions</span></a></li><li><a class="tocitem" href="#Conversions"><span>Conversions</span></a></li><li><a class="tocitem" href="#Distances"><span>Distances</span></a></li><li><a class="tocitem" href="#Alignment"><span>Alignment</span></a></li></ul></li><li><a class="tocitem" href="../functions_of_time/">Functions of time</a></li><li><a class="tocitem" href="../differentiation/">Differentiating by quaternions</a></li><li><a class="tocitem" href="../functions/">All functions</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Basics</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Basics</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/moble/Quaternionic.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands">ÔÇõ</span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/moble/Quaternionic.jl/blob/main/docs/src/manual.md" title="Edit source on GitHub"><span class="docs-icon fa-solid">ÔÅÑ</span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Quaternionic-functions"><a class="docs-heading-anchor" href="#Quaternionic-functions">Quaternionic functions</a><a id="Quaternionic-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Quaternionic-functions" title="Permalink"></a></h1><p>From <code>AbstractQuaternion{T}</code> we define three subtypes:</p><ul><li><code>Quaternion{T}</code>, which is an element of the general algebra of quaternions over any <code>T&lt;:Real</code>.</li><li><code>Rotor{T}</code>, which is an element of the multiplicative group of unit quaternions, and is interpreted as mapping to a rotation.  The magnitude is <em>assumed</em> to be 1 (though, for efficiency, this is not generally confirmed), and the sign may be freely changed in certain cases.</li><li><code>QuatVec{T}</code>, which is an element of the additive group of quaternions with 0 scalar part; a &quot;pure vector&quot; quaternion.</li></ul><p>For simplicity, almost every function in this package is defined for general <code>Quaternion</code>s, so you may not need any other type.  However, it can frequently be more accurate <em>and</em> more efficient to use the other subtypes where relevant.</p><h2 id="Constructors,-constants,-and-conversions"><a class="docs-heading-anchor" href="#Constructors,-constants,-and-conversions">Constructors, constants, and conversions</a><a id="Constructors,-constants,-and-conversions-1"></a><a class="docs-heading-anchor-permalink" href="#Constructors,-constants,-and-conversions" title="Permalink"></a></h2><p>At the most basic level, <code>Quaternion{T}</code> mimics <code>Complex{T}</code> as closely as possible, including the behavior of most functions in <code>Base</code>.  The <code>Rotor{T}</code> and <code>QuatVec{T}</code> subtypes behave very similarly, except that most of their constructors automatically impose the constraints that the norm is 1 and the scalar component is 0, respectively.  Also note that when a certain operation is not defined for either of those subtypes, the functions will usually convert to a general <code>Quaternion</code> automatically.</p><p>To create new <code>Quaternion</code>s interactively, it is typically most convenient to use the constants <code>imx</code>, <code>imy</code>, and <code>imz</code> ‚Äî or equivalently <code>ùê¢</code>, <code>ùê£</code>, and <code>ùê§</code> ‚Äî multiplied by appropriate factors and added together.  For programmatic work, it is more common to use the <a href="#Quaternionic.Quaternion"><code>Quaternion</code></a> function ‚Äî which takes all four components, the three vector components, or just the one scalar component, and creates a new <code>Quaternion</code> of the type implied by the arguments.  You can also <em>specify</em> the type, as in <code>Quaternion{Float64}(...)</code>.  Type conversions with <code>promote</code>, <code>widen</code>, <code>float</code>, etc., work as expected.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Quaternionic.QuatVec" href="#Quaternionic.QuatVec"><code>Quaternionic.QuatVec</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">QuatVec{T&lt;:Number} &lt;: Number</code></pre><p>Pure-vector quaternion with elements of type <code>T</code>.  These objects can be significantly faster <em>and</em> more accurate in certain operations than general <code>Quaternion</code>s.</p><p><code>QuatVecF16</code>, <code>QuatVecF32</code> and <code>QuatVecF64</code> are aliases for <code>QuatVec{Float16}</code>, <code>QuatVec{Float32}</code> and <code>QuatVec{Float64}</code> respectively.  See also <a href="#Quaternionic.Quaternion"><code>Quaternion</code></a> and <a href="#Quaternionic.Rotor"><code>Rotor</code></a>.</p><p>The functions</p><pre><code class="nohighlight hljs">quatvec(w, x, y, z)
quatvec(x, y, z)
quatvec(w)</code></pre><p>create a new <code>QuatVec</code> with the given components (where the components are as described in <a href="#Quaternionic.Quaternion"><code>Quaternion</code></a>), except that the scalar argument <code>w</code> is always set to 0.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; quatvec(1, 2, 3, 4)
 + 2ùê¢ + 3ùê£ + 4ùê§
julia&gt; quatvec(quaternion(1, 2, 3, 4))
 + 2ùê¢ + 3ùê£ + 4ùê§
julia&gt; quatvec(2, 3, 4)
 + 2ùê¢ + 3ùê£ + 4ùê§
julia&gt; quatvec(1)
 + 0ùê¢ + 0ùê£ + 0ùê§</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/Quaternionic.jl/blob/915c1c52e479dc61b310650e0147e8170814c028/src/quaternion.jl#L172-L203">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Quaternionic.Quaternion" href="#Quaternionic.Quaternion"><code>Quaternionic.Quaternion</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Quaternion{T&lt;:Number} &lt;: Number</code></pre><p>Quaternionic number type with elements of type <code>T</code>.</p><p><code>QuaternionF16</code>, <code>QuaternionF32</code> and <code>QuaternionF64</code> are aliases for <code>Quaternion{Float16}</code>, <code>Quaternion{Float32}</code> and <code>Quaternion{Float64}</code> respectively.  See also <a href="#Quaternionic.Rotor"><code>Rotor</code></a> and <a href="#Quaternionic.QuatVec"><code>QuatVec</code></a>.</p><p>The functions</p><pre><code class="nohighlight hljs">quaternion(w, x, y, z)
quaternion(x, y, z)
quaternion(w)</code></pre><p>create a new quaternion with the given components.  The argument <code>w</code> is the scalar component, and <code>x</code>, <code>y</code>, and <code>z</code> are the corresponding &quot;vector&quot; components.  If any of these arguments is missing, it will be set to zero.  The type of the returned quaternion will be inferred from the input arguments, or can be specified, by passing the type parameter <code>T</code> as above.</p><p>Note that the constants <a href="#Quaternionic.imx"><code>imx</code></a>, <a href="#Quaternionic.imy"><code>imy</code></a>, and <a href="#Quaternionic.imz"><code>imz</code></a> can also be used like the complex <code>im</code> to create new <code>Quaternion</code> object.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; quaternion(1, 2, 3, 4)
1 + 2ùê¢ + 3ùê£ + 4ùê§
julia&gt; Quaternion{Float64}(1, 2, 3, 4)
1.0 + 2.0ùê¢ + 3.0ùê£ + 4.0ùê§
julia&gt; quaternion(1.0, 2.0, 3.0, 4.0)
1.0 + 2.0ùê¢ + 3.0ùê£ + 4.0ùê§
julia&gt; quaternion(2, 3, 4)
0 + 2ùê¢ + 3ùê£ + 4ùê§
julia&gt; quaternion(1)
1 + 0ùê¢ + 0ùê£ + 0ùê§</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/Quaternionic.jl/blob/915c1c52e479dc61b310650e0147e8170814c028/src/quaternion.jl#L7-L45">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Quaternionic.Rotor" href="#Quaternionic.Rotor"><code>Quaternionic.Rotor</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Rotor{T&lt;:Number} &lt;: Number</code></pre><p>Quaternion of unit magnitude with elements of type <code>T</code>.  These objects can be significantly faster <em>and</em> more accurate in certain operations representing rotations.</p><p>A rotor is typically considered to be an element of the group <span>$\mathrm{Spin}(3) ‚âÉ \mathrm{SU}(2)$</span>, which can be thought of as the subgroup of quaternions with norm 1.  They are particularly useful as representations of rotations because a rotor <span>$R$</span> acts on a vector <span>$\vec{v}$</span> by &quot;conjugation&quot; as</p><p class="math-container">\[\vec{v}&#39; = R\, \vec{v}\, R^{-1}.\]</p><p>(which can be represented in code as <code>R * v / R</code> or, more efficiently, as <code>R(v)</code>).  This operation preserves the inner product between any two vectors conjugated in this way, and so is a rotation.  Note that, because there are two factors of <span>$R$</span> here, the sign of <span>$R$</span> does not affect the result.  Therefore, <span>$\mathrm{Spin}(3)$</span> forms a <em>double</em> cover of the rotation group <span>$\mathrm{SO}(3)$</span>.  For this reason, it will occasionally be useful to disregard or arbitrarily change the sign of a <code>Rotor</code> (as in <a href="#Quaternionic.distance-Tuple{AbstractQuaternion, AbstractQuaternion}"><code>distance</code></a> functions) ‚Äî though this is not generally the default, and may cause problems if the input rotors change sign when the corresponding rotations are not so different (cf. <a href="../functions_of_time/#Quaternionic.unflip-Tuple{AbstractArray{&lt;:AbstractQuaternion}}"><code>unflip</code></a>).</p><p><code>RotorF16</code>, <code>RotorF32</code> and <code>RotorF64</code> are aliases for <code>Rotor{Float16}</code>, <code>Rotor{Float32}</code> and <code>Rotor{Float64}</code> respectively.  See also <a href="#Quaternionic.Quaternion"><code>Quaternion</code></a> and <a href="#Quaternionic.QuatVec"><code>QuatVec</code></a>.</p><p>The functions</p><pre><code class="nohighlight hljs">rotor(w, x, y, z)
rotor(w)</code></pre><p>create a new rotor with the given components (where the components are as described in <a href="#Quaternionic.Quaternion"><code>Quaternion</code></a>), automatically normalizing them on input.  Note that this normalization step is the key difference between the <code>Rotor</code> and <code>rotor</code> functions; if you would like to bypass normalization, you can call</p><pre><code class="nohighlight hljs">Rotor{T}(w, x, y, z)
Rotor{T}(w)</code></pre><p>in the same way as <code>rotor</code>, and <code>w, x, y, z</code> will be converted to type <code>T</code>.  Alternatively, you can call</p><pre><code class="nohighlight hljs">Rotor{T}(v)</code></pre><p>where <code>v&lt;:AbstractArray</code> can be converted to an <code>SVector{4, T}</code>.  If you want to handle the normalization step, you can use <a href="#Quaternionic.normalize-Tuple{AbstractQuaternion}"><code>normalize</code></a>.</p><p>However, once a <code>Rotor</code> is created, its norm will often be <em>assumed</em> to be precisely 1.  So if its true norm is significantly different, you will likely see weird results ‚Äî including vectors with very different lengths after &quot;rotation&quot; by a non-unit <code>Rotor</code>.</p><p>Note that simply creating a <code>Quaternion</code> that happens to have norm 1 does not make it a <code>Rotor</code>.  However, you can pass such a <code>Quaternion</code> to the <code>rotor</code> function and get the desired result.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; rotor(1, 2, 3, 4)
rotor(0.18257418583505536 + 0.3651483716701107ùê¢ + 0.5477225575051661ùê£ + 0.7302967433402214ùê§)
julia&gt; rotor(quaternion(1, 2, 3, 4))
rotor(0.18257418583505536 + 0.3651483716701107ùê¢ + 0.5477225575051661ùê£ + 0.7302967433402214ùê§)
julia&gt; Rotor{Float16}(1, 2, 3, 4)
rotor(1.0 + 2.0ùê¢ + 3.0ùê£ + 4.0ùê§)
julia&gt; normalize(Rotor{Float16}(1, 2, 3, 4))
rotor(0.1826 + 0.3652ùê¢ + 0.548ùê£ + 0.7305ùê§)
julia&gt; rotor(1.0)
rotor(1.0 + 0.0ùê¢ + 0.0ùê£ + 0.0ùê§)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/Quaternionic.jl/blob/915c1c52e479dc61b310650e0147e8170814c028/src/quaternion.jl#L71-L141">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Quaternionic.imx" href="#Quaternionic.imx"><code>Quaternionic.imx</code></a> ‚Äî <span class="docstring-category">Constant</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">imx
ùê¢</code></pre><p>The quaternionic unit associated with rotation about the <code>x</code> axis.  Can also be entered as Unicode bold <code>ùê¢</code> (which can be input as <code>\bfi&lt;tab&gt;</code>).</p><p>Note that ‚Äî just as <code>im</code> is a <code>Complex{Bool}</code> ‚Äî <code>imx</code> is a <code>QuatVec{Bool}</code>, and as soon as you multiply by a scalar of any other number type (e.g., a <code>Float64</code>) it will be promoted to a <code>QuatVec</code> of that number type, and once you <em>add</em> a scalar it will be promoted to a <code>Quaternion</code>.</p><p>See also <a href="#Quaternionic.imy"><code>imy</code></a> and <a href="#Quaternionic.imz"><code>imz</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; imx * imx
-1 + 0ùê¢ + 0ùê£ + 0ùê§
julia&gt; 1.2imx
 + 1.2ùê¢ + 0.0ùê£ + 0.0ùê§
julia&gt; 1.2 + 3.4imx
1.2 + 3.4ùê¢ + 0.0ùê£ + 0.0ùê§
julia&gt; 1.2 + 3.4ùê¢
1.2 + 3.4ùê¢ + 0.0ùê£ + 0.0ùê§</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/Quaternionic.jl/blob/915c1c52e479dc61b310650e0147e8170814c028/src/quaternion.jl#L267-L292">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Quaternionic.imy" href="#Quaternionic.imy"><code>Quaternionic.imy</code></a> ‚Äî <span class="docstring-category">Constant</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">imy
ùê£</code></pre><p>The quaternionic unit associated with rotation about the <code>y</code> axis.  Can also be entered as Unicode bold <code>ùê£</code> (which can be input as <code>\bfj&lt;tab&gt;</code>).</p><p>Note that ‚Äî just as <code>im</code> is a <code>Complex{Bool}</code> ‚Äî <code>imy</code> is a <code>QuatVec{Bool}</code>, and as soon as you multiply by a scalar of any other number type (e.g., a <code>Float64</code>) it will be promoted to a <code>QuatVec</code> of that number type, and once you <em>add</em> a scalar it will be promoted to a <code>Quaternion</code>.</p><p>See also <a href="#Quaternionic.imx"><code>imx</code></a> and <a href="#Quaternionic.imz"><code>imz</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; imy * imy
-1 + 0ùê¢ + 0ùê£ + 0ùê§
julia&gt; 1.2imy
 + 0.0ùê¢ + 1.2ùê£ + 0.0ùê§
julia&gt; 1.2 + 3.4imy
1.2 + 0.0ùê¢ + 3.4ùê£ + 0.0ùê§
julia&gt; 1.2 + 3.4ùê£
1.2 + 0.0ùê¢ + 3.4ùê£ + 0.0ùê§</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/Quaternionic.jl/blob/915c1c52e479dc61b310650e0147e8170814c028/src/quaternion.jl#L296-L321">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Quaternionic.imz" href="#Quaternionic.imz"><code>Quaternionic.imz</code></a> ‚Äî <span class="docstring-category">Constant</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">imz
ùê§</code></pre><p>The quaternionic unit associated with rotation about the <code>z</code> axis.  Can also be entered as Unicode bold <code>ùê§</code> (which can be input as <code>\bfk&lt;tab&gt;</code>).</p><p>Note that ‚Äî just as <code>im</code> is a <code>Complex{Bool}</code> ‚Äî <code>imz</code> is a <code>QuatVec{Bool}</code>, and as soon as you multiply by a scalar of any other number type (e.g., a <code>Float64</code>) it will be promoted to a <code>QuatVec</code> of that number type, and once you <em>add</em> a scalar it will be promoted to a <code>Quaternion</code>.</p><p>See also <a href="#Quaternionic.imx"><code>imx</code></a> and <a href="#Quaternionic.imy"><code>imy</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; imz * imz
-1 + 0ùê¢ + 0ùê£ + 0ùê§
julia&gt; 1.2imz
 + 0.0ùê¢ + 0.0ùê£ + 1.2ùê§
julia&gt; 1.2 + 3.4imz
1.2 + 0.0ùê¢ + 0.0ùê£ + 3.4ùê§
julia&gt; 1.2 + 3.4ùê§
1.2 + 0.0ùê¢ + 0.0ùê£ + 3.4ùê§</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/Quaternionic.jl/blob/915c1c52e479dc61b310650e0147e8170814c028/src/quaternion.jl#L325-L350">source</a></section></article><h2 id="Number-functions-from-Base"><a class="docs-heading-anchor" href="#Number-functions-from-Base">Number functions from Base</a><a id="Number-functions-from-Base-1"></a><a class="docs-heading-anchor-permalink" href="#Number-functions-from-Base" title="Permalink"></a></h2><p>The standard <a href="https://docs.julialang.org/en/v1/base/numbers/#General-Number-Functions-and-Constants"><code>Number</code> functions</a> that work for <code>Complex</code>, such as <code>isfinite</code>, <code>iszero</code>, etc., should work analogously for <code>Quaternion</code>.  The <code>hash</code>, <code>read</code>, and <code>write</code> functions are also implemented.  As noted in the <a href="../#Examples">Examples</a>, broadcasting to each component is also implemented via <code>broadcasted</code>.</p><h2 id="Algebra-and-mathematical-functions"><a class="docs-heading-anchor" href="#Algebra-and-mathematical-functions">Algebra and mathematical functions</a><a id="Algebra-and-mathematical-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Algebra-and-mathematical-functions" title="Permalink"></a></h2><p>Along with the basic binary operators, the essential mathematical functions like <a href="#Base.conj-Tuple{Q} where Q&lt;:AbstractQuaternion"><code>conj</code></a>, <a href="#Base.abs-Tuple{AbstractQuaternion}"><code>abs</code></a>, <a href="#Base.abs2-Tuple{AbstractQuaternion}"><code>abs2</code></a>, <a href="#Base.exp-Union{Tuple{Quaternion{T}}, Tuple{T}} where T"><code>exp</code></a>, <a href="#Base.log-Union{Tuple{Quaternion{T}}, Tuple{T}} where T"><code>log</code></a>, etc., are implemented.  Most of these functions are found in the <code>Base</code> module, and are simply overloaded methods of functions that should also be familiar from <code>Complex</code> types.  Note that we use a slightly different interpretation of <a href="#Base.angle-Union{Tuple{Quaternion{T}}, Tuple{T}} where T"><code>angle</code></a> for <code>Quaternion</code>, compared to <code>Complex</code>.  We also have <a href="#Quaternionic.absvec-Tuple{AbstractQuaternion}"><code>absvec</code></a> and <a href="#Quaternionic.abs2vec-Tuple{AbstractQuaternion}"><code>abs2vec</code></a>, which are not useful in a <code>Complex</code> context, but compute the relevant quantities for the &quot;vector&quot; component of a <code>Quaternion</code>.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.conj-Tuple{Q} where Q&lt;:AbstractQuaternion" href="#Base.conj-Tuple{Q} where Q&lt;:AbstractQuaternion"><code>Base.conj</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">conj(q)</code></pre><p>Return the quaternion conjugate, which flips the sign of each &quot;vector&quot; component.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; conj(quaternion(1,2,3,4))
1 - 2ùê¢ - 3ùê£ - 4ùê§</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/Quaternionic.jl/blob/915c1c52e479dc61b310650e0147e8170814c028/src/algebra.jl#L3-L14">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.:‚ãÖ-Tuple{AbstractQuaternion, AbstractQuaternion}" href="#LinearAlgebra.:‚ãÖ-Tuple{AbstractQuaternion, AbstractQuaternion}"><code>LinearAlgebra.:‚ãÖ</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">p ‚ãÖ q</code></pre><p>Evaluate the inner (&quot;dot&quot;) product between two quaternions.  Equal to the scalar part of <code>p * conj(q)</code>.</p><p>Note that this function is not very commonly used, except as a quick way to determine whether the two quaternions are more anti-parallel than parallel, for functions like <a href="../functions_of_time/#Quaternionic.unflip-Tuple{AbstractArray{&lt;:AbstractQuaternion}}"><code>unflip</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/Quaternionic.jl/blob/915c1c52e479dc61b310650e0147e8170814c028/src/algebra.jl#L75-L84">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Quaternionic.:√ó-Tuple{QuatVec, QuatVec}" href="#Quaternionic.:√ó-Tuple{QuatVec, QuatVec}"><code>Quaternionic.:√ó</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">a √ó b</code></pre><p>Return the cross product of two pure-vector quaternions.  Equal to ¬Ω of the commutator product <code>a*b-b*a</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/Quaternionic.jl/blob/915c1c52e479dc61b310650e0147e8170814c028/src/algebra.jl#L89-L94">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Quaternionic.:√óÃÇ-Tuple{QuatVec, QuatVec}" href="#Quaternionic.:√óÃÇ-Tuple{QuatVec, QuatVec}"><code>Quaternionic.:√óÃÇ</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">a √óÃÇ b</code></pre><p>Return the <em>direction</em> of the cross product between <code>a</code> and <code>b</code>; the normalized vector along <code>a√ób</code> ‚Äî unless the magnitude is zero, in which case the zero vector is returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/Quaternionic.jl/blob/915c1c52e479dc61b310650e0147e8170814c028/src/algebra.jl#L103-L109">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Quaternionic.normalize-Tuple{AbstractQuaternion}" href="#Quaternionic.normalize-Tuple{AbstractQuaternion}"><code>Quaternionic.normalize</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">normalize(q)</code></pre><p>Return a copy of this quaternion, normalized.</p><p>Note that this returns the same type as the input quaternion.  If you want to convert to a <code>Rotor</code>, just call <code>rotor(q)</code>, which includes a normalization step.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/Quaternionic.jl/blob/915c1c52e479dc61b310650e0147e8170814c028/src/algebra.jl#L120-L128">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.abs-Tuple{AbstractQuaternion}" href="#Base.abs-Tuple{AbstractQuaternion}"><code>Base.abs</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">abs(q)</code></pre><p>Square-root of the sum the squares of the components of the quaternion</p><p>This function uses Julia&#39;s built-in <code>hypot</code> function to avoid overflow and underflow.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; abs(quaternion(1,2,4,10))
11.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/Quaternionic.jl/blob/915c1c52e479dc61b310650e0147e8170814c028/src/math.jl#L20-L32">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.abs2-Tuple{AbstractQuaternion}" href="#Base.abs2-Tuple{AbstractQuaternion}"><code>Base.abs2</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">abs2(q)</code></pre><p>Sum the squares of the components of the quaternion</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; abs2(quaternion(1,2,4,10))
121</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/Quaternionic.jl/blob/915c1c52e479dc61b310650e0147e8170814c028/src/math.jl#L3-L13">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.angle-Union{Tuple{Quaternion{T}}, Tuple{T}} where T" href="#Base.angle-Union{Tuple{Quaternion{T}}, Tuple{T}} where T"><code>Base.angle</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">angle(q)</code></pre><p>Phase angle in radians of the rotation represented by this quaternion.</p><p>Note that this may be different from your interpretation of the angle of a complex number in an important way.  Because quaternions act on vectors by conjugation ‚Äî as in <code>q*v*conj(q)</code> ‚Äî there are <em>two</em> copies of <code>q</code> involved in that expression; in some sense, a quaternion acts &quot;twice&quot;.  Therefore, this angle may be twice what you expect from an analogy with complex numbers ‚Äî dpending on how you interpret the correspondence between complex numbers and quaternions.  Also, while rotations in the complex plane have a natural choice of axis (the positive <code>z</code> direction), that is not the case for quaternions, which means that the sign of this angle is arbitrary, and we always choose it to be positive.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; Œ∏=1.2;

julia&gt; R=exp(Œ∏ * imz / 2);

julia&gt; angle(R)
1.2
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/Quaternionic.jl/blob/915c1c52e479dc61b310650e0147e8170814c028/src/math.jl#L282-L308">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.exp-Union{Tuple{Quaternion{T}}, Tuple{T}} where T" href="#Base.exp-Union{Tuple{Quaternion{T}}, Tuple{T}} where T"><code>Base.exp</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">exp(q)</code></pre><p>Exponential of a quaternion</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; exp(imx*œÄ/4)  # Rotation through œÄ/2 (note the extra 1/2) about the x axis
rotor(0.7071067811865476 + 0.7071067811865475ùê¢ + 0.0ùê£ + 0.0ùê§)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/Quaternionic.jl/blob/915c1c52e479dc61b310650e0147e8170814c028/src/math.jl#L184-L194">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.log-Union{Tuple{Quaternion{T}}, Tuple{T}} where T" href="#Base.log-Union{Tuple{Quaternion{T}}, Tuple{T}} where T"><code>Base.log</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">log(q)</code></pre><p>Logarithm of a quaternion.</p><p>As with the usual complex logarithm, the quaternion logarithm has multiple branches, though the quaternion branches are three-dimensional: for any unit &quot;vector&quot; quaternion qÃÇ, you could add any integer multiple of 2œÄqÃÇ to the result of this function and still get the same result after exponentiating (within numerical accuracy).  This function is the principal logarithm.</p><p>This function has discontinuous (and fairly arbitrary) behavior along the negative real axis: if the &quot;vector&quot; components of the quaternion are precisely zero <em>and</em> the scalar component is negative, the returned quaternion will have scalar component <code>log(-q[1])</code>, but will also have a <code>z</code> component of œÄ.  The choice of the <code>z</code> direction is arbitrary; the &quot;vector&quot; component of the returned quaternion could be œÄ times any unit vector.</p><p>Note that <code>q</code> may be either a <code>Quaternion</code> or a <code>Rotor</code>.  If it is a <code>Quaternion</code>, this function does not assume that it has unit norm, so the scalar component of the returned value will generally be nonzero unless the input has <em>precisely</em> unit magnitude (which is impossible with Float64 about 52.07% of the time due to finite machine precision), and the return type is a <code>Quaternion</code>.  If the input is a <code>Rotor</code>, a <code>QuatVec</code> is returned, which has scalar part exactly 0.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; log(exp(1.2imy))
 + 0.0ùê¢ + 1.2ùê£ + 0.0ùê§

julia&gt; log(quaternion(exp(7)))
7.0 + 0.0ùê¢ + 0.0ùê£ + 0.0ùê§

julia&gt; log(quaternion(-exp(7)))
7.0 + 0.0ùê¢ + 0.0ùê£ + 3.141592653589793ùê§</code></pre><p><strong>Notes</strong></p><p>This function uses an accurate algorithm for finding the logarithm.  For simplicity, we will assume that the input quaternion is a unit quaternion, so that the logarithm will be a pure vector <span>$\vec{v}$</span>, which we write as <span>$v\hat{v}$</span>, where <span>$v$</span> is just the scalar norm. Note that, because of the periodicity of the <code>exp</code> function, we can assume that <span>$v \in [0, \pi]$</span> and, in particular, <span>$\sin(v) \geq 0$</span>.  Now, expand the exponential as</p><p class="math-container">\[\exp\left(\vec{v}\right) = \exp\left(v \hat{v}\right) = \cos(v) + \hat{v} \sin(v).\]</p><p>The input to this function is the right-hand side, but we do not yet know its decomposition into <span>$v$</span> and <span>$\hat{v}$</span>.  But we can find <span>$\cos(v)$</span> as the scalar part of the input, and <span>$\sin(v)$</span> as the <code>absvec</code> (since we know that <span>$\sin(v) \geq 0$</span>).  Then, we can compute <span>$v = \mathrm{atan}(\sin(v), \cos(v))$</span>.  And finally, we simply multiply the vector part of the input by <span>$v / \sin(v)$</span> to obtain the logarithm.  This factor is given accurately by <code>invsinc(v)</code> whenever <span>$|v| \leq \pi/2$</span>.</p><p>When that condition is not satisfied (which also implies <span>$\cos(v)&lt;0$</span>, we can rewrite the problem as</p><p class="math-container">\[\exp\left(v \hat{v}\right) = \cos(v) + \hat{v} \sin(v) = -\cos(v-\pi) - \hat{v} \sin(v-\pi)
= -\cos(v&#39;) - \hat{v} \sin(v&#39;).\]</p><p>Here, we want to multiply the vector component by <span>$-v / \sin(v&#39;) = -(v&#39;+\pi) / sin(v&#39;)$</span>. Note that we can easily compute <span>$v&#39; = \mathrm{atan}(\sin(v), -\cos(v))$</span>.  This algorithm is surprisingly accurate, even when <span>$v$</span> is extremely close to <span>$\pi$</span>, which implies that the vector part of the input is extremely small.</p><p>The only special case remaining to handle is when <span>$\cos(v) &lt; 0$</span> but <span>$\sin(v)$</span> is <em>identically</em> zero.  In this case, we could throw an error, but this is not usually helpful. Instead, we arbitrarily choose to return <span>$\pi z$</span>.</p><p>Finally, we can return to our assumption that the input has unit magnitude.  In the preceding, this didn&#39;t matter because we only computed <span>$v$</span> as the <em>ratio</em> of the scalar part and the magnitude of the vector part, so the overall magnitude cancelled out.  So that part of the computation remains unchanged.  Instead, we note that for scalar <span>$s$</span>, we have</p><p class="math-container">\[\exp\left(s + \vec{v}\right) = \exp\left(s\right) \exp\left(\vec{v}\right),\]</p><p>so the logarithm is just the sum of the logarithms of the scalar and vector parts.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/Quaternionic.jl/blob/915c1c52e479dc61b310650e0147e8170814c028/src/math.jl#L72-L149">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.sqrt-Tuple{T} where T&lt;:AbstractQuaternion" href="#Base.sqrt-Tuple{T} where T&lt;:AbstractQuaternion"><code>Base.sqrt</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sqrt(q)</code></pre><p>Square-root of a quaternion.</p><p>The general formula whenever the denominator is nonzero is</p><p class="math-container">\[\sqrt{q} = \frac{|q| + q} {\sqrt{2|q| + 2q[1]}}\]</p><p>This can be proven by expanding <code>q</code> as <code>q[1] + vec(q)</code> and multiplying the expression above by itself.</p><p>Note that whenever the vector part is zero and the scalar part is negative, the solution is not unique (and the denominator above is zero), because it necessarily involves the square-root of -1, of which there are infinitely many in the space of quaternions.  In this case, we arbitrarily choose the vector part of the result to be in the <code>z</code> direction.  A reasonable alternative would be to throw an error; instead it is left to the user to check for that condition.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; q = quaternion(1.2, 3.4, 5.6, 7.8);

julia&gt; sqrtq = ‚àöq;

julia&gt; sqrtq^2 ‚âà q
true

julia&gt; ‚àöquaternion(4.0)
2.0 + 0.0ùê¢ + 0.0ùê£ + 0.0ùê§

julia&gt; ‚àöquaternion(-4.0)
0.0 + 0.0ùê¢ + 0.0ùê£ + 2.0ùê§</code></pre><p><strong>Notes</strong></p><p>This function uses an algorithm for finding the square root that is very accurate (typically achieving the correct result to within machine precision) for <em>most</em> values.  However, naive application of the formula above can lead to catastrophic cancellation when the scalar part is negative and significantly larger in magnitude to the vector part.  Therefore, when <code>q[1]  &lt; 0</code>, we transform the problem into the case where <code>q[1] &gt; 0</code> as</p><p class="math-container">\[\sqrt{q} = \bar{\sqrt{-\bar{q}}}\, \sqrt{-1},\]</p><p>where the bar denotes quaternionic conjugation, and we interpret <span>$\sqrt{-1}$</span> to be a unit imaginary that commutes with <span>$q$</span>.  The obvious candidate is the normalized vector part of <span>$q$</span> if the vector part is nonzero; otherwise, as noted above, we arbitrarily choose it to be the unit vector in <code>z</code> direction.  The calculation of <span>$\sqrt{-\bar{q}}$</span> can use the naive approach, and the result is still accurate to within machine precision.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/Quaternionic.jl/blob/915c1c52e479dc61b310650e0147e8170814c028/src/math.jl#L207-L260">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Quaternionic.abs2vec-Tuple{AbstractQuaternion}" href="#Quaternionic.abs2vec-Tuple{AbstractQuaternion}"><code>Quaternionic.abs2vec</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">abs2vec(q)</code></pre><p>Sum the squares of the &quot;vector&quot; components of the quaternion</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; abs2vec(quaternion(1,2,3,6))
49</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/Quaternionic.jl/blob/915c1c52e479dc61b310650e0147e8170814c028/src/math.jl#L37-L47">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Quaternionic.absvec-Tuple{AbstractQuaternion}" href="#Quaternionic.absvec-Tuple{AbstractQuaternion}"><code>Quaternionic.absvec</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">absvec(q)</code></pre><p>Square-root of the sum of the squares of the &quot;vector&quot; components of the quaternion.</p><p>This function uses Julia&#39;s built-in <code>hypot</code> function to avoid overflow and underflow.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; absvec(quaternion(1,2,3,6))
7.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/Quaternionic.jl/blob/915c1c52e479dc61b310650e0147e8170814c028/src/math.jl#L51-L63">source</a></section></article><h2 id="Random-quaternions"><a class="docs-heading-anchor" href="#Random-quaternions">Random quaternions</a><a id="Random-quaternions-1"></a><a class="docs-heading-anchor-permalink" href="#Random-quaternions" title="Permalink"></a></h2><p>It is frequently convenient to construct random <code>Quaternion</code> objects, which can be done just as with other types by passing the desired output type to the <a href="#Base.randn-Union{Tuple{T}, Tuple{Random.AbstractRNG, Type{&lt;:AbstractQuaternion{T}}}} where T&lt;:AbstractFloat"><code>randn</code></a> function.  The <code>rand</code> function is not overloaded, because there would be no geometric significance to such a <code>Quaternion</code>; <code>randn</code> results are independent of the orientation of the basis used to define the quaternions. Note that it is possible to get random <em>rotors</em> and <em>vectors</em> by passing the appropriate types to the <code>randn</code> function.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.randn-Union{Tuple{T}, Tuple{Random.AbstractRNG, Type{&lt;:AbstractQuaternion{T}}}} where T&lt;:AbstractFloat" href="#Base.randn-Union{Tuple{T}, Tuple{Random.AbstractRNG, Type{&lt;:AbstractQuaternion{T}}}} where T&lt;:AbstractFloat"><code>Base.randn</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">randn([rng=default_rng()], T=Quaternion{Float64}, [dims...])</code></pre><p>Generate a normally distributed random quaternion of type <code>T</code> with mean 0 and standard deviation of norm 1.  Optionally generate an <em>array</em> of such quaternions.  This module currently provides an implementation for the types <code>QuaternionF16</code>, <code>QuaternionF32</code>, and <code>QuaternionF64</code> (the default).  The values are drawn from the spherically symmetric quaternionic normal distribution of variance 1 (corresponding to each component having independent normal distribution with mean zero and variance 1/4).</p><p>Note that this function works with <code>Quaternion{BigFloat}</code>, even though <code>Base.randn</code> does not work with <code>BigFloat</code> on Julia &lt;1.9; for earlier versions, we just use the <a href="https://en.wikipedia.org/wiki/Box‚ÄìMuller_transform">Box-Muller transform</a> to obtain the desired result.</p><p>If the quaternion type passed in is <code>Rotor</code>, the result will be normalized correctly. Because the distribution is spherically symmetric, the result is a truly random rotation.</p><p>If the quaternion type is <code>QuatVec</code>, the result will have a 0 scalar component, and the vector will have mean 0 standard deviation of norm 1.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; randn(QuaternionF64)
0.4336736009756228 - 0.45087190792840853ùê¢ - 0.24723937675211696ùê£ - 0.4514571469326208ùê§
julia&gt; randn(QuaternionF16, 2, 2)
2√ó2 Matrix{QuaternionF16}:
   0.4321 + 1.105ùê¢ + 0.2664ùê£ - 0.1359ùê§   0.064 + 0.9263ùê¢ - 0.4138ùê£ + 0.05505ùê§
 0.2512 - 0.2585ùê¢ - 0.2803ùê£ - 0.00964ùê§  -0.1256 + 0.1848ùê¢ + 0.03607ùê£ - 0.752ùê§</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/Quaternionic.jl/blob/915c1c52e479dc61b310650e0147e8170814c028/src/random.jl#L1-L33">source</a></section></article><h2 id="Conversions"><a class="docs-heading-anchor" href="#Conversions">Conversions</a><a id="Conversions-1"></a><a class="docs-heading-anchor-permalink" href="#Conversions" title="Permalink"></a></h2><p>It can sometimes be useful to convert between quaternions and other representations.  Most of these functions are named <code>to_&lt;representation&gt;</code> and have a corresponding <code>from_&lt;representation&gt;</code> function.  Furthermore, most convert to/from representations of rotations.  While rotations are not the only useful application of quaternions, they are probably the most common.  The only conversions that are not specifically related to rotations are <a href="#Quaternionic.to_float_array-Union{Tuple{AbstractArray{&lt;:AbstractQuaternion{T}}}, Tuple{T}} where T&lt;:Number"><code>to_float_array</code></a> and <a href="#Quaternionic.from_float_array-Union{Tuple{AbstractArray{T}}, Tuple{T}} where T&lt;:Number"><code>from_float_array</code></a>.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Quaternionic.from_euler_angles-Tuple{Any, Any, Any}" href="#Quaternionic.from_euler_angles-Tuple{Any, Any, Any}"><code>Quaternionic.from_euler_angles</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">from_euler_angles(Œ±, Œ≤, Œ≥)</code></pre><p>Come over from the dark side.</p><p>Assumes the Euler angles correspond to the quaternion <code>R</code> via</p><pre><code class="nohighlight hljs">R = exp(Œ±ùê§/2) * exp(Œ≤ùê£/2) * exp(Œ≥ùê§/2)</code></pre><p>where ùê£ and ùê§ rotate about the fixed <span>$y$</span> and <span>$z$</span> axes, respectively, so this reprents an initial rotation (in the positive sense) through an angle <span>$Œ≥$</span> about the axis <span>$z$</span>, followed by a rotation through <span>$Œ≤$</span> about the axis <span>$y$</span>, and a final rotation through <span>$Œ±$</span> about the axis <span>$z$</span>.  This is equivalent to performing an initial rotation through <span>$Œ±$</span> about the axis <span>$z$</span>, followed by a rotation through <span>$Œ≤$</span> about the <em>rotated</em> axis <span>$y&#39;$</span>, followed by a rotation through <span>$Œ≥$</span> about the <em>twice-rotated</em> axis <span>$z&#39;&#39;$</span>. The angles are naturally assumed to be in radians.</p><p>NOTE: Before opening an issue reporting something &quot;wrong&quot; with this function, be sure to read all of <a href="https://github.com/moble/quaternion/wiki/Euler-angles-are-horrible">this page</a>, <em>especially</em> the very last section about opening issues or pull requests.</p><p><strong>See Also</strong></p><ul><li><a href="#Quaternionic.to_euler_angles-Tuple{AbstractQuaternion}"><code>to_euler_angles</code></a>: Convert quaternion to Euler angles</li><li><a href="#Quaternionic.to_euler_phases-Union{Tuple{AbstractQuaternion{T}}, Tuple{T}} where T"><code>to_euler_phases</code></a>: Convert quaternion to Euler phases</li><li><a href="#Quaternionic.from_euler_phases-Tuple{Any, Any, Any}"><code>from_euler_phases</code></a>: Create quaternion from Euler phases</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/Quaternionic.jl/blob/915c1c52e479dc61b310650e0147e8170814c028/src/conversion.jl#L116-L143">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Quaternionic.from_euler_phases-Tuple{Any, Any, Any}" href="#Quaternionic.from_euler_phases-Tuple{Any, Any, Any}"><code>Quaternionic.from_euler_phases</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">from_euler_phases(z‚Çê, z·µ¶, z·µß)
from_euler_phases(z)</code></pre><p>Return the quaternion corresponding to these Euler phases.</p><p>Interpreting the input quaternion as a rotation (though its normalization scales out), we can define the complex Euler phases from the Euler angles (Œ±, Œ≤, Œ≥) as</p><pre><code class="nohighlight hljs">z‚Çê ‚âî exp(i*Œ±)
z·µ¶ ‚âî exp(i*Œ≤)
z·µß ‚âî exp(i*Œ≥)</code></pre><p>These are more useful geometric quantites than the angles themselves ‚Äî being involved in computing spherical harmonics and Wigner&#39;s ùîá matrices ‚Äî and can be computed from the components of the corresponding quaternion algebraically (without the use of transcendental functions).</p><p><strong>Parameters</strong></p><ul><li><code>z::Vector{Complex{T}}</code>: complex vector of length 3, representing the complex phases (z‚Çê, z·µ¶, z·µß) in that order.</li></ul><p><strong>Returns</strong></p><ul><li><code>R::Quaternion{T}</code></li></ul><p><strong>See Also</strong></p><ul><li><a href="#Quaternionic.to_euler_phases-Union{Tuple{AbstractQuaternion{T}}, Tuple{T}} where T"><code>to_euler_phases</code></a>: Convert quaternion to Euler phases</li><li><a href="#Quaternionic.to_euler_angles-Tuple{AbstractQuaternion}"><code>to_euler_angles</code></a>: Convert quaternion to Euler angles</li><li><a href="#Quaternionic.from_euler_angles-Tuple{Any, Any, Any}"><code>from_euler_angles</code></a>: Create quaternion from Euler angles</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/Quaternionic.jl/blob/915c1c52e479dc61b310650e0147e8170814c028/src/conversion.jl#L215-L247">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Quaternionic.from_float_array-Union{Tuple{AbstractArray{T}}, Tuple{T}} where T&lt;:Number" href="#Quaternionic.from_float_array-Union{Tuple{AbstractArray{T}}, Tuple{T}} where T&lt;:Number"><code>Quaternionic.from_float_array</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">from_float_array(A)</code></pre><p>Reinterpret a float array as an array of quaternions</p><p>The input array must have an initial dimension whose size is 4, because successive indices in that dimension will be considered successive components of the output quaternion.</p><p>Note that this returns a view of the original data [via <code>reinterpret(reshape,...)</code>] only if the base type of the input array <code>isbitstype</code>; otherwise, a new array of <code>Quaternion</code>s must be created, and the memory copied.</p><p>See also <a href="#Quaternionic.to_float_array-Union{Tuple{AbstractArray{&lt;:AbstractQuaternion{T}}}, Tuple{T}} where T&lt;:Number"><code>to_float_array</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/Quaternionic.jl/blob/915c1c52e479dc61b310650e0147e8170814c028/src/conversion.jl#L1-L17">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Quaternionic.from_rotation_matrix-Tuple{AbstractMatrix}" href="#Quaternionic.from_rotation_matrix-Tuple{AbstractMatrix}"><code>Quaternionic.from_rotation_matrix</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">from_rotation_matrix(‚Ñõ)</code></pre><p>Convert 3x3 rotation matrix to quaternion.</p><p>Assuming the 3x3 matrix <code>‚Ñõ</code> rotates a vector <code>v</code> according to</p><pre><code class="nohighlight hljs">v&#39; = ‚Ñõ * v,</code></pre><p>we can also express this rotation in terms of a quaternion <code>R</code> such that</p><pre><code class="nohighlight hljs">v&#39; = R * v * R‚Åª¬π.</code></pre><p>This function returns that quaternion, using Bar-Itzhack&#39;s algorithm (version 3) to allow for non-orthogonal matrices.  <a href="http://dx.doi.org/10.2514/2.4654">J. Guidance, Vol. 23, No. 6, p. 1085</a></p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>If you want to use this function for matrices with elements of types other than <code>Float64</code> or <code>Float32</code>, you will need to (install and) import <code>GenericLinearAlgebra</code> first.  The reason is that this function computes the eigen-decomposition of <code>‚Ñõ</code>, which is only available for more generic float types via that package.  Note that you will want at least version 0.3.11 of <code>GenericLinearAlgebra</code> because previous versions had a bug.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/Quaternionic.jl/blob/915c1c52e479dc61b310650e0147e8170814c028/src/conversion.jl#L309-L334">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Quaternionic.from_spherical_coordinates-Tuple{Any, Any}" href="#Quaternionic.from_spherical_coordinates-Tuple{Any, Any}"><code>Quaternionic.from_spherical_coordinates</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">from_spherical_coordinates(Œ∏, œï)</code></pre><p>Return a rotor corresponding to these spherical coordinates.</p><p>Considering (Œ∏, œï) as a point <span>$nÃÇ$</span> on the sphere, we can also construct a quaternion that rotates the <span>$z$</span> axis onto that point.  Here, we use the standard commonly used in physics: Œ∏ represents the &quot;polar angle&quot; between the <span>$z$</span> axis and the direction <span>$nÃÇ$</span>, while œï represents the &quot;azimuthal angle&quot; between the <span>$x$</span> axis and the projection of <span>$nÃÇ$</span> into the <span>$x$</span>-<span>$y$</span> plane. Both angles must be given in radians.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/Quaternionic.jl/blob/915c1c52e479dc61b310650e0147e8170814c028/src/conversion.jl#L283-L295">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Quaternionic.to_euler_angles-Tuple{AbstractQuaternion}" href="#Quaternionic.to_euler_angles-Tuple{AbstractQuaternion}"><code>Quaternionic.to_euler_angles</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">to_euler_angles(R)</code></pre><p>Open Pandora&#39;s Box.</p><p>If somebody is trying to make you use Euler angles, tell them no, and walk away, and go and tell your mum.</p><p>You don&#39;t want to use Euler angles.  They are awful.  Stay away.  It&#39;s one thing to convert from Euler angles to quaternions; at least you&#39;re moving in the right direction.  But to go the other way?!  It&#39;s just not right.</p><p>Assumes the Euler angles correspond to the quaternion <code>R</code> via</p><pre><code class="nohighlight hljs">R = exp(Œ±ùê§/2) * exp(Œ≤ùê£/2) * exp(Œ≥ùê§/2)</code></pre><p>where ùê£ and ùê§ rotate about the fixed <span>$y$</span> and <span>$z$</span> axes, respectively, so this reprents an initial rotation (in the positive sense) through an angle <span>$Œ≥$</span> about the axis <span>$z$</span>, followed by a rotation through <span>$Œ≤$</span> about the axis <span>$y$</span>, and a final rotation through <span>$Œ±$</span> about the axis <span>$z$</span>.  This is equivalent to performing an initial rotation through <span>$Œ±$</span> about the axis <span>$z$</span>, followed by a rotation through <span>$Œ≤$</span> about the <em>rotated</em> axis <span>$y&#39;$</span>, followed by a rotation through <span>$Œ≥$</span> about the <em>twice-rotated</em> axis <span>$z&#39;&#39;$</span>. The angles are naturally assumed to be in radians.</p><p>NOTE: Before opening an issue reporting something &quot;wrong&quot; with this function, be sure to read all of <a href="https://github.com/moble/quaternion/wiki/Euler-angles-are-horrible">this page</a>, <em>especially</em> the very last section about opening issues or pull requests.</p><p><strong>Returns</strong></p><ul><li><code>Œ±Œ≤Œ≥::Vector{T}</code></li></ul><p><strong>Raises</strong></p><ul><li><code>AllHell</code> if you try to actually use Euler angles, when you could have been using quaternions like a sensible person.</li></ul><p><strong>See Also</strong></p><ul><li><a href="#Quaternionic.from_euler_angles-Tuple{Any, Any, Any}"><code>from_euler_angles</code></a>: Create quaternion from Euler angles</li><li><a href="#Quaternionic.to_euler_phases-Union{Tuple{AbstractQuaternion{T}}, Tuple{T}} where T"><code>to_euler_phases</code></a>: Convert quaternion to Euler phases</li><li><a href="#Quaternionic.from_euler_phases-Tuple{Any, Any, Any}"><code>from_euler_phases</code></a>: Create quaternion from Euler phases</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/Quaternionic.jl/blob/915c1c52e479dc61b310650e0147e8170814c028/src/conversion.jl#L65-L106">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Quaternionic.to_euler_phases-Union{Tuple{AbstractQuaternion{T}}, Tuple{T}} where T" href="#Quaternionic.to_euler_phases-Union{Tuple{AbstractQuaternion{T}}, Tuple{T}} where T"><code>Quaternionic.to_euler_phases</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">to_euler_phases(q)</code></pre><p>Convert input quaternion to complex phases of Euler angles</p><p>Interpreting the input quaternion as a rotation (though its normalization scales out), we can define the complex Euler phases from the Euler angles (Œ±, Œ≤, Œ≥) as</p><pre><code class="nohighlight hljs">z‚Çê ‚âî exp(i*Œ±)
z·µ¶ ‚âî exp(i*Œ≤)
z·µß ‚âî exp(i*Œ≥)</code></pre><p>These are more useful geometric quantites than the angles themselves ‚Äî being involved in computing spherical harmonics and Wigner&#39;s ùîá matrices ‚Äî and can be computed from the components of the corresponding quaternion algebraically (without the use of transcendental functions).</p><p>Note that <code>to_euler_phases!(z, q)</code> is supported for backwards compatibility, but because this function returns an <code>SVector</code>, there is probably no advantage to the in-place approach.</p><p><strong>Returns</strong></p><ul><li><code>z::SVector{Complex{T}}</code>: complex phases (z‚Çê, z·µ¶, z·µß) in that order.</li></ul><p><strong>See Also</strong></p><ul><li><a href="#Quaternionic.from_euler_phases-Tuple{Any, Any, Any}"><code>from_euler_phases</code></a>: Create quaternion from Euler phases</li><li><a href="#Quaternionic.to_euler_angles-Tuple{AbstractQuaternion}"><code>to_euler_angles</code></a>: Convert quaternion to Euler angles</li><li><a href="#Quaternionic.from_euler_angles-Tuple{Any, Any, Any}"><code>from_euler_angles</code></a>: Create quaternion from Euler angles</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/Quaternionic.jl/blob/915c1c52e479dc61b310650e0147e8170814c028/src/conversion.jl#L155-L185">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Quaternionic.to_float_array-Union{Tuple{AbstractArray{&lt;:AbstractQuaternion{T}}}, Tuple{T}} where T&lt;:Number" href="#Quaternionic.to_float_array-Union{Tuple{AbstractArray{&lt;:AbstractQuaternion{T}}}, Tuple{T}} where T&lt;:Number"><code>Quaternionic.to_float_array</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">to_float_array(A)</code></pre><p>View a quaternion array as an array of numbers</p><p>The output array will have an extra initial dimension whose size is 4, because successive indices in that dimension correspond to successive components of the quaternion.</p><p>Note that this returns a view of the original data only if the base type of the input array <code>isbitstype</code>; otherwise, a new array of that type must be created, and the memory copied.</p><p>See also <a href="#Quaternionic.from_float_array-Union{Tuple{AbstractArray{T}}, Tuple{T}} where T&lt;:Number"><code>from_float_array</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/Quaternionic.jl/blob/915c1c52e479dc61b310650e0147e8170814c028/src/conversion.jl#L34-L48">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Quaternionic.to_rotation_matrix-Tuple{Q} where Q&lt;:AbstractQuaternion" href="#Quaternionic.to_rotation_matrix-Tuple{Q} where Q&lt;:AbstractQuaternion"><code>Quaternionic.to_rotation_matrix</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">to_rotation_matrix(q)</code></pre><p>Convert quaternion to 3x3 rotation matrix.</p><p>Assuming the quaternion <code>R</code> rotates a vector <code>v</code> according to</p><pre><code class="nohighlight hljs">v&#39; = R * v * R‚Åª¬π,</code></pre><p>we can also express this rotation in terms of a 3x3 matrix <code>‚Ñõ</code> such that</p><pre><code class="nohighlight hljs">v&#39; = ‚Ñõ * v.</code></pre><p>This function returns that matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/Quaternionic.jl/blob/915c1c52e479dc61b310650e0147e8170814c028/src/conversion.jl#L358-L373">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Quaternionic.to_spherical_coordinates-Tuple{Q} where Q&lt;:AbstractQuaternion" href="#Quaternionic.to_spherical_coordinates-Tuple{Q} where Q&lt;:AbstractQuaternion"><code>Quaternionic.to_spherical_coordinates</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">to_spherical_coordinates(q)</code></pre><p>Return the spherical coordinates corresponding to this quaternion.</p><p>We can treat the quaternion as a transformation taking the <span>$z$</span> axis to some direction <span>$nÃÇ$</span>.  This direction can be described in terms of spherical coordinates (Œ∏, œï).  Here, we use the standard commonly used in physics: Œ∏ represents the &quot;polar angle&quot; between the <span>$z$</span> axis and the direction <span>$nÃÇ$</span>, while œï represents the &quot;azimuthal angle&quot; between the <span>$x$</span> axis and the projection of <span>$nÃÇ$</span> into the <span>$x$</span>-<span>$y$</span> plane.  Both angles are given in radians.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/Quaternionic.jl/blob/915c1c52e479dc61b310650e0147e8170814c028/src/conversion.jl#L260-L273">source</a></section></article><h2 id="Distances"><a class="docs-heading-anchor" href="#Distances">Distances</a><a id="Distances-1"></a><a class="docs-heading-anchor-permalink" href="#Distances" title="Permalink"></a></h2><p>There are several ways of measuring the &quot;distance&quot; between two quaternions: <span>$d(q_1, q_2)$</span>.  Fundamentally, any comparison between two quaternions <span>$q_1$</span> and <span>$q_2$</span> must make use of a binary operation, for which there are two obvious choices: addition or multiplication.  For either choice, we operate on <span>$q_1$</span> and the appropriate inverse (either additive or multiplicative) of <span>$q_2$</span>.  That is, <span>$d$</span> should be a function of either <span>$q_1 - q_2$</span> or <span>$q_1/q_2$</span>.<sup class="footnote-reference"><a id="citeref-1" href="#footnote-1">[1]</a></sup></p><p>Now, we also have a number of criteria we would like any distance function to satisfy.  For any quaternions <span>$q_1$</span> and <span>$q_2$</span> and any <em>unit</em> quaternion <span>$q_3$</span>, we require</p><ul><li>real-valued: <span>$d(q_1, q_2) \in \mathbb{R}$</span></li><li>symmetry: <span>$d(q_1, q_2) = d(q_2, q_1)$</span></li><li>invariance: <span>$d(q_3\, q_1, q_3\, q_2) = d(q_1, q_2) = d(q_1\, q_3, q_2\, q_3)$</span></li><li>identity: <span>$d(q_1, q_1) = 0$</span></li><li>positive-definiteness: <span>$d(q_1, q_2) &gt; 0$</span> whenever <span>$q_1 ‚â† q_2$</span></li></ul><p>(Of course, it should be noted that these criteria all hold in the <em>exact</em> case; when using floating-point numbers, they will likely be violated near edge cases.)</p><p>It is not hard to see that these criteria can be satisfied by any of</p><ul><li><code>abs(q‚ÇÅ - q‚ÇÇ)</code></li><li><code>abs2(q‚ÇÅ - q‚ÇÇ)</code></li><li><code>abs(log(q‚ÇÅ / q‚ÇÇ))</code></li><li><code>abs2(log(q‚ÇÅ / q‚ÇÇ)</code></li></ul><p>If <span>$q_1$</span> and <span>$q_2$</span> are interpreted as rotations, we frequently don&#39;t care about their signs, and just want the <em>smallest</em> distance between them, for any choice of sign.  Furthermore, in the multiplicative case, the <code>log</code> functions will involve calculation of the <code>log</code> of the magnitudes of the quaternions, which should be 1.  In this case, we relax the &quot;positive-definiteness&quot; criterion to allow <span>$d(q_1, q_2)$</span> to equal zero when <span>$q_1$</span> and <span>$q_2$</span> are related by a nonzero scalar multiple.</p><p>For <code>Rotor</code> types, the latter two multiplicative options are most relevant, while for other types the additive options are more relevant.  These are the default behaviors of the <code>distance</code> and <code>distance2</code> functions.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Quaternionic.distance-Tuple{AbstractQuaternion, AbstractQuaternion}" href="#Quaternionic.distance-Tuple{AbstractQuaternion, AbstractQuaternion}"><code>Quaternionic.distance</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">distance(q‚ÇÅ, q‚ÇÇ)
distance2(q‚ÇÅ, q‚ÇÇ)</code></pre><p>Measure the &quot;distance&quot; between two quaternions, or the squared distance with <code>distance2</code>.</p><p>By default, this function just returns the natural measure in the <em>additive</em> group of quaternions:</p><pre><code class="language-julia hljs">abs2(q‚ÇÅ - q‚ÇÇ)</code></pre><p>If both arguments are <code>Rotor</code>s, the function returns the natural measure in the <em>rotation</em> group, which is roughly</p><pre><code class="language-julia hljs">abs2(log(q‚ÇÅ / q‚ÇÇ))</code></pre><p>Note that for <code>Rotor</code>s, this method is (efficiently) independent of the scaling of <code>q‚ÇÅ</code> and <code>q‚ÇÇ</code>, including up to factors of -1, as is appropriate for the rotation group.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; distance(imx, imy)
1.4142135623730951
julia&gt; distance(rotor(imx), rotor(imy))
1.5707963267948966
julia&gt; distance(imz, -imz)
2.0
julia&gt; distance(rotor(imz), rotor(-imz))
0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/Quaternionic.jl/blob/915c1c52e479dc61b310650e0147e8170814c028/src/distance.jl#L1-L33">source</a></section></article><h2 id="Alignment"><a class="docs-heading-anchor" href="#Alignment">Alignment</a><a id="Alignment-1"></a><a class="docs-heading-anchor-permalink" href="#Alignment" title="Permalink"></a></h2><p>There are many ways to optimize alignment with rotations.  In particular, we can seek the optimal rotation that takes one set of points onto a corresponding set of points, or the optimal quaternion that takes one set of quaternions onto a corresponding set of quaternions.  In both cases, the &quot;optimal&quot; value depends on the metric being used.  The simplest and most robust results are obtained when the metric is the standard Euclidean metric (in the case of points), or the magnitude of the difference (in the case of quaternions).  Here, we assume that <code>QuatVec</code>s represent points, and any other type of quaternion should be treated as rotors.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Quaternionic.align-Tuple{AbstractArray{&lt;:QuatVec}, AbstractArray{&lt;:QuatVec}, AbstractArray{&lt;:Real}}" href="#Quaternionic.align-Tuple{AbstractArray{&lt;:QuatVec}, AbstractArray{&lt;:QuatVec}, AbstractArray{&lt;:Real}}"><code>Quaternionic.align</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">align(a‚Éó, b‚Éó, [w])</code></pre><p>Solve <a href="https://en.wikipedia.org/wiki/Wahba%27s_problem">Wahba&#39;s problem</a>, finding a rotation that aligns the set of points <code>a‚Éó</code> to a corresponding set of points <code>b‚Éó</code> by minimizing the distance between the first set and the rotated second set.</p><p>Here, <code>a‚Éó</code> and <code>b‚Éó</code> must be equally sized arrays of <code>QuatVec</code>s.  If present, <code>w</code> must be an equally sized array of real numbers; if not, it is taken to be 1. We define the loss function</p><p class="math-container">\[L(‚Ñõ) ‚âî Œ£·µ¢ w·µ¢ ‚Äña‚Éó·µ¢ - ‚Ñõ b‚Éó·µ¢‚Äñ¬≤\]</p><p>where <span>$‚Ñõ$</span> is a rotation operator, and return the quaternion corresponding to the optimal <span>$‚Ñõ$</span> that minimizes this function.</p><p>Note that it is possible that the points do not uniquely determine a rotation ‚Äî as when one or both sets of points is rotationally symmetric.  In that case, the loss function <span>$L(‚Ñõ)$</span> will still be minimized and the points will still be optimally aligned by the output quaternion, but that quaternion will not be unique.</p><p><strong>Notes</strong></p><p>In their book <a href="https://doi.org/10.1007/978-1-4939-0802-8"><em>Fundamentals of Spacecraft Attitude Determination and Control</em> (2014)</a>, Markley and Crassidis say that &quot;Davenport‚Äôs method remains the best method for solving Wahba‚Äôs problem&quot;. This method provides the optimal quaternion as the dominant eigenvector (the one with the largest eigenvalue) of a certain matrix.  We start by defining the supplementary matrix</p><p class="math-container">\[S ‚âî Œ£·µ¢ w·µ¢ a‚Éó·µ¢ b‚Éó·µ¢·µÄ\]</p><p>and vector</p><p class="math-container">\[s‚Éó ‚âî \begin{bmatrix}
S‚ÇÇ‚ÇÉ-S‚ÇÉ‚ÇÇ \\
S‚ÇÉ‚ÇÅ-S‚ÇÅ‚ÇÉ \\
S‚ÇÅ‚ÇÇ-S‚ÇÇ‚ÇÅ
\end{bmatrix}.\]</p><p>Then the key matrix is</p><p class="math-container">\[M ‚âî \begin{bmatrix}
S + S·µÄ - (\mathrm{tr}S)\, I‚ÇÉ &amp; s‚Éó \\
s‚Éó·µÄ &amp; \mathrm{tr}S
\end{bmatrix}\]</p><p>It is possible for this matrix to have degenerate eigenvalues, corresponding to cases where the points do not uniquely determine the rotation, as described above.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/Quaternionic.jl/blob/915c1c52e479dc61b310650e0147e8170814c028/src/alignment.jl#L1-L55">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Quaternionic.align-Tuple{Any, Any, Any}" href="#Quaternionic.align-Tuple{Any, Any, Any}"><code>Quaternionic.align</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">align(A, B, [w])</code></pre><p>Find a <code>Rotor</code> that aligns the set of rotors <code>A</code> to a corresponding set <code>B</code> by minimizing the distance between the first set and the rotated second set.</p><p>Here, <code>A</code> and <code>B</code> must be equally sized arrays of <code>AbstractQuaternion</code>s.  If present, <code>w</code> must be an equally sized array of real numbers; if not, it is taken to be 1.  We define the loss function</p><p class="math-container">\[L(R) ‚âî Œ£·µ¢ w·µ¢ |A·µ¢ - R B·µ¢|¬≤\]</p><p>where <span>$R$</span> is a <code>Rotor</code>, and return the quaternion corresponding to the optimal <span>$R$</span> that minimizes this function.</p><p>Note that it is possible that the input data do not uniquely determine a rotor, which will happen when sum below is zero.  When this happens, the result will contain <code>NaN</code>s, but no error will be raised.  When the sum is very close to ‚Äî but not exactly ‚Äî zero, the accuracy of the result will be limited.  However, the loss function will not depend strongly on the result in that case.</p><p>Be aware that this function <em>is</em> sensitive to the signs of the input quaternions.  See the <a href="../functions_of_time/#Quaternionic.unflip-Tuple{AbstractArray{&lt;:AbstractQuaternion}}"><code>unflip</code></a> function for one way to avoid problems related to signs.</p><p><strong>Notes</strong></p><p>We can ensure that the loss function is minimized by multiplying <span>$R$</span> by an exponential, differentiating with respect to the argument of the exponential, and setting that argument to 0.  This derivative should be 0 at the minimum.  We have</p><p class="math-container">\[‚àÇ‚±º Œ£·µ¢ w·µ¢ |A·µ¢ - \exp[v‚±º] R B·µ¢|¬≤  ‚Üí  2 ‚ü® e‚±º R Œ£·µ¢ w·µ¢ B·µ¢ AÃÑ·µ¢ ‚ü©‚ÇÄ\]</p><p>where ‚Üí denotes taking <span>$v‚±º‚Üí0$</span>, the symbol <span>$‚ü®‚ü©‚ÇÄ$</span> denotes taking the scalar part, and <span>$e‚±º$</span> is the unit quaternionic vector in the <span>$j$</span> direction.  The only way for this quantity to be zero for each choice of <span>$j$</span> is if</p><p class="math-container">\[R Œ£·µ¢ w·µ¢ B·µ¢ AÃÑ·µ¢\]</p><p>is itself a pure scalar.  This, in turn, can only happen if either (1) the sum is 0 or (2) if <span>$R$</span> is proportional to the <em>conjugate</em> of the sum:</p><p class="math-container">\[R ‚àù Œ£·µ¢ w·µ¢ A·µ¢ BÃÑ·µ¢\]</p><p>Now, since we want <span>$R$</span> to be a rotor, we simply define it to be the normalized sum.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/Quaternionic.jl/blob/915c1c52e479dc61b310650e0147e8170814c028/src/alignment.jl#L85-L134">source</a></section></article><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-1"><a class="tag is-link" href="#citeref-1">1</a>For <span>$q_1/q_2$</span>, we are dealing with the <em>multiplicative</em> group of quaternions, which does not include 0, so we will assume that no quaternion involved in such a function can be 0.</li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">¬´ Introduction</a><a class="docs-footer-nextpage" href="../functions_of_time/">Functions of time ¬ª</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.7.0 on <span class="colophon-date" title="Monday 21 October 2024 17:24">Monday 21 October 2024</span>. Using Julia version 1.11.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
