<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Manual · Quaternionic.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">Quaternionic.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction</a></li><li class="is-active"><a class="tocitem" href>Manual</a><ul class="internal"><li><a class="tocitem" href="#Constructors-and-Number-methods"><span>Constructors and Number methods</span></a></li><li><a class="tocitem" href="#Algebra-and-mathematical-functions"><span>Algebra and mathematical functions</span></a></li><li><a class="tocitem" href="#Random-quaternions"><span>Random quaternions</span></a></li><li><a class="tocitem" href="#Conversions"><span>Conversions</span></a></li><li><a class="tocitem" href="#Distances"><span>Distances</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Manual</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Manual</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/moble/Quaternionic.jl/blob/main/docs/src/manual.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Quaternionic-functions"><a class="docs-heading-anchor" href="#Quaternionic-functions">Quaternionic functions</a><a id="Quaternionic-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Quaternionic-functions" title="Permalink"></a></h1><h2 id="Constructors-and-Number-methods"><a class="docs-heading-anchor" href="#Constructors-and-Number-methods">Constructors and Number methods</a><a id="Constructors-and-Number-methods-1"></a><a class="docs-heading-anchor-permalink" href="#Constructors-and-Number-methods" title="Permalink"></a></h2><p>At the most basic level, <code>Quaternion{T}</code> mimics <code>Complex{T}</code> as closely as possible, including the behavior of most functions in <code>Base</code>.</p><p>To create new <code>Quaternion</code>s interactively, it is typically most convenient to use the constants <code>imx</code>, <code>imy</code>, and <code>imz</code> — or equivalently <code>𝐢</code>, <code>𝐣</code>, and <code>𝐤</code> — multiplied by appropriate factors and added together.  For programmatic work, it is more common to use the <a href="#Quaternionic.Quaternion"><code>Quaternion</code></a> function — which takes all four components, the three vector components, or just the one scalar component, and creates a new <code>Quaternion</code> of the type implied by the arguments.  You can also <em>specify</em> the type, as in <code>Quaternion{Float64}(...)</code>.  Type conversions with <code>promote</code>, <code>widen</code>, <code>float</code>, etc., work as expected.  The standard <a href="https://docs.julialang.org/en/v1/base/numbers/#General-Number-Functions-and-Constants"><code>Number</code> functions</a> that work for <code>Complex</code>, such as <code>isfinite</code>, <code>iszero</code>, etc., should work analogously for <code>Quaternion</code>.  The <code>hash</code>, <code>read</code>, and <code>write</code> functions are also implemented.  As noted in the <a href="../#Examples">Examples</a>, broadcasting to each component is also implemented via <code>broadcasted</code>.</p><article class="docstring"><header><a class="docstring-binding" id="Quaternionic.imx" href="#Quaternionic.imx"><code>Quaternionic.imx</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia">imx</code></pre><p>The quaternionic unit associated with rotation about the <code>x</code> axis.  Can also be entered as Unicode bold: <code>𝐢</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; imx * imx
-1 + 0𝐢 + 0𝐣 + 0𝐤
julia&gt; 1.2imx
0.0 + 1.2𝐢 + 0.0𝐣 + 0.0𝐤</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/Quaternionic.jl/blob/52be295819bca1148fb156b6ebb04f3715cb5564/src/quaternion.jl#L87-L100">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quaternionic.imy" href="#Quaternionic.imy"><code>Quaternionic.imy</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia">imy</code></pre><p>The quaternionic unit associated with rotation about the <code>y</code> axis.  Can also be entered as Unicode bold: <code>𝐣</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; imy * imy
-1 + 0𝐢 + 0𝐣 + 0𝐤
julia&gt; 1.2imy
0.0 + 0.0𝐢 + 1.2𝐣 + 0.0𝐤</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/Quaternionic.jl/blob/52be295819bca1148fb156b6ebb04f3715cb5564/src/quaternion.jl#L104-L117">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quaternionic.imz" href="#Quaternionic.imz"><code>Quaternionic.imz</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia">imz</code></pre><p>The quaternionic unit associated with rotation about the <code>z</code> axis.  Can also be entered as Unicode bold: <code>𝐤</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; imz * imz
-1 + 0𝐢 + 0𝐣 + 0𝐤
julia&gt; 1.2imz
0.0 + 0.0𝐢 + 0.0𝐣 + 1.2𝐤</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/Quaternionic.jl/blob/52be295819bca1148fb156b6ebb04f3715cb5564/src/quaternion.jl#L121-L134">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quaternionic.Quaternion" href="#Quaternionic.Quaternion"><code>Quaternionic.Quaternion</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Quaternion{T&lt;:Real} &lt;: Number</code></pre><p>Quaternionic number type with elements of type <code>T</code>.</p><p><code>QuaternionF16</code>, <code>QuaternionF32</code> and <code>QuaternionF64</code> are aliases for <code>Quaternion{Float16}</code>, <code>Quaternion{Float32}</code> and <code>Quaternion{Float64}</code> respectively.</p><p>See also: <a href="#Quaternionic.Quaternion"><code>Quaternion</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/Quaternionic.jl/blob/52be295819bca1148fb156b6ebb04f3715cb5564/src/quaternion.jl#L1-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quaternionic.Quaternion-NTuple{4, Real}" href="#Quaternionic.Quaternion-NTuple{4, Real}"><code>Quaternionic.Quaternion</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Quaternion(w, x, y, z)
Quaternion(x, y, z)
Quaternion(w)
Quaternion{T}(w, x, y, z)</code></pre><p>Creates a new quaternion with the given components.  The first argument <code>w</code> is the scalar component, and <code>x</code>, <code>y</code>, and <code>z</code> are the corresponding &quot;vector&quot; components.  The type of the returned quaternion will be inferred from the input arguments.  If numeric arguments are missing, they will be set to zero. The element type <code>T</code> can also be specified, by passing the type parameter as usual.</p><p>Note that the constants <a href="#Quaternionic.imx"><code>imx</code></a>, <a href="#Quaternionic.imy"><code>imy</code></a>, and <a href="#Quaternionic.imz"><code>imz</code></a> can also be used like the complex <code>im</code> to create new <code>Quaternion</code> object.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; Quaternion(1, 2, 3, 4)
1 + 2𝐢 + 3𝐣 + 4𝐤
julia&gt; Quaternion{Float64}(1, 2, 3, 4)
1.0 + 2.0𝐢 + 3.0𝐣 + 4.0𝐤
julia&gt; Quaternion(1.0, 2.0, 3.0, 4.0)
1.0 + 2.0𝐢 + 3.0𝐣 + 4.0𝐤
julia&gt; Quaternion(2, 3, 4)
0 + 2𝐢 + 3𝐣 + 4𝐤
julia&gt; Quaternion(1)
1 + 0𝐢 + 0𝐣 + 0𝐤</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/Quaternionic.jl/blob/52be295819bca1148fb156b6ebb04f3715cb5564/src/quaternion.jl#L18-L48">source</a></section></article><h2 id="Algebra-and-mathematical-functions"><a class="docs-heading-anchor" href="#Algebra-and-mathematical-functions">Algebra and mathematical functions</a><a id="Algebra-and-mathematical-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Algebra-and-mathematical-functions" title="Permalink"></a></h2><p>Along with the basic binary operators, the essential mathematical functions like <a href="#Base.conj-Tuple{Quaternion}"><code>conj</code></a>, <a href="#Base.abs-Tuple{Quaternion}"><code>abs</code></a>, <a href="#Base.abs2-Tuple{Quaternion}"><code>abs2</code></a>, <a href="#Base.exp-Union{Tuple{Quaternion{T}}, Tuple{T}} where T"><code>exp</code></a>, <a href="#Base.log-Union{Tuple{Quaternion{T}}, Tuple{T}} where T"><code>log</code></a>, etc., are implemented.  Most of these functions are found in the <code>Base</code> module, and are simply overloaded methods of functions that should also be familiar from <code>Complex</code> types.  Note that we use a slightly different interpretation of <a href="#Base.angle-Tuple{Quaternion}"><code>angle</code></a> for <code>Quaternion</code>, compared to <code>Complex</code>.  We also have <a href="#Quaternionic.absvec-Tuple{Quaternion}"><code>absvec</code></a> and <a href="#Quaternionic.abs2vec-Tuple{Quaternion}"><code>abs2vec</code></a>, which are not useful in a <code>Complex</code> context, but compute the relevant quantities for the &quot;vector&quot; component of a <code>Quaternion</code>.</p><article class="docstring"><header><a class="docstring-binding" id="Base.conj-Tuple{Quaternion}" href="#Base.conj-Tuple{Quaternion}"><code>Base.conj</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">conj(q)</code></pre><p>Return the quaternion conjugate, which flips the sign of each &quot;vector&quot; component.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; conj(Quaternion(1,2,3,4))
1 - 2𝐢 - 3𝐣 - 4𝐤</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/Quaternionic.jl/blob/52be295819bca1148fb156b6ebb04f3715cb5564/src/algebra.jl#L95-L106">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.abs-Tuple{Quaternion}" href="#Base.abs-Tuple{Quaternion}"><code>Base.abs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">abs(q)</code></pre><p>Square-root of the sum the squares of the components of the quaternion</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; abs(Quaternion(1,2,4,10))
11.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/Quaternionic.jl/blob/52be295819bca1148fb156b6ebb04f3715cb5564/src/math.jl#L15-L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.abs2-Tuple{Quaternion}" href="#Base.abs2-Tuple{Quaternion}"><code>Base.abs2</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">abs2(q)</code></pre><p>Sum the squares of the components of the quaternion</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; abs2(Quaternion(1,2,4,10))
121</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/Quaternionic.jl/blob/52be295819bca1148fb156b6ebb04f3715cb5564/src/math.jl#L2-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.angle-Tuple{Quaternion}" href="#Base.angle-Tuple{Quaternion}"><code>Base.angle</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">angle(q)</code></pre><p>Phase angle in radians of the rotation represented by this quaternion.</p><p>Note that this may be different from your interpretation of the angle of a complex number in an important way.  Because quaternions act on vectors by conjugation — as in <code>q*v*conj(q)</code> — there are <em>two</em> copies of <code>q</code> involved in that expression; in some sense, a quaternion acts &quot;twice&quot;.  Therefore, this angle may be twice what you expect from an analogy with complex numbers — dpending on how you interpret the correspondence between complex numbers and quaternions.  Also, while rotations in the complex plane have a natural choice of axis (the positive <code>z</code> direction), that is not the case for quaternions, which means that the sign of this angle is arbitrary, and we always choose it to be positive.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; θ=1.2;

julia&gt; R=exp(θ * imz / 2);

julia&gt; angle(R)
1.2
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/Quaternionic.jl/blob/52be295819bca1148fb156b6ebb04f3715cb5564/src/math.jl#L221-L247">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.exp-Union{Tuple{Quaternion{T}}, Tuple{T}} where T" href="#Base.exp-Union{Tuple{Quaternion{T}}, Tuple{T}} where T"><code>Base.exp</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">exp(q)</code></pre><p>Exponential of a quaternion</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; exp(imx*π/4)  # Rotation through π/2 (note the extra 1/2) about the x axis
0.7071067811865476 + 0.7071067811865475𝐢 + 0.0𝐣 + 0.0𝐤</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/Quaternionic.jl/blob/52be295819bca1148fb156b6ebb04f3715cb5564/src/math.jl#L118-L128">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.log-Union{Tuple{Quaternion{T}}, Tuple{T}} where T" href="#Base.log-Union{Tuple{Quaternion{T}}, Tuple{T}} where T"><code>Base.log</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">log(q)</code></pre><p>Logarithm of a quaternion.</p><p>As with the usual complex logarithm, the quaternion logarithm has multiple branches, though the quaternion branches are three-dimensional: for any unit &quot;vector&quot; quaternion q̂, you could add any integer multiple of 2πq̂ to the result of this function and still get the same result after exponentiating (within numerical accuracy).  This function is the principal logarithm.</p><p>This function has discontinuous (and fairly arbitrary) behavior along the negative real axis: if the &quot;vector&quot; components of the quaternion are precisely zero <em>and</em> the scalar component is negative, the returned quaternion will have scalar component <code>log(-q.w)</code>, but will also have a <code>z</code> component of π.  The choice of the <code>z</code> direction is arbitrary; the &quot;vector&quot; component of the returned quaternion could be π times any unit vector.</p><p>Note that this function is not specialized to unit-quaternion inputs, so the scalar component of the returned value will be nonzero unless the input has <em>precisely</em> unit magnitude.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; log(exp(1.2imy))
0.0 + 0.0𝐢 + 1.2𝐣 + 0.0𝐤

julia&gt; log(Quaternion(exp(7)))
7.0 + 0.0𝐢 + 0.0𝐣 + 0.0𝐤

julia&gt; log(Quaternion(-exp(7)))
7.0 + 0.0𝐢 + 0.0𝐣 + 3.141592653589793𝐤</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/Quaternionic.jl/blob/52be295819bca1148fb156b6ebb04f3715cb5564/src/math.jl#L56-L90">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.sqrt-Union{Tuple{Quaternion{T}}, Tuple{T}} where T" href="#Base.sqrt-Union{Tuple{Quaternion{T}}, Tuple{T}} where T"><code>Base.sqrt</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">sqrt(q)</code></pre><p>Square-root of a quaternion.</p><p>The general formula whenever the denominator is nonzero is</p><p><span>$\sqrt{q} = \frac{|q| + q} {\sqrt{2|q| + 2q.w}}$</span></p><p>This can be proven by expanding <code>q</code> as <code>q.w + q.vec</code> and multiplying the expression above by itself.</p><p>When the denominator is zero, this function has discontinuous (and fairly arbitrary) behavior, just as with the quaternion <a href="#Base.log-Union{Tuple{Quaternion{T}}, Tuple{T}} where T"><code>log</code></a> function.  In this case, either all components are zero — in which case the result is simply the zero quaternion — or the &quot;vector&quot; components of the quaternion are precisely zero and the scalar component is negative.  If the latter is true, the denominator above will be a pure-imaginary number.  Because the quaternions come with infinitely many elements that square to -1, it is not clear <em>which</em> imaginary should be used, so we arbitrarily choose to set the result proportional to the <code>z</code> quaternion.  The choice of the <code>z</code> direction is arbitrary; the &quot;vector&quot; component of the returned quaternion could be in any direction.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; q = Quaternion(1.2, 3.4, 5.6, 7.8);

julia&gt; sqrtq = √q;

julia&gt; sqrtq^2 ≈ q
true

julia&gt; √Quaternion(4)
2.0 + 0.0𝐢 + 0.0𝐣 + 0.0𝐤

julia&gt; √Quaternion(-4)
0.0 + 0.0𝐢 + 0.0𝐣 + 2.0𝐤</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/Quaternionic.jl/blob/52be295819bca1148fb156b6ebb04f3715cb5564/src/math.jl#L151-L192">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quaternionic.abs2vec-Tuple{Quaternion}" href="#Quaternionic.abs2vec-Tuple{Quaternion}"><code>Quaternionic.abs2vec</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">abs2vec(q)</code></pre><p>Sum the squares of the &quot;vector&quot; components of the quaternion</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; abs2vec(Quaternion(1,2,3,6))
49</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/Quaternionic.jl/blob/52be295819bca1148fb156b6ebb04f3715cb5564/src/math.jl#L28-L38">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quaternionic.absvec-Tuple{Quaternion}" href="#Quaternionic.absvec-Tuple{Quaternion}"><code>Quaternionic.absvec</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">absvec(q)</code></pre><p>Square-root of the sum of the squares of the &quot;vector&quot; components of the quaternion</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; absvec(Quaternion(1,2,3,6))
7.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/Quaternionic.jl/blob/52be295819bca1148fb156b6ebb04f3715cb5564/src/math.jl#L41-L51">source</a></section></article><h2 id="Random-quaternions"><a class="docs-heading-anchor" href="#Random-quaternions">Random quaternions</a><a id="Random-quaternions-1"></a><a class="docs-heading-anchor-permalink" href="#Random-quaternions" title="Permalink"></a></h2><p>It is frequently convenient to construct random <code>Quaternion</code> objects, which can be done just as with other types by passing the desired output type to the <a href="#Base.randn-Union{Tuple{T}, Tuple{Random.AbstractRNG, Type{Quaternion{T}}}} where T&lt;:AbstractFloat"><code>randn</code></a> function.  The <code>rand</code> function is not overloaded, because there would be no geometric significance to such a <code>Quaternion</code>; <code>randn</code> results are independent of the orientation of the basis used to define the quaternions.  A simple convenience function <a href="#Quaternionic.randn_rotor-Union{Tuple{T}, Tuple{Random.AbstractRNG, Type{T}, Tuple{Vararg{Int64, N}} where N}} where T&lt;:AbstractFloat"><code>randn_rotor</code></a> is also provided, to normalize each result.</p><article class="docstring"><header><a class="docstring-binding" id="Base.randn-Union{Tuple{T}, Tuple{Random.AbstractRNG, Type{Quaternion{T}}}} where T&lt;:AbstractFloat" href="#Base.randn-Union{Tuple{T}, Tuple{Random.AbstractRNG, Type{Quaternion{T}}}} where T&lt;:AbstractFloat"><code>Base.randn</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">randn([rng=GLOBAL_RNG], [T=Quaternion{Float64}], [dims...])</code></pre><p>Generate a normally distributed random quaternion of type <code>T</code> with mean 0 and standard deviation of norm 1.  Optionally generate an <em>array</em> of such quaternions.  This module currently provides an implementation for the types <code>QuaternionF16</code>, <code>QuaternionF32</code>, and <code>QuaternionF64</code> (the default).  The values are drawn from the spherically symmetric quaternionic normal distribution of variance 1 (corresponding to each component having independent normal distribution with mean zero and variance 1/4).</p><p>Note that this function works with any <code>Quaternion{&lt;:AbstractFloat}</code>, including <code>Quaternion{BigFloat}</code>, even though <code>Base.randn</code> does not work with BigFloat; we just use the <a href="https://en.wikipedia.org/wiki/Box–Muller_transform">Box-Muller transform</a> to obtain the desired result.</p><p>See also: <a href="#Quaternionic.randn_rotor-Union{Tuple{T}, Tuple{Random.AbstractRNG, Type{T}, Tuple{Vararg{Int64, N}} where N}} where T&lt;:AbstractFloat"><code>randn_rotor</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia">julia&gt; randn(QuaternionF64)
0.4336736009756228 - 0.45087190792840853𝐢 - 0.24723937675211696𝐣 - 0.4514571469326208𝐤
julia&gt; randn(QuaternionF16, 2, 2)
2×2 Matrix{QuaternionF16}:
   0.4321 + 1.105𝐢 + 0.2664𝐣 - 0.1359𝐤   0.064 + 0.9263𝐢 - 0.4138𝐣 + 0.05505𝐤
 0.2512 - 0.2585𝐢 - 0.2803𝐣 - 0.00964𝐤  -0.1256 + 0.1848𝐢 + 0.03607𝐣 - 0.752𝐤</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/Quaternionic.jl/blob/52be295819bca1148fb156b6ebb04f3715cb5564/src/random.jl#L1-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quaternionic.randn_rotor-Union{Tuple{T}, Tuple{Random.AbstractRNG, Type{T}, Tuple{Vararg{Int64, N}} where N}} where T&lt;:AbstractFloat" href="#Quaternionic.randn_rotor-Union{Tuple{T}, Tuple{Random.AbstractRNG, Type{T}, Tuple{Vararg{Int64, N}} where N}} where T&lt;:AbstractFloat"><code>Quaternionic.randn_rotor</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">randn_rotor([rng=GLOBAL_RNG], [T=Quaternion{Float64}], [dims...])</code></pre><p>Generate a normally distributed random quaternion of type <code>T</code> with mean 0 and norm 1.  (Note that the <em>norm</em> is always precisely 1 with this function, but otherwise the individual components are randomly distributed.)  The result is spherically symmetric, and gives rise a truly random rotation.</p><p>See also: <a href="#Base.randn-Union{Tuple{T}, Tuple{Random.AbstractRNG, Type{Quaternion{T}}}} where T&lt;:AbstractFloat"><code>randn</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/Quaternionic.jl/blob/52be295819bca1148fb156b6ebb04f3715cb5564/src/random.jl#L43-L51">source</a></section></article><h2 id="Conversions"><a class="docs-heading-anchor" href="#Conversions">Conversions</a><a id="Conversions-1"></a><a class="docs-heading-anchor-permalink" href="#Conversions" title="Permalink"></a></h2><p>It can sometimes be useful to convert between quaternions and other representations.  Most of these functions are named <code>to_&lt;representation&gt;</code> and have a corresponding <code>from_&lt;representation&gt;</code> function.  Furthermore, most convert to/from representations of rotations.  While rotations are not the only useful application of quaternions, they are probably the most common.  The only conversions that are not specifically related to rotations are <a href="#Quaternionic.to_float_array-Union{Tuple{AbstractArray{Quaternion{T}, N} where N}, Tuple{T}} where T&lt;:Real"><code>to_float_array</code></a> and <a href="#Quaternionic.from_float_array-Union{Tuple{AbstractArray{T, N} where N}, Tuple{T}} where T&lt;:Real"><code>from_float_array</code></a>.</p><article class="docstring"><header><a class="docstring-binding" id="Quaternionic.from_euler_angles-Tuple{Any, Any, Any}" href="#Quaternionic.from_euler_angles-Tuple{Any, Any, Any}"><code>Quaternionic.from_euler_angles</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">from_euler_angles(α, β, γ)</code></pre><p>Come over from the dark side.</p><p>Assumes the Euler angles correspond to the quaternion <code>R</code> via</p><pre><code class="language-none">R = exp(α𝐤/2) * exp(β𝐣/2) * exp(γ𝐤/2)</code></pre><p>where 𝐣 and 𝐤 rotate about the fixed <span>$y$</span> and <span>$z$</span> axes, respectively, so this reprents an initial rotation (in the positive sense) through an angle <span>$γ$</span> about the axis <span>$z$</span>, followed by a rotation through <span>$β$</span> about the axis <span>$y$</span>, and a final rotation through <span>$α$</span> about the axis <span>$z$</span>.  This is equivalent to performing an initial rotation through <span>$α$</span> about the axis <span>$z$</span>, followed by a rotation through <span>$β$</span> about the <em>rotated</em> axis <span>$y&#39;$</span>, followed by a rotation through <span>$γ$</span> about the <em>twice-rotated</em> axis <span>$z&#39;&#39;$</span>. The angles are naturally assumed to be in radians.</p><p>NOTE: Before opening an issue reporting something &quot;wrong&quot; with this function, be sure to read all of <a href="https://github.com/moble/quaternion/wiki/Euler-angles-are-horrible">this page</a>, <em>especially</em> the very last section about opening issues or pull requests.</p><p><strong>See Also</strong></p><ul><li><a href="#Quaternionic.to_euler_angles-Tuple{Quaternion}"><code>to_euler_angles</code></a>: Convert quaternion to Euler angles</li><li><a href="#Quaternionic.to_euler_phases-Union{Tuple{Quaternion{T}}, Tuple{T}} where T"><code>to_euler_phases</code></a>: Convert quaternion to Euler phases</li><li><a href="#Quaternionic.from_euler_phases-Tuple{Any, Any, Any}"><code>from_euler_phases</code></a>: Create quaternion from Euler phases</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/Quaternionic.jl/blob/52be295819bca1148fb156b6ebb04f3715cb5564/src/conversion.jl#L115-L142">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quaternionic.from_euler_phases-Tuple{Any, Any, Any}" href="#Quaternionic.from_euler_phases-Tuple{Any, Any, Any}"><code>Quaternionic.from_euler_phases</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">from_euler_phases(zₐ, zᵦ, zᵧ)
from_euler_phases(z)</code></pre><p>Return the quaternion corresponding to these Euler phases.</p><p>Interpreting the input quaternion as a rotation (though its normalization scales out), we can define the complex Euler phases from the Euler angles (α, β, γ) as</p><pre><code class="language-none">zₐ ≔ exp(i*α)
zᵦ ≔ exp(i*β)
zᵧ ≔ exp(i*γ)</code></pre><p>These are more useful geometric quantites than the angles themselves — being involved in computing spherical harmonics and Wigner&#39;s 𝔇 matrices — and can be computed from the components of the corresponding quaternion algebraically (without the use of transcendental functions).</p><p><strong>Parameters</strong></p><ul><li><code>z::Vector{Complex{T}}</code>: complex vector of length 3, representing the complex phases (zₐ, zᵦ, zᵧ) in that order.</li></ul><p><strong>Returns</strong></p><ul><li><code>R::Quaternion{T}</code></li></ul><p><strong>See Also</strong></p><ul><li><a href="#Quaternionic.to_euler_phases-Union{Tuple{Quaternion{T}}, Tuple{T}} where T"><code>to_euler_phases</code></a>: Convert quaternion to Euler phases</li><li><a href="#Quaternionic.to_euler_angles-Tuple{Quaternion}"><code>to_euler_angles</code></a>: Convert quaternion to Euler angles</li><li><a href="#Quaternionic.from_euler_angles-Tuple{Any, Any, Any}"><code>from_euler_angles</code></a>: Create quaternion from Euler angles</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/Quaternionic.jl/blob/52be295819bca1148fb156b6ebb04f3715cb5564/src/conversion.jl#L211-L243">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quaternionic.from_float_array-Union{Tuple{AbstractArray{T, N} where N}, Tuple{T}} where T&lt;:Real" href="#Quaternionic.from_float_array-Union{Tuple{AbstractArray{T, N} where N}, Tuple{T}} where T&lt;:Real"><code>Quaternionic.from_float_array</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">from_float_array(A)</code></pre><p>Reinterpret a real array as an array of quaternions</p><p>The input array must have an initial dimension whose size is 4, because successive indices in that dimension will be considered successive components of the output quaternion.</p><p>Note that this returns a view of the original data only if the base type of the input array <code>isbitstype</code>; otherwise, a new array of <code>Quaternion</code>s must be created, and the memory copied.</p><p>See also <a href="#Quaternionic.to_float_array-Union{Tuple{AbstractArray{Quaternion{T}, N} where N}, Tuple{T}} where T&lt;:Real"><code>to_float_array</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/Quaternionic.jl/blob/52be295819bca1148fb156b6ebb04f3715cb5564/src/conversion.jl#L1-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quaternionic.from_rotation_matrix-Tuple{Any}" href="#Quaternionic.from_rotation_matrix-Tuple{Any}"><code>Quaternionic.from_rotation_matrix</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">from_rotation_matrix(ℛ)</code></pre><p>Convert 3x3 rotation matrix to quaternion.</p><p>Assuming the 3x3 matrix <code>ℛ</code> rotates a vector <code>v</code> according to</p><pre><code class="language-none">v&#39; = ℛ * v,</code></pre><p>we can also express this rotation in terms of a quaternion <code>R</code> such that</p><pre><code class="language-none">v&#39; = R * v * R⁻¹.</code></pre><p>This function returns that quaternion, using Bar-Itzhack&#39;s algorithm to allow for non-orthogonal matrices.  <a href="http://dx.doi.org/10.2514/2.4654">J. Guidance, Vol. 23, No. 6, p. 1085</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/Quaternionic.jl/blob/52be295819bca1148fb156b6ebb04f3715cb5564/src/conversion.jl#L300-L317">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quaternionic.from_spherical_coordinates-Tuple{Any, Any}" href="#Quaternionic.from_spherical_coordinates-Tuple{Any, Any}"><code>Quaternionic.from_spherical_coordinates</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">from_spherical_coordinates(θ, ϕ)</code></pre><p>Return a quaternion corresponding to these spherical coordinates.</p><p>Considering (θ, ϕ) as a point <span>$n̂$</span> on the sphere, we can also construct a quaternion that rotates the <span>$z$</span> axis onto that point.  Here, we use the standard commonly used in physics: θ represents the &quot;polar angle&quot; between the <span>$z$</span> axis and the direction <span>$n̂$</span>, while ϕ represents the &quot;azimuthal angle&quot; between the <span>$x$</span> axis and the projection of <span>$n̂$</span> into the <span>$x$</span>-<span>$y$</span> plane. Both angles must be given in radians.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/Quaternionic.jl/blob/52be295819bca1148fb156b6ebb04f3715cb5564/src/conversion.jl#L279-L291">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quaternionic.to_euler_angles-Tuple{Quaternion}" href="#Quaternionic.to_euler_angles-Tuple{Quaternion}"><code>Quaternionic.to_euler_angles</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">to_euler_angles(R)</code></pre><p>Open Pandora&#39;s Box.</p><p>If somebody is trying to make you use Euler angles, tell them no, and walk away, and go and tell your mum.</p><p>You don&#39;t want to use Euler angles.  They are awful.  Stay away.  It&#39;s one thing to convert from Euler angles to quaternions; at least you&#39;re moving in the right direction.  But to go the other way?!  It&#39;s just not right.</p><p>Assumes the Euler angles correspond to the quaternion <code>R</code> via</p><pre><code class="language-none">R = exp(α𝐤/2) * exp(β𝐣/2) * exp(γ𝐤/2)</code></pre><p>where 𝐣 and 𝐤 rotate about the fixed <span>$y$</span> and <span>$z$</span> axes, respectively, so this reprents an initial rotation (in the positive sense) through an angle <span>$γ$</span> about the axis <span>$z$</span>, followed by a rotation through <span>$β$</span> about the axis <span>$y$</span>, and a final rotation through <span>$α$</span> about the axis <span>$z$</span>.  This is equivalent to performing an initial rotation through <span>$α$</span> about the axis <span>$z$</span>, followed by a rotation through <span>$β$</span> about the <em>rotated</em> axis <span>$y&#39;$</span>, followed by a rotation through <span>$γ$</span> about the <em>twice-rotated</em> axis <span>$z&#39;&#39;$</span>. The angles are naturally assumed to be in radians.</p><p>NOTE: Before opening an issue reporting something &quot;wrong&quot; with this function, be sure to read all of <a href="https://github.com/moble/quaternion/wiki/Euler-angles-are-horrible">this page</a>, <em>especially</em> the very last section about opening issues or pull requests.</p><p><strong>Returns</strong></p><ul><li><code>αβγ::Vector{T}</code></li></ul><p><strong>Raises</strong></p><ul><li><code>AllHell</code> if you try to actually use Euler angles, when you could have been using quaternions like a sensible person.</li></ul><p><strong>See Also</strong></p><ul><li><a href="#Quaternionic.from_euler_angles-Tuple{Any, Any, Any}"><code>from_euler_angles</code></a>: Create quaternion from Euler angles</li><li><a href="#Quaternionic.to_euler_phases-Union{Tuple{Quaternion{T}}, Tuple{T}} where T"><code>to_euler_phases</code></a>: Convert quaternion to Euler phases</li><li><a href="#Quaternionic.from_euler_phases-Tuple{Any, Any, Any}"><code>from_euler_phases</code></a>: Create quaternion from Euler phases</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/Quaternionic.jl/blob/52be295819bca1148fb156b6ebb04f3715cb5564/src/conversion.jl#L64-L105">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quaternionic.to_euler_phases-Union{Tuple{Quaternion{T}}, Tuple{T}} where T" href="#Quaternionic.to_euler_phases-Union{Tuple{Quaternion{T}}, Tuple{T}} where T"><code>Quaternionic.to_euler_phases</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">to_euler_phases(q)
to_euler_phases!(z, q)</code></pre><p>Convert input quaternion to complex phases of Euler angles</p><p>Interpreting the input quaternion as a rotation (though its normalization scales out), we can define the complex Euler phases from the Euler angles (α, β, γ) as</p><pre><code class="language-none">zₐ ≔ exp(i*α)
zᵦ ≔ exp(i*β)
zᵧ ≔ exp(i*γ)</code></pre><p>These are more useful geometric quantites than the angles themselves — being involved in computing spherical harmonics and Wigner&#39;s 𝔇 matrices — and can be computed from the components of the corresponding quaternion algebraically (without the use of transcendental functions).</p><p><strong>Returns</strong></p><ul><li><code>z::Vector{Complex{T}}</code>: complex phases (zₐ, zᵦ, zᵧ) in that order.</li></ul><p><strong>See Also</strong></p><ul><li><a href="#Quaternionic.from_euler_phases-Tuple{Any, Any, Any}"><code>from_euler_phases</code></a>: Create quaternion from Euler phases</li><li><a href="#Quaternionic.to_euler_angles-Tuple{Quaternion}"><code>to_euler_angles</code></a>: Convert quaternion to Euler angles</li><li><a href="#Quaternionic.from_euler_angles-Tuple{Any, Any, Any}"><code>from_euler_angles</code></a>: Create quaternion from Euler angles</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/Quaternionic.jl/blob/52be295819bca1148fb156b6ebb04f3715cb5564/src/conversion.jl#L176-L203">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quaternionic.to_float_array-Union{Tuple{AbstractArray{Quaternion{T}, N} where N}, Tuple{T}} where T&lt;:Real" href="#Quaternionic.to_float_array-Union{Tuple{AbstractArray{Quaternion{T}, N} where N}, Tuple{T}} where T&lt;:Real"><code>Quaternionic.to_float_array</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">to_float_array(A)</code></pre><p>View a quaternion array as an array of real numbers</p><p>The output array will have an extra initial dimension whose size is 4, because successive indices in that dimension correspond to successive components of the quaternion.</p><p>Note that this returns a view of the original data only if the base type of the input array <code>isbitstype</code>; otherwise, a new array of that type must be created, and the memory copied.</p><p>See also <a href="#Quaternionic.from_float_array-Union{Tuple{AbstractArray{T, N} where N}, Tuple{T}} where T&lt;:Real"><code>from_float_array</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/Quaternionic.jl/blob/52be295819bca1148fb156b6ebb04f3715cb5564/src/conversion.jl#L33-L47">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quaternionic.to_rotation_matrix-Tuple{Any}" href="#Quaternionic.to_rotation_matrix-Tuple{Any}"><code>Quaternionic.to_rotation_matrix</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">to_rotation_matrix(q)</code></pre><p>Convert quaternion to 3x3 rotation matrix.</p><p>Assuming the quaternion <code>R</code> rotates a vector <code>v</code> according to</p><pre><code class="language-none">v&#39; = R * v * R⁻¹,</code></pre><p>we can also express this rotation in terms of a 3x3 matrix <code>ℛ</code> such that</p><pre><code class="language-none">v&#39; = ℛ * v.</code></pre><p>This function returns that matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/Quaternionic.jl/blob/52be295819bca1148fb156b6ebb04f3715cb5564/src/conversion.jl#L340-L355">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quaternionic.to_spherical_coordinates-Tuple{Quaternion}" href="#Quaternionic.to_spherical_coordinates-Tuple{Quaternion}"><code>Quaternionic.to_spherical_coordinates</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">to_spherical_coordinates(q)</code></pre><p>Return the spherical coordinates corresponding to this quaternion.</p><p>We can treat the quaternion as a transformation taking the <span>$z$</span> axis to some direction <span>$n̂$</span>.  This direction can be described in terms of spherical coordinates (θ, ϕ).  Here, we use the standard commonly used in physics: θ represents the &quot;polar angle&quot; between the <span>$z$</span> axis and the direction <span>$n̂$</span>, while ϕ represents the &quot;azimuthal angle&quot; between the <span>$x$</span> axis and the projection of <span>$n̂$</span> into the <span>$x$</span>-<span>$y$</span> plane.  Both angles are given in radians.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/Quaternionic.jl/blob/52be295819bca1148fb156b6ebb04f3715cb5564/src/conversion.jl#L256-L269">source</a></section></article><h2 id="Distances"><a class="docs-heading-anchor" href="#Distances">Distances</a><a id="Distances-1"></a><a class="docs-heading-anchor-permalink" href="#Distances" title="Permalink"></a></h2><p>There are several ways of measuring the &quot;distance&quot; between two quaternions: <span>$d(q_1, q_2)$</span>.  Fundamentally, any comparison between two quaternions <span>$q_1$</span> and <span>$q_2$</span> must make use of a binary operation, for which there are two obvious choices: addition or multiplication.  For either choice, we operate on <span>$q_1$</span> and the appropriate inverse (either additive or multiplicative) of <span>$q_2$</span>.  That is, <span>$d$</span> should be a function of either <span>$q_1 - q_2$</span> or <span>$q_1/q_2$</span>.<sup class="footnote-reference"><a id="citeref-1" href="#footnote-1">[1]</a></sup></p><p>Now, we also have a number of criteria we would like any distance function to satisfy.  For any quaternions <span>$q_1$</span> and <span>$q_2$</span> and any <em>unit</em> quaternion <span>$q_3$</span>, we require</p><ul><li>real-valued: <span>$d(q_1, q_2) \in \mathbb{R}$</span></li><li>symmetry: <span>$d(q_1, q_2) = d(q_2, q_1)$</span></li><li>invariance: <span>$d(q_3\, q_1, q_3\, q_2) = d(q_1, q_2) = d(q_1\, q_3, q_2\, q_3)$</span></li><li>identity: <span>$d(q_1, q_1) = 0$</span></li><li>positive-definiteness: <span>$d(q_1, q_2) &gt; 0$</span> whenever <span>$q_1 ≠ q_2$</span></li></ul><p>(Of course, it should be noted that these criteria all hold in the <em>exact</em> case; when using floating-point numbers, will likely be violated near edge cases.)</p><p>It is not hard to see that these criteria can be satisfied by any of</p><ul><li><code>abs2(q₁ - q₂)</code></li><li><code>abs(q₁ - q₂)</code></li><li><code>abs2(log(q₁ / q₂)</code></li><li><code>abs(log(q₁ / q₂))</code></li></ul><p>If <span>$q_1$</span> and <span>$q_2$</span> are interpreted as rotations, we frequently don&#39;t care about their signs, and just want the <em>smallest</em> distance between them, for any choice of sign.  Furthermore, in the multiplicative case, the <code>log</code> functions will involve calculation of the <code>log</code> of the magnitudes of the quaternions, which should be 1.  In this case, we relax the &quot;positive-definiteness&quot; criterion to allow <span>$d(q_1, q_2)$</span> to equal zero when <span>$q_1$</span> and <span>$q_2$</span> are related by a nonzero scalar multiple.</p><p>While these functions are simple to implement as needed, it is also useful to have a single function to remind us of all the possibilities.  The <a href="#Quaternionic.distance-Tuple{Any, Any}"><code>distance</code></a> function implements all these possible choices with keyword arguments.  The <a href="#Quaternionic.distance_rotation-Tuple{Any, Any}"><code>distance_rotation</code></a> function is similar, but restricts to the multiplicative case, and assumes rotations.  These two functions, with their default arguments, are likely to be the most commonly needed functions.</p><article class="docstring"><header><a class="docstring-binding" id="Quaternionic.distance-Tuple{Any, Any}" href="#Quaternionic.distance-Tuple{Any, Any}"><code>Quaternionic.distance</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">distance(q₁, q₂; multiplicative=false, sqrt=false, rotation=false)</code></pre><p>Measure the &quot;distance&quot; between two quaternions.</p><p>By default, this function just returns the natural measure in the <em>additive</em> group of quaternions:</p><pre><code class="language-julia">abs2(q₁ - q₂)</code></pre><p>If <code>multiplicative=true</code> is passed as a keyword, the function returns the natural measure in the <em>multiplicative</em> group:</p><pre><code class="language-julia">abs2(log(q₁ / q₂))</code></pre><p>[Note that this will return <code>NaN</code> if either input is 0.]</p><p>If <code>sqrt=true</code> is passed, the square-root of the result will be taken (so, <code>abs</code> instead of <code>abs2</code>).</p><p>Finally, if <code>rotation=true</code> is passed, the input quaternions will be interpreted as quaternions, in which case the result will be the smallest possible value for any combination of their signs.</p><p>See also <a href="#Quaternionic.distance_rotation-Tuple{Any, Any}"><code>distance_rotation</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; distance(imz, -imz)
4
julia&gt; distance(imz, -imz, rotation=true)
0
julia&gt; distance(1, imx, multiplicative=true, sqrt=true)  # π/2
1.5707963267948966</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/Quaternionic.jl/blob/52be295819bca1148fb156b6ebb04f3715cb5564/src/distance.jl#L1-L37">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quaternionic.distance_rotation-Tuple{Any, Any}" href="#Quaternionic.distance_rotation-Tuple{Any, Any}"><code>Quaternionic.distance_rotation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">distance_rotation(q₁, q₂; sqrt=false)</code></pre><p>Return <code>abs2(log(q₁/q₂))</code>, but assume that the signs and magnitudes of the input quaternions do not matter.  If <code>sqrt=true</code>, we return the square-root of that result.</p><p>This function is just a simple wrapper calling the <a href="#Quaternionic.distance-Tuple{Any, Any}"><code>distance</code></a> function as</p><pre><code class="language-julia">distance(q₁, q₂; multiplicative=true, sqrt=sqrt, rotation=true)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/Quaternionic.jl/blob/52be295819bca1148fb156b6ebb04f3715cb5564/src/distance.jl#L71-L83">source</a></section></article><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-1"><a class="tag is-link" href="#citeref-1">1</a>For <span>$q_1/q_2$</span>, we are dealing with the <em>multiplicative</em> group of quaternions, which does not include 0, so we will assume that no quaternion involved in such a function can be 0.</li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Introduction</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Tuesday 15 June 2021 20:13">Tuesday 15 June 2021</span>. Using Julia version 1.6.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
