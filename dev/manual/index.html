<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Manual · Quaternionic.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">Quaternionic.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction</a></li><li class="is-active"><a class="tocitem" href>Manual</a><ul class="internal"><li><a class="tocitem" href="#Constructors,-constants,-and-conversions"><span>Constructors, constants, and conversions</span></a></li><li><a class="tocitem" href="#Number-functions-from-Base"><span>Number functions from Base</span></a></li><li><a class="tocitem" href="#Algebra-and-mathematical-functions"><span>Algebra and mathematical functions</span></a></li><li><a class="tocitem" href="#Random-quaternions"><span>Random quaternions</span></a></li><li><a class="tocitem" href="#Conversions"><span>Conversions</span></a></li><li><a class="tocitem" href="#Distances"><span>Distances</span></a></li><li class="toplevel"><a class="tocitem" href="#Interpolation"><span>Interpolation</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Manual</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Manual</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/moble/Quaternionic.jl/blob/main/docs/src/manual.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Quaternionic-functions"><a class="docs-heading-anchor" href="#Quaternionic-functions">Quaternionic functions</a><a id="Quaternionic-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Quaternionic-functions" title="Permalink"></a></h1><p>From <code>AbstractQuaternion{T}</code> we define three subtypes:</p><ul><li><code>Quaternion{T}</code>, which is an element of the general algebra of quaternions over any <code>T&lt;:Real</code>.</li><li><code>Rotor{T}</code>, which is an element of the multiplicative group of unit quaternions, and is interpreted as mapping to a rotation.  The magnitude is <em>assumed</em> to be 1 (though, for efficiency, this is not generally confirmed), and the sign may be freely changed in certain cases.</li><li><code>QuatVec{T}</code>, which is an element of the additive group of quaternions with 0 scalar part; a &quot;pure vector&quot; quaternion.</li></ul><p>For simplicity, almost every function in this package is defined for general <code>Quaternion</code>s, so you may not need any other type.  However, it can frequently be more accurate <em>and</em> more efficient to use the other subtypes where relevant.</p><h2 id="Constructors,-constants,-and-conversions"><a class="docs-heading-anchor" href="#Constructors,-constants,-and-conversions">Constructors, constants, and conversions</a><a id="Constructors,-constants,-and-conversions-1"></a><a class="docs-heading-anchor-permalink" href="#Constructors,-constants,-and-conversions" title="Permalink"></a></h2><p>At the most basic level, <code>Quaternion{T}</code> mimics <code>Complex{T}</code> as closely as possible, including the behavior of most functions in <code>Base</code>.  The <code>Rotor{T}</code> and <code>QuatVec{T}</code> subtypes behave very similarly, except that most of their constructors automatically impose the constraints that the norm is 1 and the scalar component is 0, respectively.  Also note that when a certain operation is not defined for either of those subtypes, the functions will usually convert to a general <code>Quaternion</code> automatically.</p><p>To create new <code>Quaternion</code>s interactively, it is typically most convenient to use the constants <code>imx</code>, <code>imy</code>, and <code>imz</code> — or equivalently <code>𝐢</code>, <code>𝐣</code>, and <code>𝐤</code> — multiplied by appropriate factors and added together.  For programmatic work, it is more common to use the <a href="#Quaternionic.Quaternion"><code>Quaternion</code></a> function — which takes all four components, the three vector components, or just the one scalar component, and creates a new <code>Quaternion</code> of the type implied by the arguments.  You can also <em>specify</em> the type, as in <code>Quaternion{Float64}(...)</code>.  Type conversions with <code>promote</code>, <code>widen</code>, <code>float</code>, etc., work as expected.</p><article class="docstring"><header><a class="docstring-binding" id="Quaternionic.QuatVec" href="#Quaternionic.QuatVec"><code>Quaternionic.QuatVec</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">QuatVec{T&lt;:Real} &lt;: Number</code></pre><p>Pure-vector quaternion with elements of type <code>T</code>.  These objects can be significantly faster <em>and</em> more accurate in certain operations than general <code>Quaternion</code>s.</p><p><code>QuatVecF16</code>, <code>QuatVecF32</code> and <code>QuatVecF64</code> are aliases for <code>QuatVec{Float16}</code>, <code>QuatVec{Float32}</code> and <code>QuatVec{Float64}</code> respectively.  See also <a href="#Quaternionic.Quaternion"><code>Quaternion</code></a> and <a href="#Quaternionic.Rotor"><code>Rotor</code></a>.</p><p>The functions</p><pre><code class="language-none">QuatVec(w, x, y, z)
QuatVec(x, y, z)
QuatVec(w)
QuatVec{T}(w, x, y, z)</code></pre><p>create a new rotor with the given components (where the components are as described in <a href="#Quaternionic.Quaternion"><code>Quaternion</code></a>), except that the scalar argument <code>w</code> is always set to 0.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; QuatVec(1, 2, 3, 4)
0 + 2𝐢 + 3𝐣 + 4𝐤
julia&gt; QuatVec(Quaternion(1, 2, 3, 4))
0 + 2𝐢 + 3𝐣 + 4𝐤
julia&gt; QuatVec(2, 3, 4)
0 + 2𝐢 + 3𝐣 + 4𝐤
julia&gt; QuatVec(1)
0 + 0𝐢 + 0𝐣 + 0𝐤</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/Quaternionic.jl/blob/e5554101723b232d4fd58d637bde1c316322c9b1/src/quaternion.jl#L122-L156">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quaternionic.Quaternion" href="#Quaternionic.Quaternion"><code>Quaternionic.Quaternion</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Quaternion{T&lt;:Real} &lt;: Number</code></pre><p>Quaternionic number type with elements of type <code>T</code>.</p><p><code>QuaternionF16</code>, <code>QuaternionF32</code> and <code>QuaternionF64</code> are aliases for <code>Quaternion{Float16}</code>, <code>Quaternion{Float32}</code> and <code>Quaternion{Float64}</code> respectively.  See also <a href="#Quaternionic.Rotor"><code>Rotor</code></a> and <a href="#Quaternionic.QuatVec"><code>QuatVec</code></a>.</p><p>The functions</p><pre><code class="language-none">Quaternion(w, x, y, z)
Quaternion(x, y, z)
Quaternion(w)
Quaternion{T}(w, x, y, z)</code></pre><p>create a new quaternion with the given components.  The argument <code>w</code> is the scalar component, and <code>x</code>, <code>y</code>, and <code>z</code> are the corresponding &quot;vector&quot; components.  If any of these arguments is missing, it will be set to zero.  The type of the returned quaternion will be inferred from the input arguments, or can be specified, by passing the type parameter <code>T</code> as above.</p><p>Note that the constants <a href="#Quaternionic.imx"><code>imx</code></a>, <a href="#Quaternionic.imy"><code>imy</code></a>, and <a href="#Quaternionic.imz"><code>imz</code></a> can also be used like the complex <code>im</code> to create new <code>Quaternion</code> object.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; Quaternion(1, 2, 3, 4)
1 + 2𝐢 + 3𝐣 + 4𝐤
julia&gt; Quaternion{Float64}(1, 2, 3, 4)
1.0 + 2.0𝐢 + 3.0𝐣 + 4.0𝐤
julia&gt; Quaternion(1.0, 2.0, 3.0, 4.0)
1.0 + 2.0𝐢 + 3.0𝐣 + 4.0𝐤
julia&gt; Quaternion(2, 3, 4)
0 + 2𝐢 + 3𝐣 + 4𝐤
julia&gt; Quaternion(1)
1 + 0𝐢 + 0𝐣 + 0𝐤</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/Quaternionic.jl/blob/e5554101723b232d4fd58d637bde1c316322c9b1/src/quaternion.jl#L1-L40">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quaternionic.Rotor" href="#Quaternionic.Rotor"><code>Quaternionic.Rotor</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Rotor{T&lt;:Real} &lt;: Number</code></pre><p>Quaternion of unit magnitude with elements of type <code>T</code>.  These objects can be significantly faster <em>and</em> more accurate in certain operations representing rotations.</p><p>A rotor is typically considered to be an element of the group <span>$\mathrm{Spin}(3) ≃ \mathrm{SU}(2)$</span>, which can be thought of as the subgroup of quaternions with norm 1.  They are particularly useful as representations of rotations because a rotor <span>$R$</span> acts on a vector <span>$\vec{v}$</span> by &quot;conjugation&quot; as</p><p class="math-container">\[\vec{v}&#39; = R\, \vec{v}\, R^{-1}.\]</p><p>This preserves the inner product between any two vectors conjugated in this way, and so is a rotation.  Note that, because there are two factors of <span>$R$</span> here, the sign of <span>$R$</span> does not affect the result.  Therefore, <span>$\mathrm{Spin}(3)$</span> forms a <em>double</em> cover of the rotation group <span>$\mathrm{SO}(3)$</span>.  For this reason, it will occasionally be useful to disregard or arbitrarily change the sign of a <code>Rotor</code> (as in <a href="#Quaternionic.distance-Tuple{AbstractQuaternion, AbstractQuaternion}"><code>distance</code></a> functions) — though this is not generally the default, and may cause problems if the input rotors change sign when the corresponding rotations are not so different (cf. <a href="#Quaternionic.unflip-Tuple{AbstractArray{var&quot;#s8&quot;, N} where {var&quot;#s8&quot;&lt;:AbstractQuaternion, N}}"><code>unflip</code></a>).</p><p><code>RotorF16</code>, <code>RotorF32</code> and <code>RotorF64</code> are aliases for <code>Rotor{Float16}</code>, <code>Rotor{Float32}</code> and <code>Rotor{Float64}</code> respectively.  See also <a href="#Quaternionic.Quaternion"><code>Quaternion</code></a> and <a href="#Quaternionic.QuatVec"><code>QuatVec</code></a>.</p><p>The functions</p><pre><code class="language-none">Rotor(w, x, y, z)
Rotor(x, y, z)
Rotor(w)
Rotor{T}(w, x, y, z)</code></pre><p>create a new rotor with the given components (where the components are as described in <a href="#Quaternionic.Quaternion"><code>Quaternion</code></a>), automatically normalizing them on input. If you would like to bypass this normalization step, you can call</p><pre><code class="language-none">Rotor{T}(v)</code></pre><p>where <code>v&lt;:AbstractArray</code>, and can be converted to an <code>SVector{4, T}</code>.</p><p>However, once a <code>Rotor</code> is created, its norm will always be assumed to be precisely 1.  So if its true norm is significantly different, you will like see weird results — including vectors with very different lengths after &quot;rotation&quot; by a non-unit <code>Rotor</code>.</p><p>Note that simply creating a <code>Quaternion</code> that happens to have norm 1 does not make it a <code>Rotor</code>.  However, you can pass such a <code>Quaternion</code> to the <code>Rotor</code> function and get the desired result.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; Rotor(1, 2, 3, 4)
0.18257418583505536 + 0.3651483716701107𝐢 + 0.5477225575051661𝐣 + 0.7302967433402214𝐤
julia&gt; Rotor(Quaternion(1, 2, 3, 4))
0.18257418583505536 + 0.3651483716701107𝐢 + 0.5477225575051661𝐣 + 0.7302967433402214𝐤
julia&gt; Rotor{Float16}(1, 2, 3, 4)
0.1826 + 0.3652𝐢 + 0.548𝐣 + 0.7305𝐤
julia&gt; Rotor(2, 3, 4)
0.0 + 0.3713906763541037𝐢 + 0.5570860145311556𝐣 + 0.7427813527082074𝐤
julia&gt; Rotor(1)
1 + 0𝐢 + 0𝐣 + 0𝐤</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/Quaternionic.jl/blob/e5554101723b232d4fd58d637bde1c316322c9b1/src/quaternion.jl#L47-L115">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quaternionic.imx" href="#Quaternionic.imx"><code>Quaternionic.imx</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia">imx</code></pre><p>The quaternionic unit associated with rotation about the <code>x</code> axis.  Can also be entered as Unicode bold: <code>𝐢</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; imx * imx
-1 + 0𝐢 + 0𝐣 + 0𝐤
julia&gt; 1.2imx
0.0 + 1.2𝐢 + 0.0𝐣 + 0.0𝐤</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/Quaternionic.jl/blob/e5554101723b232d4fd58d637bde1c316322c9b1/src/quaternion.jl#L223-L236">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quaternionic.imy" href="#Quaternionic.imy"><code>Quaternionic.imy</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia">imy</code></pre><p>The quaternionic unit associated with rotation about the <code>y</code> axis.  Can also be entered as Unicode bold: <code>𝐣</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; imy * imy
-1 + 0𝐢 + 0𝐣 + 0𝐤
julia&gt; 1.2imy
0.0 + 0.0𝐢 + 1.2𝐣 + 0.0𝐤</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/Quaternionic.jl/blob/e5554101723b232d4fd58d637bde1c316322c9b1/src/quaternion.jl#L240-L253">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quaternionic.imz" href="#Quaternionic.imz"><code>Quaternionic.imz</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia">imz</code></pre><p>The quaternionic unit associated with rotation about the <code>z</code> axis.  Can also be entered as Unicode bold: <code>𝐤</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; imz * imz
-1 + 0𝐢 + 0𝐣 + 0𝐤
julia&gt; 1.2imz
0.0 + 0.0𝐢 + 0.0𝐣 + 1.2𝐤</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/Quaternionic.jl/blob/e5554101723b232d4fd58d637bde1c316322c9b1/src/quaternion.jl#L257-L270">source</a></section></article><h2 id="Number-functions-from-Base"><a class="docs-heading-anchor" href="#Number-functions-from-Base">Number functions from Base</a><a id="Number-functions-from-Base-1"></a><a class="docs-heading-anchor-permalink" href="#Number-functions-from-Base" title="Permalink"></a></h2><p>The standard <a href="https://docs.julialang.org/en/v1/base/numbers/#General-Number-Functions-and-Constants"><code>Number</code> functions</a> that work for <code>Complex</code>, such as <code>isfinite</code>, <code>iszero</code>, etc., should work analogously for <code>Quaternion</code>.  The <code>hash</code>, <code>read</code>, and <code>write</code> functions are also implemented.  As noted in the <a href="../#Examples">Examples</a>, broadcasting to each component is also implemented via <code>broadcasted</code>.</p><h2 id="Algebra-and-mathematical-functions"><a class="docs-heading-anchor" href="#Algebra-and-mathematical-functions">Algebra and mathematical functions</a><a id="Algebra-and-mathematical-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Algebra-and-mathematical-functions" title="Permalink"></a></h2><p>Along with the basic binary operators, the essential mathematical functions like <a href="#Base.conj-Tuple{Q} where Q&lt;:AbstractQuaternion"><code>conj</code></a>, <a href="#Base.abs-Tuple{AbstractQuaternion}"><code>abs</code></a>, <a href="#Base.abs2-Tuple{AbstractQuaternion}"><code>abs2</code></a>, <a href="#Base.exp-Union{Tuple{Quaternion{T}}, Tuple{T}} where T"><code>exp</code></a>, <a href="#Base.log-Union{Tuple{Quaternion{T}}, Tuple{T}} where T"><code>log</code></a>, etc., are implemented.  Most of these functions are found in the <code>Base</code> module, and are simply overloaded methods of functions that should also be familiar from <code>Complex</code> types.  Note that we use a slightly different interpretation of <a href="#Base.angle-Union{Tuple{Quaternion{T}}, Tuple{T}} where T"><code>angle</code></a> for <code>Quaternion</code>, compared to <code>Complex</code>.  We also have <a href="#Quaternionic.absvec-Tuple{AbstractQuaternion}"><code>absvec</code></a> and <a href="#Quaternionic.abs2vec-Tuple{AbstractQuaternion}"><code>abs2vec</code></a>, which are not useful in a <code>Complex</code> context, but compute the relevant quantities for the &quot;vector&quot; component of a <code>Quaternion</code>.</p><article class="docstring"><header><a class="docstring-binding" id="Base.conj-Tuple{Q} where Q&lt;:AbstractQuaternion" href="#Base.conj-Tuple{Q} where Q&lt;:AbstractQuaternion"><code>Base.conj</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">conj(q)</code></pre><p>Return the quaternion conjugate, which flips the sign of each &quot;vector&quot; component.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; conj(Quaternion(1,2,3,4))
1 - 2𝐢 - 3𝐣 - 4𝐤</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/Quaternionic.jl/blob/e5554101723b232d4fd58d637bde1c316322c9b1/src/algebra.jl#L3-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quaternionic.:⋅-Union{Tuple{Q}, Tuple{P}, Tuple{P, P}} where {P&lt;:AbstractQuaternion, Q&lt;:AbstractQuaternion}" href="#Quaternionic.:⋅-Union{Tuple{Q}, Tuple{P}, Tuple{P, P}} where {P&lt;:AbstractQuaternion, Q&lt;:AbstractQuaternion}"><code>Quaternionic.:⋅</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">p ⋅ q</code></pre><p>Evaluate the inner (&quot;dot&quot;) product between two quaternions.  Equal to the scalar part of <code>p * conj(q)</code>.</p><p>Note that this function is not very commonly used, except as a quick way to determine whether the two quaternions are more anti-parallel than parallel, for functions like <a href="#Quaternionic.unflip-Tuple{AbstractArray{var&quot;#s8&quot;, N} where {var&quot;#s8&quot;&lt;:AbstractQuaternion, N}}"><code>unflip</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/Quaternionic.jl/blob/e5554101723b232d4fd58d637bde1c316322c9b1/src/algebra.jl#L63-L72">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.abs-Tuple{AbstractQuaternion}" href="#Base.abs-Tuple{AbstractQuaternion}"><code>Base.abs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">abs(q)</code></pre><p>Square-root of the sum the squares of the components of the quaternion</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; abs(Quaternion(1,2,4,10))
11.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/Quaternionic.jl/blob/e5554101723b232d4fd58d637bde1c316322c9b1/src/math.jl#L17-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.abs2-Tuple{AbstractQuaternion}" href="#Base.abs2-Tuple{AbstractQuaternion}"><code>Base.abs2</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">abs2(q)</code></pre><p>Sum the squares of the components of the quaternion</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; abs2(Quaternion(1,2,4,10))
121</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/Quaternionic.jl/blob/e5554101723b232d4fd58d637bde1c316322c9b1/src/math.jl#L3-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.angle-Union{Tuple{Quaternion{T}}, Tuple{T}} where T" href="#Base.angle-Union{Tuple{Quaternion{T}}, Tuple{T}} where T"><code>Base.angle</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">angle(q)</code></pre><p>Phase angle in radians of the rotation represented by this quaternion.</p><p>Note that this may be different from your interpretation of the angle of a complex number in an important way.  Because quaternions act on vectors by conjugation — as in <code>q*v*conj(q)</code> — there are <em>two</em> copies of <code>q</code> involved in that expression; in some sense, a quaternion acts &quot;twice&quot;.  Therefore, this angle may be twice what you expect from an analogy with complex numbers — dpending on how you interpret the correspondence between complex numbers and quaternions.  Also, while rotations in the complex plane have a natural choice of axis (the positive <code>z</code> direction), that is not the case for quaternions, which means that the sign of this angle is arbitrary, and we always choose it to be positive.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; θ=1.2;

julia&gt; R=exp(θ * imz / 2);

julia&gt; angle(R)
1.2
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/Quaternionic.jl/blob/e5554101723b232d4fd58d637bde1c316322c9b1/src/math.jl#L226-L252">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.exp-Union{Tuple{Quaternion{T}}, Tuple{T}} where T" href="#Base.exp-Union{Tuple{Quaternion{T}}, Tuple{T}} where T"><code>Base.exp</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">exp(q)</code></pre><p>Exponential of a quaternion</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; exp(imx*π/4)  # Rotation through π/2 (note the extra 1/2) about the x axis
0.7071067811865476 + 0.7071067811865475𝐢 + 0.0𝐣 + 0.0𝐤</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/Quaternionic.jl/blob/e5554101723b232d4fd58d637bde1c316322c9b1/src/math.jl#L123-L133">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.log-Union{Tuple{Quaternion{T}}, Tuple{T}} where T" href="#Base.log-Union{Tuple{Quaternion{T}}, Tuple{T}} where T"><code>Base.log</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">log(q)</code></pre><p>Logarithm of a quaternion.</p><p>As with the usual complex logarithm, the quaternion logarithm has multiple branches, though the quaternion branches are three-dimensional: for any unit &quot;vector&quot; quaternion q̂, you could add any integer multiple of 2πq̂ to the result of this function and still get the same result after exponentiating (within numerical accuracy).  This function is the principal logarithm.</p><p>This function has discontinuous (and fairly arbitrary) behavior along the negative real axis: if the &quot;vector&quot; components of the quaternion are precisely zero <em>and</em> the scalar component is negative, the returned quaternion will have scalar component <code>log(-q.w)</code>, but will also have a <code>z</code> component of π.  The choice of the <code>z</code> direction is arbitrary; the &quot;vector&quot; component of the returned quaternion could be π times any unit vector.</p><p>Note that this function is not specialized to unit-quaternion inputs, so the scalar component of the returned value will be nonzero unless the input has <em>precisely</em> unit magnitude.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; log(exp(1.2imy))
0.0 + 0.0𝐢 + 1.2𝐣 + 0.0𝐤

julia&gt; log(Quaternion(exp(7)))
7.0 + 0.0𝐢 + 0.0𝐣 + 0.0𝐤

julia&gt; log(Quaternion(-exp(7)))
7.0 + 0.0𝐢 + 0.0𝐣 + 3.141592653589793𝐤</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/Quaternionic.jl/blob/e5554101723b232d4fd58d637bde1c316322c9b1/src/math.jl#L61-L95">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.sqrt-Union{Tuple{Quaternion{T}}, Tuple{T}} where T" href="#Base.sqrt-Union{Tuple{Quaternion{T}}, Tuple{T}} where T"><code>Base.sqrt</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">sqrt(q)</code></pre><p>Square-root of a quaternion.</p><p>The general formula whenever the denominator is nonzero is</p><p class="math-container">\[\sqrt{q} = \frac{|q| + q} {\sqrt{2|q| + 2q.w}}\]</p><p>This can be proven by expanding <code>q</code> as <code>q.w + q.vec</code> and multiplying the expression above by itself.</p><p>When the denominator is zero, this function has discontinuous (and fairly arbitrary) behavior, just as with the quaternion <a href="#Base.log-Union{Tuple{Quaternion{T}}, Tuple{T}} where T"><code>log</code></a> function.  In this case, either all components are zero — in which case the result is simply the zero quaternion — or the &quot;vector&quot; components of the quaternion are precisely zero and the scalar component is negative.  If the latter is true, the denominator above will be a pure-imaginary number.  Because the quaternions come with infinitely many elements that square to -1, it is not clear <em>which</em> imaginary should be used, so we arbitrarily choose to set the result proportional to the <code>z</code> quaternion.  The choice of the <code>z</code> direction is arbitrary; the &quot;vector&quot; component of the returned quaternion could be in any direction.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; q = Quaternion(1.2, 3.4, 5.6, 7.8);

julia&gt; sqrtq = √q;

julia&gt; sqrtq^2 ≈ q
true

julia&gt; √Quaternion(4)
2.0 + 0.0𝐢 + 0.0𝐣 + 0.0𝐤

julia&gt; √Quaternion(-4)
0.0 + 0.0𝐢 + 0.0𝐣 + 2.0𝐤</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/Quaternionic.jl/blob/e5554101723b232d4fd58d637bde1c316322c9b1/src/math.jl#L156-L197">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quaternionic.abs2vec-Tuple{AbstractQuaternion}" href="#Quaternionic.abs2vec-Tuple{AbstractQuaternion}"><code>Quaternionic.abs2vec</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">abs2vec(q)</code></pre><p>Sum the squares of the &quot;vector&quot; components of the quaternion</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; abs2vec(Quaternion(1,2,3,6))
49</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/Quaternionic.jl/blob/e5554101723b232d4fd58d637bde1c316322c9b1/src/math.jl#L31-L41">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quaternionic.absvec-Tuple{AbstractQuaternion}" href="#Quaternionic.absvec-Tuple{AbstractQuaternion}"><code>Quaternionic.absvec</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">absvec(q)</code></pre><p>Square-root of the sum of the squares of the &quot;vector&quot; components of the quaternion</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; absvec(Quaternion(1,2,3,6))
7.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/Quaternionic.jl/blob/e5554101723b232d4fd58d637bde1c316322c9b1/src/math.jl#L44-L54">source</a></section></article><h2 id="Random-quaternions"><a class="docs-heading-anchor" href="#Random-quaternions">Random quaternions</a><a id="Random-quaternions-1"></a><a class="docs-heading-anchor-permalink" href="#Random-quaternions" title="Permalink"></a></h2><p>It is frequently convenient to construct random <code>Quaternion</code> objects, which can be done just as with other types by passing the desired output type to the <a href="#Base.randn-Union{Tuple{T}, Tuple{Random.AbstractRNG, Type{var&quot;#s11&quot;} where var&quot;#s11&quot;&lt;:AbstractQuaternion{T}}} where T&lt;:AbstractFloat"><code>randn</code></a> function.  The <code>rand</code> function is not overloaded, because there would be no geometric significance to such a <code>Quaternion</code>; <code>randn</code> results are independent of the orientation of the basis used to define the quaternions. Note that it is possible to get random <em>rotors</em> and <em>vectors</em> by passing the appropriate tyepes to the <code>randn</code> function.</p><article class="docstring"><header><a class="docstring-binding" id="Base.randn-Union{Tuple{T}, Tuple{Random.AbstractRNG, Type{var&quot;#s11&quot;} where var&quot;#s11&quot;&lt;:AbstractQuaternion{T}}} where T&lt;:AbstractFloat" href="#Base.randn-Union{Tuple{T}, Tuple{Random.AbstractRNG, Type{var&quot;#s11&quot;} where var&quot;#s11&quot;&lt;:AbstractQuaternion{T}}} where T&lt;:AbstractFloat"><code>Base.randn</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">randn([rng=GLOBAL_RNG], T=Quaternion{Float64}, [dims...])</code></pre><p>Generate a normally distributed random quaternion of type <code>T</code> with mean 0 and standard deviation of norm 1.  Optionally generate an <em>array</em> of such quaternions.  This module currently provides an implementation for the types <code>QuaternionF16</code>, <code>QuaternionF32</code>, and <code>QuaternionF64</code> (the default).  The values are drawn from the spherically symmetric quaternionic normal distribution of variance 1 (corresponding to each component having independent normal distribution with mean zero and variance 1/4).</p><p>Note that this function works with <code>Quaternion{BigFloat}</code>, even though <code>Base.randn</code> does not work with <code>BigFloat</code>; we just use the <a href="https://en.wikipedia.org/wiki/Box–Muller_transform">Box-Muller transform</a> to obtain the desired result.</p><p>If the quaternion type passed in is <code>Rotor</code>, the result will be normalized correctly. Because the distribution is spherically symmetric, the result is a truly random rotation.</p><p>If the quaternion type is <code>QuatVec</code>, the result will have a 0 scalar component, and the vector will have mean 0 standard deviation of norm 1.</p><p><strong>Examples</strong></p><pre><code class="language-julia">julia&gt; randn(QuaternionF64)
0.4336736009756228 - 0.45087190792840853𝐢 - 0.24723937675211696𝐣 - 0.4514571469326208𝐤
julia&gt; randn(QuaternionF16, 2, 2)
2×2 Matrix{QuaternionF16}:
   0.4321 + 1.105𝐢 + 0.2664𝐣 - 0.1359𝐤   0.064 + 0.9263𝐢 - 0.4138𝐣 + 0.05505𝐤
 0.2512 - 0.2585𝐢 - 0.2803𝐣 - 0.00964𝐤  -0.1256 + 0.1848𝐢 + 0.03607𝐣 - 0.752𝐤</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/Quaternionic.jl/blob/e5554101723b232d4fd58d637bde1c316322c9b1/src/random.jl#L1-L33">source</a></section></article><h2 id="Conversions"><a class="docs-heading-anchor" href="#Conversions">Conversions</a><a id="Conversions-1"></a><a class="docs-heading-anchor-permalink" href="#Conversions" title="Permalink"></a></h2><p>It can sometimes be useful to convert between quaternions and other representations.  Most of these functions are named <code>to_&lt;representation&gt;</code> and have a corresponding <code>from_&lt;representation&gt;</code> function.  Furthermore, most convert to/from representations of rotations.  While rotations are not the only useful application of quaternions, they are probably the most common.  The only conversions that are not specifically related to rotations are <a href="#Quaternionic.to_float_array-Union{Tuple{AbstractArray{var&quot;#s11&quot;, N} where {var&quot;#s11&quot;&lt;:AbstractQuaternion{T}, N}}, Tuple{T}} where T&lt;:Real"><code>to_float_array</code></a> and <a href="#Quaternionic.from_float_array-Union{Tuple{AbstractArray{T, N} where N}, Tuple{T}} where T&lt;:Real"><code>from_float_array</code></a>.</p><article class="docstring"><header><a class="docstring-binding" id="Quaternionic.from_euler_angles-Tuple{Any, Any, Any}" href="#Quaternionic.from_euler_angles-Tuple{Any, Any, Any}"><code>Quaternionic.from_euler_angles</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">from_euler_angles(α, β, γ)</code></pre><p>Come over from the dark side.</p><p>Assumes the Euler angles correspond to the quaternion <code>R</code> via</p><pre><code class="language-none">R = exp(α𝐤/2) * exp(β𝐣/2) * exp(γ𝐤/2)</code></pre><p>where 𝐣 and 𝐤 rotate about the fixed <span>$y$</span> and <span>$z$</span> axes, respectively, so this reprents an initial rotation (in the positive sense) through an angle <span>$γ$</span> about the axis <span>$z$</span>, followed by a rotation through <span>$β$</span> about the axis <span>$y$</span>, and a final rotation through <span>$α$</span> about the axis <span>$z$</span>.  This is equivalent to performing an initial rotation through <span>$α$</span> about the axis <span>$z$</span>, followed by a rotation through <span>$β$</span> about the <em>rotated</em> axis <span>$y&#39;$</span>, followed by a rotation through <span>$γ$</span> about the <em>twice-rotated</em> axis <span>$z&#39;&#39;$</span>. The angles are naturally assumed to be in radians.</p><p>NOTE: Before opening an issue reporting something &quot;wrong&quot; with this function, be sure to read all of <a href="https://github.com/moble/quaternion/wiki/Euler-angles-are-horrible">this page</a>, <em>especially</em> the very last section about opening issues or pull requests.</p><p><strong>See Also</strong></p><ul><li><a href="#Quaternionic.to_euler_angles-Tuple{AbstractQuaternion}"><code>to_euler_angles</code></a>: Convert quaternion to Euler angles</li><li><a href="#Quaternionic.to_euler_phases-Union{Tuple{AbstractQuaternion{T}}, Tuple{T}} where T"><code>to_euler_phases</code></a>: Convert quaternion to Euler phases</li><li><a href="#Quaternionic.from_euler_phases-Tuple{Any, Any, Any}"><code>from_euler_phases</code></a>: Create quaternion from Euler phases</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/Quaternionic.jl/blob/e5554101723b232d4fd58d637bde1c316322c9b1/src/conversion.jl#L116-L143">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quaternionic.from_euler_phases-Tuple{Any, Any, Any}" href="#Quaternionic.from_euler_phases-Tuple{Any, Any, Any}"><code>Quaternionic.from_euler_phases</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">from_euler_phases(zₐ, zᵦ, zᵧ)
from_euler_phases(z)</code></pre><p>Return the quaternion corresponding to these Euler phases.</p><p>Interpreting the input quaternion as a rotation (though its normalization scales out), we can define the complex Euler phases from the Euler angles (α, β, γ) as</p><pre><code class="language-none">zₐ ≔ exp(i*α)
zᵦ ≔ exp(i*β)
zᵧ ≔ exp(i*γ)</code></pre><p>These are more useful geometric quantites than the angles themselves — being involved in computing spherical harmonics and Wigner&#39;s 𝔇 matrices — and can be computed from the components of the corresponding quaternion algebraically (without the use of transcendental functions).</p><p><strong>Parameters</strong></p><ul><li><code>z::Vector{Complex{T}}</code>: complex vector of length 3, representing the complex phases (zₐ, zᵦ, zᵧ) in that order.</li></ul><p><strong>Returns</strong></p><ul><li><code>R::Quaternion{T}</code></li></ul><p><strong>See Also</strong></p><ul><li><a href="#Quaternionic.to_euler_phases-Union{Tuple{AbstractQuaternion{T}}, Tuple{T}} where T"><code>to_euler_phases</code></a>: Convert quaternion to Euler phases</li><li><a href="#Quaternionic.to_euler_angles-Tuple{AbstractQuaternion}"><code>to_euler_angles</code></a>: Convert quaternion to Euler angles</li><li><a href="#Quaternionic.from_euler_angles-Tuple{Any, Any, Any}"><code>from_euler_angles</code></a>: Create quaternion from Euler angles</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/Quaternionic.jl/blob/e5554101723b232d4fd58d637bde1c316322c9b1/src/conversion.jl#L212-L244">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quaternionic.from_float_array-Union{Tuple{AbstractArray{T, N} where N}, Tuple{T}} where T&lt;:Real" href="#Quaternionic.from_float_array-Union{Tuple{AbstractArray{T, N} where N}, Tuple{T}} where T&lt;:Real"><code>Quaternionic.from_float_array</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">from_float_array(A)</code></pre><p>Reinterpret a real array as an array of quaternions</p><p>The input array must have an initial dimension whose size is 4, because successive indices in that dimension will be considered successive components of the output quaternion.</p><p>Note that this returns a view of the original data [via <code>reinterpret(reshape,...)</code>] only if the base type of the input array <code>isbitstype</code>; otherwise, a new array of <code>Quaternion</code>s must be created, and the memory copied.</p><p>See also <a href="#Quaternionic.to_float_array-Union{Tuple{AbstractArray{var&quot;#s11&quot;, N} where {var&quot;#s11&quot;&lt;:AbstractQuaternion{T}, N}}, Tuple{T}} where T&lt;:Real"><code>to_float_array</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/Quaternionic.jl/blob/e5554101723b232d4fd58d637bde1c316322c9b1/src/conversion.jl#L1-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quaternionic.from_rotation_matrix-Tuple{Any}" href="#Quaternionic.from_rotation_matrix-Tuple{Any}"><code>Quaternionic.from_rotation_matrix</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">from_rotation_matrix(ℛ)</code></pre><p>Convert 3x3 rotation matrix to quaternion.</p><p>Assuming the 3x3 matrix <code>ℛ</code> rotates a vector <code>v</code> according to</p><pre><code class="language-none">v&#39; = ℛ * v,</code></pre><p>we can also express this rotation in terms of a quaternion <code>R</code> such that</p><pre><code class="language-none">v&#39; = R * v * R⁻¹.</code></pre><p>This function returns that quaternion, using Bar-Itzhack&#39;s algorithm to allow for non-orthogonal matrices.  <a href="http://dx.doi.org/10.2514/2.4654">J. Guidance, Vol. 23, No. 6, p. 1085</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/Quaternionic.jl/blob/e5554101723b232d4fd58d637bde1c316322c9b1/src/conversion.jl#L301-L318">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quaternionic.from_spherical_coordinates-Tuple{Any, Any}" href="#Quaternionic.from_spherical_coordinates-Tuple{Any, Any}"><code>Quaternionic.from_spherical_coordinates</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">from_spherical_coordinates(θ, ϕ)</code></pre><p>Return a rotor corresponding to these spherical coordinates.</p><p>Considering (θ, ϕ) as a point <span>$n̂$</span> on the sphere, we can also construct a quaternion that rotates the <span>$z$</span> axis onto that point.  Here, we use the standard commonly used in physics: θ represents the &quot;polar angle&quot; between the <span>$z$</span> axis and the direction <span>$n̂$</span>, while ϕ represents the &quot;azimuthal angle&quot; between the <span>$x$</span> axis and the projection of <span>$n̂$</span> into the <span>$x$</span>-<span>$y$</span> plane. Both angles must be given in radians.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/Quaternionic.jl/blob/e5554101723b232d4fd58d637bde1c316322c9b1/src/conversion.jl#L280-L292">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quaternionic.to_euler_angles-Tuple{AbstractQuaternion}" href="#Quaternionic.to_euler_angles-Tuple{AbstractQuaternion}"><code>Quaternionic.to_euler_angles</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">to_euler_angles(R)</code></pre><p>Open Pandora&#39;s Box.</p><p>If somebody is trying to make you use Euler angles, tell them no, and walk away, and go and tell your mum.</p><p>You don&#39;t want to use Euler angles.  They are awful.  Stay away.  It&#39;s one thing to convert from Euler angles to quaternions; at least you&#39;re moving in the right direction.  But to go the other way?!  It&#39;s just not right.</p><p>Assumes the Euler angles correspond to the quaternion <code>R</code> via</p><pre><code class="language-none">R = exp(α𝐤/2) * exp(β𝐣/2) * exp(γ𝐤/2)</code></pre><p>where 𝐣 and 𝐤 rotate about the fixed <span>$y$</span> and <span>$z$</span> axes, respectively, so this reprents an initial rotation (in the positive sense) through an angle <span>$γ$</span> about the axis <span>$z$</span>, followed by a rotation through <span>$β$</span> about the axis <span>$y$</span>, and a final rotation through <span>$α$</span> about the axis <span>$z$</span>.  This is equivalent to performing an initial rotation through <span>$α$</span> about the axis <span>$z$</span>, followed by a rotation through <span>$β$</span> about the <em>rotated</em> axis <span>$y&#39;$</span>, followed by a rotation through <span>$γ$</span> about the <em>twice-rotated</em> axis <span>$z&#39;&#39;$</span>. The angles are naturally assumed to be in radians.</p><p>NOTE: Before opening an issue reporting something &quot;wrong&quot; with this function, be sure to read all of <a href="https://github.com/moble/quaternion/wiki/Euler-angles-are-horrible">this page</a>, <em>especially</em> the very last section about opening issues or pull requests.</p><p><strong>Returns</strong></p><ul><li><code>αβγ::Vector{T}</code></li></ul><p><strong>Raises</strong></p><ul><li><code>AllHell</code> if you try to actually use Euler angles, when you could have been using quaternions like a sensible person.</li></ul><p><strong>See Also</strong></p><ul><li><a href="#Quaternionic.from_euler_angles-Tuple{Any, Any, Any}"><code>from_euler_angles</code></a>: Create quaternion from Euler angles</li><li><a href="#Quaternionic.to_euler_phases-Union{Tuple{AbstractQuaternion{T}}, Tuple{T}} where T"><code>to_euler_phases</code></a>: Convert quaternion to Euler phases</li><li><a href="#Quaternionic.from_euler_phases-Tuple{Any, Any, Any}"><code>from_euler_phases</code></a>: Create quaternion from Euler phases</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/Quaternionic.jl/blob/e5554101723b232d4fd58d637bde1c316322c9b1/src/conversion.jl#L65-L106">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quaternionic.to_euler_phases-Union{Tuple{AbstractQuaternion{T}}, Tuple{T}} where T" href="#Quaternionic.to_euler_phases-Union{Tuple{AbstractQuaternion{T}}, Tuple{T}} where T"><code>Quaternionic.to_euler_phases</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">to_euler_phases(q)
to_euler_phases!(z, q)</code></pre><p>Convert input quaternion to complex phases of Euler angles</p><p>Interpreting the input quaternion as a rotation (though its normalization scales out), we can define the complex Euler phases from the Euler angles (α, β, γ) as</p><pre><code class="language-none">zₐ ≔ exp(i*α)
zᵦ ≔ exp(i*β)
zᵧ ≔ exp(i*γ)</code></pre><p>These are more useful geometric quantites than the angles themselves — being involved in computing spherical harmonics and Wigner&#39;s 𝔇 matrices — and can be computed from the components of the corresponding quaternion algebraically (without the use of transcendental functions).</p><p><strong>Returns</strong></p><ul><li><code>z::Vector{Complex{T}}</code>: complex phases (zₐ, zᵦ, zᵧ) in that order.</li></ul><p><strong>See Also</strong></p><ul><li><a href="#Quaternionic.from_euler_phases-Tuple{Any, Any, Any}"><code>from_euler_phases</code></a>: Create quaternion from Euler phases</li><li><a href="#Quaternionic.to_euler_angles-Tuple{AbstractQuaternion}"><code>to_euler_angles</code></a>: Convert quaternion to Euler angles</li><li><a href="#Quaternionic.from_euler_angles-Tuple{Any, Any, Any}"><code>from_euler_angles</code></a>: Create quaternion from Euler angles</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/Quaternionic.jl/blob/e5554101723b232d4fd58d637bde1c316322c9b1/src/conversion.jl#L177-L204">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quaternionic.to_float_array-Union{Tuple{AbstractArray{var&quot;#s11&quot;, N} where {var&quot;#s11&quot;&lt;:AbstractQuaternion{T}, N}}, Tuple{T}} where T&lt;:Real" href="#Quaternionic.to_float_array-Union{Tuple{AbstractArray{var&quot;#s11&quot;, N} where {var&quot;#s11&quot;&lt;:AbstractQuaternion{T}, N}}, Tuple{T}} where T&lt;:Real"><code>Quaternionic.to_float_array</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">to_float_array(A)</code></pre><p>View a quaternion array as an array of real numbers</p><p>The output array will have an extra initial dimension whose size is 4, because successive indices in that dimension correspond to successive components of the quaternion.</p><p>Note that this returns a view of the original data only if the base type of the input array <code>isbitstype</code>; otherwise, a new array of that type must be created, and the memory copied.</p><p>See also <a href="#Quaternionic.from_float_array-Union{Tuple{AbstractArray{T, N} where N}, Tuple{T}} where T&lt;:Real"><code>from_float_array</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/Quaternionic.jl/blob/e5554101723b232d4fd58d637bde1c316322c9b1/src/conversion.jl#L34-L48">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quaternionic.to_rotation_matrix-Tuple{Q} where Q&lt;:AbstractQuaternion" href="#Quaternionic.to_rotation_matrix-Tuple{Q} where Q&lt;:AbstractQuaternion"><code>Quaternionic.to_rotation_matrix</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">to_rotation_matrix(q)</code></pre><p>Convert quaternion to 3x3 rotation matrix.</p><p>Assuming the quaternion <code>R</code> rotates a vector <code>v</code> according to</p><pre><code class="language-none">v&#39; = R * v * R⁻¹,</code></pre><p>we can also express this rotation in terms of a 3x3 matrix <code>ℛ</code> such that</p><pre><code class="language-none">v&#39; = ℛ * v.</code></pre><p>This function returns that matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/Quaternionic.jl/blob/e5554101723b232d4fd58d637bde1c316322c9b1/src/conversion.jl#L341-L356">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quaternionic.to_spherical_coordinates-Tuple{Q} where Q&lt;:AbstractQuaternion" href="#Quaternionic.to_spherical_coordinates-Tuple{Q} where Q&lt;:AbstractQuaternion"><code>Quaternionic.to_spherical_coordinates</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">to_spherical_coordinates(q)</code></pre><p>Return the spherical coordinates corresponding to this quaternion.</p><p>We can treat the quaternion as a transformation taking the <span>$z$</span> axis to some direction <span>$n̂$</span>.  This direction can be described in terms of spherical coordinates (θ, ϕ).  Here, we use the standard commonly used in physics: θ represents the &quot;polar angle&quot; between the <span>$z$</span> axis and the direction <span>$n̂$</span>, while ϕ represents the &quot;azimuthal angle&quot; between the <span>$x$</span> axis and the projection of <span>$n̂$</span> into the <span>$x$</span>-<span>$y$</span> plane.  Both angles are given in radians.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/Quaternionic.jl/blob/e5554101723b232d4fd58d637bde1c316322c9b1/src/conversion.jl#L257-L270">source</a></section></article><h2 id="Distances"><a class="docs-heading-anchor" href="#Distances">Distances</a><a id="Distances-1"></a><a class="docs-heading-anchor-permalink" href="#Distances" title="Permalink"></a></h2><p>There are several ways of measuring the &quot;distance&quot; between two quaternions: <span>$d(q_1, q_2)$</span>.  Fundamentally, any comparison between two quaternions <span>$q_1$</span> and <span>$q_2$</span> must make use of a binary operation, for which there are two obvious choices: addition or multiplication.  For either choice, we operate on <span>$q_1$</span> and the appropriate inverse (either additive or multiplicative) of <span>$q_2$</span>.  That is, <span>$d$</span> should be a function of either <span>$q_1 - q_2$</span> or <span>$q_1/q_2$</span>.<sup class="footnote-reference"><a id="citeref-1" href="#footnote-1">[1]</a></sup></p><p>Now, we also have a number of criteria we would like any distance function to satisfy.  For any quaternions <span>$q_1$</span> and <span>$q_2$</span> and any <em>unit</em> quaternion <span>$q_3$</span>, we require</p><ul><li>real-valued: <span>$d(q_1, q_2) \in \mathbb{R}$</span></li><li>symmetry: <span>$d(q_1, q_2) = d(q_2, q_1)$</span></li><li>invariance: <span>$d(q_3\, q_1, q_3\, q_2) = d(q_1, q_2) = d(q_1\, q_3, q_2\, q_3)$</span></li><li>identity: <span>$d(q_1, q_1) = 0$</span></li><li>positive-definiteness: <span>$d(q_1, q_2) &gt; 0$</span> whenever <span>$q_1 ≠ q_2$</span></li></ul><p>(Of course, it should be noted that these criteria all hold in the <em>exact</em> case; when using floating-point numbers, will likely be violated near edge cases.)</p><p>It is not hard to see that these criteria can be satisfied by any of</p><ul><li><code>abs(q₁ - q₂)</code></li><li><code>abs2(q₁ - q₂)</code></li><li><code>abs(log(q₁ / q₂))</code></li><li><code>abs2(log(q₁ / q₂)</code></li></ul><p>If <span>$q_1$</span> and <span>$q_2$</span> are interpreted as rotations, we frequently don&#39;t care about their signs, and just want the <em>smallest</em> distance between them, for any choice of sign.  Furthermore, in the multiplicative case, the <code>log</code> functions will involve calculation of the <code>log</code> of the magnitudes of the quaternions, which should be 1.  In this case, we relax the &quot;positive-definiteness&quot; criterion to allow <span>$d(q_1, q_2)$</span> to equal zero when <span>$q_1$</span> and <span>$q_2$</span> are related by a nonzero scalar multiple.</p><p>For <code>Rotor</code> types, the latter two multiplicative options are most relevant, while for other types the additive options are more relevant.  These are the default behaviors of the <code>distance</code> and <code>distance2</code> functions.</p><article class="docstring"><header><a class="docstring-binding" id="Quaternionic.distance-Tuple{AbstractQuaternion, AbstractQuaternion}" href="#Quaternionic.distance-Tuple{AbstractQuaternion, AbstractQuaternion}"><code>Quaternionic.distance</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">distance(q₁, q₂)
distance2(q₁, q₂)</code></pre><p>Measure the &quot;distance&quot; between two quaternions, or the squared distance with <code>distance2</code>.</p><p>By default, this function just returns the natural measure in the <em>additive</em> group of quaternions:</p><pre><code class="language-julia">abs2(q₁ - q₂)</code></pre><p>If both arguments are <code>Rotor</code>s, the function returns the natural measure in the <em>rotation</em> group, which is roughly</p><pre><code class="language-julia">abs2(log(q₁ / q₂))</code></pre><p>Note that for <code>Rotor</code>s, this method is (efficiently) independent of the scaling of <code>q₁</code> and <code>q₂</code>, including up to factors of -1, as is appropriate for the rotation group.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; distance(imx, imy)
1.4142135623730951
julia&gt; distance(Rotor(imx), Rotor(imy))
1.5707963267948966
julia&gt; distance(imz, -imz)
2.0
julia&gt; distance(Rotor(imz), Rotor(-imz))
0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/Quaternionic.jl/blob/e5554101723b232d4fd58d637bde1c316322c9b1/src/distance.jl#L1-L33">source</a></section></article><h1 id="Interpolation"><a class="docs-heading-anchor" href="#Interpolation">Interpolation</a><a id="Interpolation-1"></a><a class="docs-heading-anchor-permalink" href="#Interpolation" title="Permalink"></a></h1><p>Component-wise interpolation of quaternions does not generally yield good results when the quaternions are interpreted as rotations.  The basic reason is that rotations correspond to <em>unit</em> quaternions, but component-wise interpolation does not respect this constraint.  There are two specialized functions for dealing with this problem.  The first is <a href="#Quaternionic.slerp-Union{Tuple{R2}, Tuple{R1}, Tuple{R1, R2, Real}} where {R1&lt;:Union{Quaternion, Rotor}, R2&lt;:Union{Quaternion, Rotor}}"><code>slerp</code></a>, which is an abbreviation of &quot;Spherical Linear intERPolation&quot;, and is the direct analog of standard linear interpolation of functions ℝ → ℝ.  The second is <a href="#Quaternionic.squad-Tuple{AbstractVector{var&quot;#s48&quot;} where var&quot;#s48&quot;&lt;:Rotor, AbstractVector{var&quot;#s49&quot;} where var&quot;#s49&quot;&lt;:Real, AbstractVector{var&quot;#s50&quot;} where var&quot;#s50&quot;&lt;:Real}"><code>squad</code></a>, which is an abbreviation of &quot;Spherical QUADrangle interpolation&quot;, and is more analogous to cubic interpolation by Bézier splines. The first is relatively fast but has discontinuous first derivatives at the input points, while the second is somewhat slower but has continuous first and second derivatives.</p><p>In both cases, it is important for extraneous sign flips to be eliminated before passing quaternions to the interpolating functions.  For this purpose, there is the <a href="#Quaternionic.unflip-Tuple{AbstractArray{var&quot;#s8&quot;, N} where {var&quot;#s8&quot;&lt;:AbstractQuaternion, N}}"><code>unflip</code></a> utility function, which can also be called automatically by passing the corresponding keywords to <code>slerp</code> and <code>squad</code>.</p><article class="docstring"><header><a class="docstring-binding" id="Quaternionic.slerp-Union{Tuple{R2}, Tuple{R1}, Tuple{R1, R2, Real}} where {R1&lt;:Union{Quaternion, Rotor}, R2&lt;:Union{Quaternion, Rotor}}" href="#Quaternionic.slerp-Union{Tuple{R2}, Tuple{R1}, Tuple{R1, R2, Real}} where {R1&lt;:Union{Quaternion, Rotor}, R2&lt;:Union{Quaternion, Rotor}}"><code>Quaternionic.slerp</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">slerp(q₁, q₂, τ; [unflip=false])</code></pre><p>Spherical linear interpolation of quaternions</p><p>The result of a &quot;slerp&quot; is given by</p><pre><code class="language-none">    (q₂ / q₁)^τ * q₁</code></pre><p>When <code>τ</code> is 0, this evaluates to <code>q₁</code>; when <code>τ</code> is 1, this evaluates to <code>q₂</code>; for any other values the result varies between the two.</p><p>Note that applying this to successive pairs of quaternions as in <code>slerp(q₁, q₂, τₐ)</code> and <code>slerp(q₂, q₃, τᵦ)</code> will be continuous, but the derivative will be discontinuous when moving from the first pair to the second.  See <a href="#Quaternionic.squad-Tuple{AbstractVector{var&quot;#s48&quot;} where var&quot;#s48&quot;&lt;:Rotor, AbstractVector{var&quot;#s49&quot;} where var&quot;#s49&quot;&lt;:Real, AbstractVector{var&quot;#s50&quot;} where var&quot;#s50&quot;&lt;:Real}"><code>squad</code></a> for a more continuous curve.</p><p>If <code>unflip=true</code> is passed as a keyword, and the input quaternions are more anti-parallel than parallel, the sign of <code>q₂</code> will be flipped before the result is computed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/Quaternionic.jl/blob/e5554101723b232d4fd58d637bde1c316322c9b1/src/interpolation.jl#L85-L106">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quaternionic.squad-Tuple{AbstractVector{var&quot;#s48&quot;} where var&quot;#s48&quot;&lt;:Rotor, AbstractVector{var&quot;#s49&quot;} where var&quot;#s49&quot;&lt;:Real, AbstractVector{var&quot;#s50&quot;} where var&quot;#s50&quot;&lt;:Real}" href="#Quaternionic.squad-Tuple{AbstractVector{var&quot;#s48&quot;} where var&quot;#s48&quot;&lt;:Rotor, AbstractVector{var&quot;#s49&quot;} where var&quot;#s49&quot;&lt;:Real, AbstractVector{var&quot;#s50&quot;} where var&quot;#s50&quot;&lt;:Real}"><code>Quaternionic.squad</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">squad(Rin, tin, tout; [unflip=false], [validate=false])</code></pre><p>Perform &quot;Spherical QUADrangle interpolation&quot; on the input <code>Rotor</code>s <code>Rin</code> with corresponding times <code>tin</code>, to the output times <code>tout</code>.</p><p>This is a slightly generalized version of <a href="https://doi.org/10.1145/325165.325242">Shoemake&#39;s &quot;spherical Bézier curves&quot;</a>, to allow for time steps of varying sizes.</p><p>The input <code>Rin</code> and <code>tin</code> must be vectors of the same length.  The output <code>tout</code> may be either a single real number or a vector of real numbers.  Both <code>tin</code> and <code>tout</code> are assumed to be sorted, and <code>tout</code> is assumed to be contained entirely within <code>tin</code>; no extrapolation will be done.</p><p>If <code>unflip=true</code> is passed as a keyword, the <a href="#Quaternionic.unflip-Tuple{AbstractArray{var&quot;#s8&quot;, N} where {var&quot;#s8&quot;&lt;:AbstractQuaternion, N}}"><code>unflip</code></a> function will be applied to <code>Rin</code>.</p><p>If <code>validate=true</code> is passed as a keyword, the time ordering of the input <code>tin</code> and <code>tout</code> will be tested to ensure that no extrapolation will be done.</p><p>See also <a href="#Quaternionic.squad_control_points-Tuple{AbstractVector{var&quot;#s10&quot;} where var&quot;#s10&quot;&lt;:Rotor, AbstractVector{var&quot;#s9&quot;} where var&quot;#s9&quot;&lt;:AbstractFloat, Int64}"><code>squad_control_points</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/Quaternionic.jl/blob/e5554101723b232d4fd58d637bde1c316322c9b1/src/interpolation.jl#L186-L209">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quaternionic.squad_control_points-Tuple{AbstractVector{var&quot;#s10&quot;} where var&quot;#s10&quot;&lt;:Rotor, AbstractVector{var&quot;#s9&quot;} where var&quot;#s9&quot;&lt;:AbstractFloat, Int64}" href="#Quaternionic.squad_control_points-Tuple{AbstractVector{var&quot;#s10&quot;} where var&quot;#s10&quot;&lt;:Rotor, AbstractVector{var&quot;#s9&quot;} where var&quot;#s9&quot;&lt;:AbstractFloat, Int64}"><code>Quaternionic.squad_control_points</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">squad_control_points(R::AbstractVector{Rotor}, t::AbstractVector{&lt;:AbstractFloat}, i::Int)</code></pre><p>This is a helper function for the <code>squad</code> routines, returning the control points between one pair of input rotors.</p><p>The expressions for <span>$A$</span> and <span>$B$</span> (assuming all indices are valid) are</p><p class="math-container">\[\begin{aligned}
A_{i} &amp;= R_{i}\, \exp\left\{
  \frac{1}{4}
  \left[
    \log\left(\bar{R}_{i-1}\, R_i\right) \frac{t_{i+1} - t_{i}} {t_{i} - t_{i-1}}
    - \log\left(\bar{R}_{i}\, R_{i+1}\right)
  \right]
\right\},
\\
B_{i} &amp;= R_{i+1}\, \exp\left\{
  -\frac{1}{4}
  \left[
    \log\left(\bar{R}_{i+1}\, R_{i+2}\right) \frac{t_{i+1} - t_{i}} {t_{i+2} - t_{i+1}}
    - \log\left(\bar{R}_{i}\, R_{i+1}\right)
  \right]
\right\}
\end{aligned}.\]</p><p>The indices will be invalid for <code>A[begin]</code> and <code>A[end]</code>, and for <code>B[end-1]</code> and <code>B[end]</code>.  We can simply extend the input <code>R</code> values by linearly extrapolating, which results in the following simplified results:</p><p class="math-container">\[\begin{aligned}
A_{\mathrm{begin}} &amp;= R_{\mathrm{begin}} \\
A_{\mathrm{end}} &amp;= R_{\mathrm{end}} \\
B_{\mathrm{end-1}} &amp;= R_{\mathrm{end}} \\
B_{\mathrm{end}} &amp;= R_{\mathrm{end}}\, \bar{R}_{\mathrm{end-1}}\, R_{\mathrm{end}} \\
                 &amp;= 2\left(R_{\mathrm{end}}\cdot R_{\mathrm{end-1}}\right)\, R_{\mathrm{end}} - R_{\mathrm{end-1}}.
\end{aligned}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/Quaternionic.jl/blob/e5554101723b232d4fd58d637bde1c316322c9b1/src/interpolation.jl#L115-L153">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quaternionic.unflip-Tuple{AbstractArray{var&quot;#s8&quot;, N} where {var&quot;#s8&quot;&lt;:AbstractQuaternion, N}}" href="#Quaternionic.unflip-Tuple{AbstractArray{var&quot;#s8&quot;, N} where {var&quot;#s8&quot;&lt;:AbstractQuaternion, N}}"><code>Quaternionic.unflip</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">unflip(q, [dim=1])
unflip!(q, [dim=1])</code></pre><p>Flip the signs of successive quaternions along dimension <code>dim</code> so that they are as continuous as possible.</p><p>If <code>q</code> represents a series of rotations, the sign of each element is arbitrary. However, for certain purposes — such as interpolation and differentiation — the continuity of the quaternions matters, and so we want the <em>quaternions</em> to be as continuous as possible without changing the <em>rotations</em> that they represent.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; q = [imx, -imx, imx, -imx];

julia&gt; unflip(q)
4-element Vector{QuatVec{Int64}}:
 0 + 1𝐢 + 0𝐣 + 0𝐤
 0 + 1𝐢 + 0𝐣 + 0𝐤
 0 + 1𝐢 + 0𝐣 + 0𝐤
 0 + 1𝐢 + 0𝐣 + 0𝐤</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/Quaternionic.jl/blob/e5554101723b232d4fd58d637bde1c316322c9b1/src/interpolation.jl#L51-L74">source</a></section></article><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-1"><a class="tag is-link" href="#citeref-1">1</a>For <span>$q_1/q_2$</span>, we are dealing with the <em>multiplicative</em> group of quaternions, which does not include 0, so we will assume that no quaternion involved in such a function can be 0.</li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Introduction</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Tuesday 22 June 2021 04:00">Tuesday 22 June 2021</span>. Using Julia version 1.6.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
