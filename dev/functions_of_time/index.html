<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Functions of time · Quaternionic.jl</title><link rel="canonical" href="https://moble.github.io/Quaternionic.jl/stable/functions_of_time/"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">Quaternionic.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction</a></li><li><a class="tocitem" href="../manual/">Basics</a></li><li class="is-active"><a class="tocitem" href>Functions of time</a><ul class="internal"><li><a class="tocitem" href="#Interpolation"><span>Interpolation</span></a></li><li><a class="tocitem" href="#Angular-velocity"><span>Angular velocity</span></a></li><li><a class="tocitem" href="#Minimal-rotation"><span>Minimal rotation</span></a></li><li><a class="tocitem" href="#Derivatives-and-gradients"><span>Derivatives and gradients</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Functions of time</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Functions of time</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/moble/Quaternionic.jl/blob/master/docs/src/functions_of_time.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Functions-of-time"><a class="docs-heading-anchor" href="#Functions-of-time">Functions of time</a><a id="Functions-of-time-1"></a><a class="docs-heading-anchor-permalink" href="#Functions-of-time" title="Permalink"></a></h1><p>When using quaternions to represent rotations and orientations, we frequently model dynamical systems, which means that the quaternions must be regarded as functions of time.  The preceding functions can all be applied at each instant of time, but we also need to be deal with the <em>change</em> of quaternions over time, for which there are several important techniques:</p><ul><li><a href="#Interpolation">Interpolation</a> — Taking discretely sampled quaternionic time series and interpolating to different samples, and possibly differentiating.</li><li><a href="#Angular-velocity">Angular velocity</a> — Both differentiation of a quaternionic function of time to get angular velocity, and integration of angular velocity to get an orientation as a function of time.</li><li><a href="#Minimal-rotation">Minimal rotation</a> — Finding the <em>least</em> dynamical motion that can achieve pointing in a certain direction.</li><li><a href="#Derivatives-and-gradients">Derivatives and gradients</a> — Thanks to the <a href="https://en.wikipedia.org/wiki/Chain_rule#Multivariable_case">chain rule</a>, differentiating many nontrivial quaternionic functions of time will also involve differentiating with respect to components of quaternionic arguments.</li></ul><h2 id="Interpolation"><a class="docs-heading-anchor" href="#Interpolation">Interpolation</a><a id="Interpolation-1"></a><a class="docs-heading-anchor-permalink" href="#Interpolation" title="Permalink"></a></h2><p>Component-wise interpolation of quaternions does not generally yield good results when the quaternions are interpreted as rotations.  The basic reason is that rotations correspond to <em>unit</em> quaternions, but component-wise interpolation does not respect this constraint.  There are two specialized functions for dealing with this problem.  The first is <a href="#Quaternionic.slerp-Union{Tuple{R2}, Tuple{R1}, Tuple{R1, R2, Real}} where {R1&lt;:Union{Quaternion, Rotor}, R2&lt;:Union{Quaternion, Rotor}}"><code>slerp</code></a>, which is an abbreviation of &quot;Spherical Linear intERPolation&quot;, and is the direct analog of standard linear interpolation of functions ℝ → ℝ.  The second is <a href="#Quaternionic.squad-Union{Tuple{T}, Tuple{AbstractArray{Rotor{T}, 1}, AbstractVector{&lt;:Real}, AbstractVector{&lt;:Real}}} where T"><code>squad</code></a>, which is an abbreviation of &quot;Spherical QUADrangle interpolation&quot;, and is more analogous to cubic interpolation by Bézier splines. The first is relatively fast but has discontinuous first derivatives at the input points, while the second is somewhat slower but has continuous first and second derivatives.</p><p>In both cases, it is important for extraneous sign flips to be eliminated before passing quaternions to the interpolating functions.  For this purpose, there is the <a href="#Quaternionic.unflip-Tuple{AbstractArray{&lt;:AbstractQuaternion}}"><code>unflip</code></a> utility function, which can also be called automatically by passing the corresponding keywords to <code>slerp</code> and <code>squad</code>.</p><p>As noted <a href="#Gradients">below</a>, <code>slerp</code> can also be simultaneously evaluated and differentiated analytically with <a href="#Quaternionic.slerp∂slerp∂τ-Tuple{Rotor, Rotor, Real}"><code>slerp∂slerp∂τ</code></a> (or automatically with <code>ForwardDiff</code>).  While, <code>squad</code> and its derivative can be evaluated with <a href="#Quaternionic.squad∂squad∂t-NTuple{7, Any}"><code>squad∂squad∂t</code></a>, this is a relatively low-level function; it is easier to use the relevant keyword arguments to <a href="#Quaternionic.squad-Union{Tuple{T}, Tuple{AbstractArray{Rotor{T}, 1}, AbstractVector{&lt;:Real}, AbstractVector{&lt;:Real}}} where T"><code>squad</code></a>.</p><article class="docstring"><header><a class="docstring-binding" id="Quaternionic.slerp-Union{Tuple{R2}, Tuple{R1}, Tuple{R1, R2, Real}} where {R1&lt;:Union{Quaternion, Rotor}, R2&lt;:Union{Quaternion, Rotor}}" href="#Quaternionic.slerp-Union{Tuple{R2}, Tuple{R1}, Tuple{R1, R2, Real}} where {R1&lt;:Union{Quaternion, Rotor}, R2&lt;:Union{Quaternion, Rotor}}"><code>Quaternionic.slerp</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">slerp(q₁, q₂, τ; [unflip=false])</code></pre><p>&quot;Spherical Linear intERPolation&quot; of a pair of quaternions.</p><p>The result of a &quot;slerp&quot; is given by</p><pre><code class="language-none">    (q₂ / q₁)^τ * q₁</code></pre><p>When <code>τ</code> is 0, this evaluates to <code>q₁</code>; when <code>τ</code> is 1, this evaluates to <code>q₂</code>; for any other values the result varies between the two.</p><p>Note that applying this to successive pairs of quaternions as in <code>slerp(q₁, q₂, τₐ)</code> and <code>slerp(q₂, q₃, τᵦ)</code> will be continuous, but the derivative will be discontinuous when moving from the first pair to the second.  See <a href="#Quaternionic.squad-Union{Tuple{T}, Tuple{AbstractArray{Rotor{T}, 1}, AbstractVector{&lt;:Real}, AbstractVector{&lt;:Real}}} where T"><code>squad</code></a> for a more continuous curve.</p><p>If <code>unflip=true</code> is passed as a keyword, and the input quaternions are more anti-parallel than parallel, the sign of <code>q₂</code> will be flipped before the result is computed.</p><p>See also <a href="#Quaternionic.slerp∂slerp∂τ-Tuple{Rotor, Rotor, Real}"><code>slerp∂slerp∂τ</code></a>, to simultaneously evaluate this function and its derivative with respect to <code>τ</code>, or <a href="#Quaternionic.slerp∂slerp-Tuple{Rotor, Rotor, Real}"><code>slerp∂slerp</code></a> to evaluate this function and its derivative with respect to each parameter of the input.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/Quaternionic.jl/blob/d68feede90b1382512c6f8435fafb042fb0bfdd5/src/interpolation.jl#L85-L110">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quaternionic.squad!-Tuple{AbstractVector{&lt;:Rotor}, Union{Nothing, AbstractVector{&lt;:QuatVec}}, Union{Nothing, AbstractVector{&lt;:Quaternion}}, AbstractVector{&lt;:Rotor}, AbstractVector{&lt;:Real}, AbstractVector{&lt;:Real}}" href="#Quaternionic.squad!-Tuple{AbstractVector{&lt;:Rotor}, Union{Nothing, AbstractVector{&lt;:QuatVec}}, Union{Nothing, AbstractVector{&lt;:Quaternion}}, AbstractVector{&lt;:Rotor}, AbstractVector{&lt;:Real}, AbstractVector{&lt;:Real}}"><code>Quaternionic.squad!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">squad!(Rout, Ω⃗out, Ṙout, Rin, tin, tout; [unflip=false], [validate=false])
squad!(Rout, Rin, tin, tout; [unflip=false], [validate=false])</code></pre><p>In-place evaluation of &quot;Spherical QUADrangular interpolation&quot;.  Note that this is intended mostly as a utility function; the <a href="#Quaternionic.squad-Union{Tuple{T}, Tuple{AbstractArray{Rotor{T}, 1}, AbstractVector{&lt;:Real}, AbstractVector{&lt;:Real}}} where T"><code>squad</code></a> is more user-friendly.  However, for efficiency, this function may be preferable.</p><p>The first three arrays will be modified in place, and must have the same length as <code>tout</code>.  Their elements must be <code>Rotor</code>, <code>QuatVec</code>, and <code>Quaternion</code>, respectively.  Optionally, either or both of <code>Ω⃗out</code> and <code>Ṙout</code> maybe <code>nothing</code>, in which case they will not be computed.</p><p>See also <a href="#Quaternionic.squad-Union{Tuple{T}, Tuple{AbstractArray{Rotor{T}, 1}, AbstractVector{&lt;:Real}, AbstractVector{&lt;:Real}}} where T"><code>squad</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/Quaternionic.jl/blob/d68feede90b1382512c6f8435fafb042fb0bfdd5/src/interpolation.jl#L191-L206">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quaternionic.squad-Union{Tuple{T}, Tuple{AbstractArray{Rotor{T}, 1}, AbstractVector{&lt;:Real}, AbstractVector{&lt;:Real}}} where T" href="#Quaternionic.squad-Union{Tuple{T}, Tuple{AbstractArray{Rotor{T}, 1}, AbstractVector{&lt;:Real}, AbstractVector{&lt;:Real}}} where T"><code>Quaternionic.squad</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">squad(Rin, tin, tout; [kwargs...])</code></pre><p>&quot;Spherical QUADrangle interpolation&quot; of the input <code>Rotor</code>s <code>Rin</code> with corresponding times <code>tin</code>, to the output times <code>tout</code>.</p><p>This is a slightly generalized version of <a href="https://doi.org/10.1145/325165.325242">Shoemake&#39;s &quot;spherical Bézier curves&quot;</a>, to allow for time steps of varying sizes.</p><p>The input <code>Rin</code> and <code>tin</code> must be vectors of the same length.  The output <code>tout</code> may be either a single real number or a vector of real numbers.  Both <code>tin</code> and <code>tout</code> are assumed to be sorted, and <code>tout</code> is assumed to be contained entirely within <code>tin</code>; no extrapolation will be done.</p><p>See also <a href="#Quaternionic.squad!-Tuple{AbstractVector{&lt;:Rotor}, Union{Nothing, AbstractVector{&lt;:QuatVec}}, Union{Nothing, AbstractVector{&lt;:Quaternion}}, AbstractVector{&lt;:Rotor}, AbstractVector{&lt;:Real}, AbstractVector{&lt;:Real}}"><code>squad!</code></a> for in-place versions of this function.</p><p><strong>Keyword arguments</strong></p><p>If <code>unflip=true</code> is passed as a keyword, the <a href="#Quaternionic.unflip-Tuple{AbstractArray{&lt;:AbstractQuaternion}}"><code>unflip</code></a> function will be applied to <code>Rin</code>.</p><p>If <code>validate=true</code> is passed as a keyword, the time ordering of the input <code>tin</code> and <code>tout</code> will be tested to ensure that no extrapolation will be done.</p><p>If <code>compute_angular_velocity=true</code> is passed as a keyword, the return value will be a tuple.  The first element of the tuple will be a vector of <code>Rotor</code>s as before, but the second element will be a vector of <code>QuatVec</code>s representing the angular velocity.</p><p>If <code>compute_derivative=true</code> is passed as a keyword, the return value will be a tuple.  The first element of the tuple will be a vector of <code>Rotor</code>s as before, but the last element will be a vector of <code>Quaternion</code>s representing the time-derivative of the rotors.  Note that if <code>compute_angular_velocity=true</code>, this tuple will have three elements.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/Quaternionic.jl/blob/d68feede90b1382512c6f8435fafb042fb0bfdd5/src/interpolation.jl#L293-L329">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quaternionic.squad_control_points-Tuple{AbstractVector{&lt;:Rotor}, AbstractVector{&lt;:AbstractFloat}, Int64}" href="#Quaternionic.squad_control_points-Tuple{AbstractVector{&lt;:Rotor}, AbstractVector{&lt;:AbstractFloat}, Int64}"><code>Quaternionic.squad_control_points</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">squad_control_points(R::AbstractVector{Rotor}, t::AbstractVector{&lt;:AbstractFloat}, i::Int)</code></pre><p>This is a helper function for the <code>squad</code> routines, returning the control points between one pair of input rotors.</p><p>The expressions for <span>$A$</span> and <span>$B$</span> (assuming all indices are valid) are</p><p class="math-container">\[\begin{aligned}
A_{i} &amp;= R_{i}\, \exp\left\{
  \frac{1}{4}
  \left[
    \log\left(\bar{R}_{i-1}\, R_i\right) \frac{t_{i+1} - t_{i}} {t_{i} - t_{i-1}}
    - \log\left(\bar{R}_{i}\, R_{i+1}\right)
  \right]
\right\},
\\
B_{i} &amp;= R_{i+1}\, \exp\left\{
  -\frac{1}{4}
  \left[
    \log\left(\bar{R}_{i+1}\, R_{i+2}\right) \frac{t_{i+1} - t_{i}} {t_{i+2} - t_{i+1}}
    - \log\left(\bar{R}_{i}\, R_{i+1}\right)
  \right]
\right\}.
\end{aligned}\]</p><p>These expressions will be invalid for <span>$A_{\mathrm{begin}}$</span>, <span>$A_{\mathrm{end}}$</span>, <span>$B_{\mathrm{end-1}}$</span>, and <span>$B_{\mathrm{end}}$</span>, because they all involve out-of-bounds indices of <span>$R_i$</span>.  We can simply extend the input <code>R</code> values by linearly extrapolating, which results in the following simplified results:</p><p class="math-container">\[\begin{aligned}
A_{\mathrm{begin}} &amp;= R_{\mathrm{begin}} \\
A_{\mathrm{end}} &amp;= R_{\mathrm{end}} \\
B_{\mathrm{end-1}} &amp;= R_{\mathrm{end}} \\
B_{\mathrm{end}} &amp;= R_{\mathrm{end}}\, \bar{R}_{\mathrm{end-1}}\, R_{\mathrm{end}} \\
                 &amp;= 2\left(R_{\mathrm{end}}\cdot R_{\mathrm{end-1}}\right)\, R_{\mathrm{end}} - R_{\mathrm{end-1}}.
\end{aligned}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/Quaternionic.jl/blob/d68feede90b1382512c6f8435fafb042fb0bfdd5/src/interpolation.jl#L119-L158">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quaternionic.unflip-Tuple{AbstractArray{&lt;:AbstractQuaternion}}" href="#Quaternionic.unflip-Tuple{AbstractArray{&lt;:AbstractQuaternion}}"><code>Quaternionic.unflip</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">unflip(q, [dim=1])
unflip!(q, [dim=1])</code></pre><p>Flip the signs of successive quaternions along dimension <code>dim</code> so that they are as continuous as possible.</p><p>If <code>q</code> represents a series of rotations, the sign of each element is arbitrary. However, for certain purposes — such as interpolation and differentiation — the continuity of the quaternions matters, and so we want the <em>quaternions</em> to be as continuous as possible without changing the <em>rotations</em> that they represent.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; q = [imx, -imx, imx, -imx];

julia&gt; unflip(q)
4-element Vector{QuatVec{Int64}}:
 0 + 1𝐢 + 0𝐣 + 0𝐤
 0 + 1𝐢 + 0𝐣 + 0𝐤
 0 + 1𝐢 + 0𝐣 + 0𝐤
 0 + 1𝐢 + 0𝐣 + 0𝐤</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/Quaternionic.jl/blob/d68feede90b1382512c6f8435fafb042fb0bfdd5/src/interpolation.jl#L51-L74">source</a></section></article><h2 id="Angular-velocity"><a class="docs-heading-anchor" href="#Angular-velocity">Angular velocity</a><a id="Angular-velocity-1"></a><a class="docs-heading-anchor-permalink" href="#Angular-velocity" title="Permalink"></a></h2><p>Given a quaternionic function of time <span>$q(t)$</span>, we can — in principle — differentiate it to find <span>$\dot{q}(t)$</span>.  This is related to the more familiar  <a href="https://en.wikipedia.org/wiki/Angular_velocity">angular velocity</a> <span>$\vec{\omega}$</span> by the equation</p><p class="math-container">\[\vec{\omega} = 2 \dot{q}\, q^{-1}.\]</p><p>While <span>$\dot{q}(t)$</span> can certainly be useful, it &quot;lives&quot; in a four-dimensional space, which means that it takes a little more work to relate to our three-dimensional space.  On the other hand, the direction of <span>$\vec{\omega}$</span> represents the instantaneous axis of rotation in our three-dimensional space, and its magnitude describes the rate of rotation about that axis.  More importantly, many results from physics describe rotations in terms of <span>$\vec{\omega}$</span>, rather than <span>$\dot{q}(t)$</span>.  So generally, we need a way to go from <span>$q(t)$</span> to <span>$\vec{\omega}(t)$</span> — and back.</p><p>The details of this process and some examples are discussed in full in <a href="https://arxiv.org/abs/1604.08139">this paper</a>.</p><p>Taking <span>$q(t)$</span> and obtaining <span>$\vec{\omega}(t)$</span> is fairly straightforward: one simply needs to obtain <span>$\dot{q}(t)$</span> and apply the equation above.  If <span>$q(t)$</span> is known analytically, it may be possible to compute <span>$\dot{q}$</span> directly (as in the example from Sec. 6.2 of <a href="https://arxiv.org/abs/1604.08139">the paper</a>).  But ordinarily, this is a difficult task.  For numerical functions automatic differentiation can be used to obtain a numerical result for <span>$\dot{q}$</span> (see <a href="#Gradient">below</a>).  Or, if <span>$q$</span> is discretely sampled, <a href="#Quaternionic.squad-Union{Tuple{T}, Tuple{AbstractArray{Rotor{T}, 1}, AbstractVector{&lt;:Real}, AbstractVector{&lt;:Real}}} where T"><code>squad</code></a> (with the relevant keyword arguments) can be used to find the derivative of the interpolant at any instant and/or the corresponding angular velocity.</p><p>Going the other way, obtaining <span>$q(t)$</span> from <span>$\vec{\omega}(t)$</span>, is more delicate — though still possible.  It requires integrating the ordinary differential equation</p><p class="math-container">\[\dot{q} = \frac{1}{2} \vec{\omega}\, q,\]</p><p>which is just a rearrangement of the equation above to solve for <span>$\dot{q}$</span>. Standard theorems on differential equations tell us that this equation has a solution for <span>$q(t)$</span> as long as we know <span>$\vec{\omega}$</span> as a function of time (and possibly of <span>$q$</span>, but not <span>$\dot{q}$</span>), and supply an initial value for <span>$q$</span> at some instant of time.  Note that <a href="https://arxiv.org/abs/1604.08139">the paper</a> noted above found that integrating this equation without any restriction on the norm of <span>$q$</span> is generally the most accurate and efficient choice.  However, with loose integration tolerances, numerical error may result in the output <span>$q(t)$</span> having norm significantly different from 1.  In this case, to use <span>$q$</span> as a rotation, you can normalize the result, or simply apply it by &quot;true&quot; conjugation with the inverse as in</p><p class="math-container">\[q\, \vec{v}\, q^{-1},\]</p><p>rather than using <span>$\bar{q}$</span> in the last factor.</p><p>If <code>DifferentialEquations.jl</code> is available, we can solve the ODE with code like this:</p><pre><code class="language-julia">using Quaternionic
using DifferentialEquations

# Make up some simple problem to solve
Ω⃗ = randn(QuatVecF64)
ω⃗(t) = Ω⃗
q₀ = randn(RotorF64)
tspan = (0.0, 100.0)

# Construct the ODE and `ODEProblem`
angular_velocity_ode(q, ω⃗, t) = ω⃗(t) * q / 2
angular_velocity_problem = ODEProblem(angular_velocity_ode, Quaternion(q₀), tspan, ω⃗)

# Now, solve it
q = solve(angular_velocity_problem, Vern9(), abstol=1e-12, reltol=0)</code></pre><p>Here, we have constructed a very simple <code>ω⃗</code> function — which can actually be integrated analytically — but it could be any callable that returns a <code>QuatVec</code> (or <code>Quaternion</code>).  Note that the initial condition <code>q₀</code> has to be a <code>Quaternion</code> on input to <code>ODEProblem</code> because <code>DifferentialEquations.jl</code> tries to construct a zero element of that type, which is impossible for a <code>Rotor</code>. This initial condition is also used for the output type and — as mentioned above — numerical errors will tend to move the norm away from 1, so a <code>Rotor</code> would not make sense anyway.  The choices of <code>Vern9</code> and <code>abstol=1e-12</code> here are quite stringent, and may be overkill for many problems.  It is recommended to set <code>reltol=0</code> in all cases.</p><p>The <code>q</code> that results from <code>solve</code> contains the time steps <code>q.t</code> at which the solution was found along with the solution values <code>q.u</code> at each of those time steps, but can also be used as a function of time to compute the value <code>q(t)</code> at an arbitrary time in <code>tspan</code>.  In this simple case, we can compute the exact value of, and compare it to the result of integration:</p><pre><code class="language-julia">q_exact = @. exp([Ω⃗] * q.t / 2) * q₀
maximum(distance.(q.u, q_exact))</code></pre><p>Typical numbers for this maximum error are roughly <code>1e-14</code>, though they increase as <code>tspan</code> is increased.</p><p>Also note that this simple version involves allocations at each time step.  If this is problematic, it should be easy to <a href="https://diffeq.sciml.ai/dev/tutorials/ode_example/#Example-2:-Solving-Systems-of-Equations">define in-place updating</a> versions of <code>ω⃗</code> and <code>angular_velocity_ode</code> to eliminate allocations, using vectors to hold the numbers instead of quaternions, and an expression like this for the ODE:</p><pre><code class="language-julia">    dqdt[1] = (q[2]*ω⃗t[2] + q[3]*ω⃗t[3] + q[4]*ω⃗t[4]) / -2
    dqdt[2] = (q[1]*ω⃗t[2] - q[3]*ω⃗t[4] + q[4]*ω⃗t[3]) / 2
    dqdt[3] = (q[1]*ω⃗t[3] + q[2]*ω⃗t[4] - q[4]*ω⃗t[2]) / 2
    dqdt[4] = (q[1]*ω⃗t[4] - q[2]*ω⃗t[3] + q[3]*ω⃗t[2]) / 2</code></pre><p>There is a particularly useful complicated but analytic example available here:</p><article class="docstring"><header><a class="docstring-binding" id="Quaternionic.precessing_nutating_example" href="#Quaternionic.precessing_nutating_example"><code>Quaternionic.precessing_nutating_example</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">precessing_nutating_example([Ωₒ], [Ωₚ], [α], [α̇], [ν], [R₀])</code></pre><p>Return an exact quaternionic function of time representing nutating precessional orbital motion, as described in Sec. 6.2 of <a href="https://arxiv.org/abs/1604.08139">this paper</a>.  This example is useful because it provides physically realistic but <em>very</em> complicated motion, while still being simple to code up and differentiate analytically.</p><p>The output represents the rotation of the line joining the orbiting bodies and their angular velocity.  The following are the input parameters, along with their default values and physical interpretations:</p><ul><li><code>Ωₒ=2π/1_000</code>: The orbital frequency</li><li><code>Ωₚ=2π/10_000</code>: The precessional frequency</li><li><code>α=π/8</code>: The opening angle of the precession cone at <span>$t=0$</span></li><li><code>α̇=2α/100_000</code>: The rate of opening of the precession cone</li><li><code>ν=π/80</code>: The angle of nutation</li><li><code>R₀=exp(-3α*imx/10)</code>: Overal rotation of the system</li></ul><p>The default values are chosen to be typical of a (potentially) real precessing binary black hole system shortly before merger.</p><p>The returned objects are three functions of time: <code>R</code>, <code>ω⃗</code>, and <code>Ṙ</code>, which return the orientation as a <code>Rotor</code>, followed by the angular velocity as a <code>QuatVec</code>, and the time-derivative of <code>R</code> as a <code>Quaternion</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; R, ω⃗, Ṙ = precessing_nutating_example();

julia&gt; R(12.34)
0.9944579779058746 + 0.09804177421238346𝐢 - 0.00084850453525312𝐣 + 0.03795287510453948𝐤
julia&gt; ω⃗(345.67)
0.0 + 0.00046343007342867023𝐢 - 0.0007032818419003181𝐣 + 0.006214814810035088𝐤
julia&gt; ϵ = 1e-6; (R(ϵ) - R(-ϵ)) / 2ϵ  # Approximate derivative at t=0
-3.8491432263754177e-7 + (3.9080960689830135e-6)𝐢 - (6.861695854245619e-5)𝐣 + 0.003076329202503836𝐤
julia&gt; Ṙ(0)
-3.8491240998153413e-7 + (3.9080812828476746e-6)𝐢 - (6.861695854245637e-5)𝐣 + 0.0030763292025038354𝐤</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/Quaternionic.jl/blob/d68feede90b1382512c6f8435fafb042fb0bfdd5/src/examples.jl#L1-L43">source</a></section></article><p>Because this is an analytic solution, we know that <code>R(t)</code> and <code>ω⃗(t)</code> output by this function are consistent with each other to within numerical accuracy.  We can check that our integration scheme agrees:</p><pre><code class="language-julia">R, ω⃗, Ṙ = precessing_nutating_example()
angular_velocity_ode(q, ω⃗, t) = ω⃗(t) * q / 2
tspan = (0., 100_000.)
angular_velocity_problem = ODEProblem(angular_velocity_ode, Quaternion(R(tspan[1])), tspan, ω⃗)
q = solve(angular_velocity_problem, Vern9(), abstol=1e-12, reltol=0);</code></pre><p>To check the difference between the analytic <code>R</code> and the integrated <code>q.u</code>, we evaluate</p><pre><code class="language-julia">julia&gt; maximum(distance.(R.(q.t), RotorF64.(q.u)))
3.655365559565175e-13</code></pre><p>The maximum error is consistent with time-stepping error, so we can have confidence that other <code>ω⃗</code> functions would be correctly integrated also.</p><h2 id="Minimal-rotation"><a class="docs-heading-anchor" href="#Minimal-rotation">Minimal rotation</a><a id="Minimal-rotation-1"></a><a class="docs-heading-anchor-permalink" href="#Minimal-rotation" title="Permalink"></a></h2><p>One common problem arises when a system must be rotated to align some axis with some direction, while the rotation of the system <em>about</em> that axis is irrelevant.  To be specific, suppose we want to rotate our basis vectors <span>$\hat{x}, \hat{y}, \hat{z}$</span> so that <span>$\hat{z}$</span> points in a particular direction.  A naive approach may be to determine the direction in terms of spherical coordinates <span>$(\theta, \phi)$</span>, and then use the rotation determined by Euler angles <span>$(\alpha, \beta, \gamma) = (\phi, \theta, 0)$</span>.  However, as with most applications of Euler angles, this is a terrible idea.  The resulting orientation will be extremely sensitive to the direction whenever it happens to be near the poles.  In such cases, the angular velocity of the system will be very high — potentially infinite, in principle.</p><p>A <em>slightly</em> better approach would be to use <span>$(\alpha, \beta, \gamma) = (\phi, \theta, -\phi)$</span>, which is the most direct rotation from the <span>$z$</span> axis to the point given by <span>$(\theta, \phi)$</span>, and behaves better in the limit of small <span>$\theta$</span>.  However, this only works for rotations directly from the <span>$z$</span> axis; the result depends on the choice of coordinates, and is not the best choice for tracking general motion of the target axis.</p><p>Fortunately, it is possible to take <em>any</em> rotor <span>$R_\mathrm{axis}(t)$</span> that aligns the axis correctly, and compute another rotation that also aligns the axis, but has the smallest possible angular velocity.  This is called the &quot;minimal rotation&quot;.  The general problem is discussed (by way of a very specific physical situation) in detail in Sec. III and Appendix B of <a href="https://arxiv.org/abs/1110.2965">this paper</a>.  Essentially, we solve the equation</p><p class="math-container">\[\dot{\gamma} = 2 \left[\dot{R}_\mathrm{axis}\, 𝐤\, \bar{R}_\mathrm{axis}
\right]_w\]</p><p>(where the subscript <span>$w$</span> just takes the scalar component) for <span>$\gamma(t)$</span>. We then construct the rotor</p><p class="math-container">\[R(t) = R_\mathrm{axis}(t)\, \exp\left[\gamma(t) 𝐤 / 2 \right]\]</p><p>This rotor also aligns the axis correctly, but otherwise has the smallest possible angular velocity.  Here, <span>$R_\mathrm{axis}$</span> may be constructed in any convenient way, including using spherical coordinates or even Euler angles; the resulting <span>$R(t)$</span> will be independent of such poor life choices.</p><h2 id="Derivatives-and-gradients"><a class="docs-heading-anchor" href="#Derivatives-and-gradients">Derivatives and gradients</a><a id="Derivatives-and-gradients-1"></a><a class="docs-heading-anchor-permalink" href="#Derivatives-and-gradients" title="Permalink"></a></h2><p>It can be very useful to compute the derivative of various functions with respect to their arguments — for example, when computing angular velocity of a <code>squad</code> interpolant, one needs to use the chain rule, and therefore needs each of the derivatives of <code>exp</code>, <code>log</code>, etc.  Here, we provide the essential (nontrivial) derivatives, treating each quaternionic argument as a series of four real arguments.  For each input argument, the output is generally a quaternion; interpreting those outputs as also being a series of four real quantities, these derivatives could also be thought of as <a href="https://en.wikipedia.org/wiki/Jacobian_matrix_and_determinant">Jacobian matrices</a> of the relevant functions, though the actual return types are collections of <code>Quaternion</code> objects.</p><p>Because of massive simplifications that result when using the right types, these derivatives are more strict about input types than the main functions themselves.  For example, the derivatives of <code>exp</code> are defined only for <code>QuatVec</code> arguments; the derivatives of <code>log</code> are defined only for <code>Rotor</code> arguments; etc.</p><p>Note that gradients can also be calculated automatically using <a href="https://juliadiff.org/ForwardDiff.jl/"><code>ForwardDiff.jl</code></a>.<sup class="footnote-reference"><a id="citeref-2" href="#footnote-2">[2]</a></sup> For example, we could compute the derivative of <code>slerp</code> with respect to the <code>y</code> component of the first input quaternion as</p><pre><code class="language-julia">∂slerp∂q₁y(q₁, q₂, τ) = ForwardDiff.derivative(ϵ-&gt;slerp(q₁+ϵ*imy, q₂, τ), 0)</code></pre><p>This is equal to</p><pre><code class="language-julia">slerp∂slerp(q₁, q₂, τ)[2][3]</code></pre><p>though <code>slerp∂slerp</code> computes the value and all derivatives of <code>slerp</code> simultaneously, and does at least as fast as — and likely faster than — most AD systems would.  Nonetheless, it is useful to know that <code>ForwardDiff</code> can process functions <em>involving</em> <code>Quaternionic</code> methods.</p><article class="docstring"><header><a class="docstring-binding" id="Quaternionic.exp∂exp-Tuple{QuatVec}" href="#Quaternionic.exp∂exp-Tuple{QuatVec}"><code>Quaternionic.exp∂exp</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">exp∂exp(Z::QuatVec)</code></pre><p>Return the value and gradient of <code>exp(Z)</code> with respect to the components of <code>Z</code>.</p><p>See <a href="#Quaternionic.∂exp-Tuple{QuatVec}"><code>∂exp</code></a> for more explanation of the components of the gradient.</p><p><strong>Examples</strong></p><pre><code class="language-julia">julia&gt; e, ∂e = exp∂exp(randn(QuatVecF64));
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/Quaternionic.jl/blob/d68feede90b1382512c6f8435fafb042fb0bfdd5/src/gradients.jl#L139-L151">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quaternionic.log∂log-Tuple{Rotor}" href="#Quaternionic.log∂log-Tuple{Rotor}"><code>Quaternionic.log∂log</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">log∂log(Z::Rotor)</code></pre><p>Return the value and gradient of <code>log(Z)</code> with respect to the components of <code>Z</code>.</p><p>See <a href="#Quaternionic.∂log-Tuple{Rotor}"><code>∂log</code></a> for more explanation of the components of the gradient.</p><p><strong>Examples</strong></p><pre><code class="language-julia">julia&gt; l, ∂l = log∂log(randn(RotorF64));
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/Quaternionic.jl/blob/d68feede90b1382512c6f8435fafb042fb0bfdd5/src/gradients.jl#L53-L65">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quaternionic.slerp∂slerp-Tuple{Rotor, Rotor, Real}" href="#Quaternionic.slerp∂slerp-Tuple{Rotor, Rotor, Real}"><code>Quaternionic.slerp∂slerp</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">slerp∂slerp(q₁, q₂, τ)</code></pre><p>Return the value and gradient of <code>slerp</code>.</p><p>The gradient is with respect to each of the input arguments in turn, with each quaternion regarded as a series of four arguments.  That is, a total of 10 quaternions will be returned:</p><p class="math-container">\[\begin{aligned}
  &amp;\big[\\
    &amp;\quad \mathrm{slerp}(q₁, q₂, τ), \\
    &amp;\quad \frac{\partial}{\partial q₁.w} \mathrm{slerp}(q₁, q₂, τ), \\
    &amp;\quad \frac{\partial}{\partial q₁.x} \mathrm{slerp}(q₁, q₂, τ), \\
    &amp;\quad \frac{\partial}{\partial q₁.y} \mathrm{slerp}(q₁, q₂, τ), \\
    &amp;\quad \frac{\partial}{\partial q₁.z} \mathrm{slerp}(q₁, q₂, τ), \\
    &amp;\quad \frac{\partial}{\partial q₂.w} \mathrm{slerp}(q₁, q₂, τ), \\
    &amp;\quad \frac{\partial}{\partial q₂.x} \mathrm{slerp}(q₁, q₂, τ), \\
    &amp;\quad \frac{\partial}{\partial q₂.y} \mathrm{slerp}(q₁, q₂, τ), \\
    &amp;\quad \frac{\partial}{\partial q₂.z} \mathrm{slerp}(q₁, q₂, τ), \\
    &amp;\quad \frac{\partial}{\partial \tau} \mathrm{slerp}(q₁, q₂, τ), \\
  &amp;\big]
\end{aligned}\]</p><p>For convenience, this will be a 4-tuple with the <code>slerp</code> as the first element, the first four components of the derivative, followed by the next four components of the derivative, followed by the last component of the derivative.</p><p>See also <a href="#Quaternionic.slerp-Union{Tuple{R2}, Tuple{R1}, Tuple{R1, R2, Real}} where {R1&lt;:Union{Quaternion, Rotor}, R2&lt;:Union{Quaternion, Rotor}}"><code>slerp</code></a> for just the value, and <a href="#Quaternionic.slerp∂slerp∂τ-Tuple{Rotor, Rotor, Real}"><code>slerp∂slerp∂τ</code></a> for just the value and the derivative with respect to <code>τ</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia">julia&gt; (q1, q2), τ = randn(RotorF64, 2), rand();

julia&gt; s, ∂s∂q₁, ∂s∂q₂, ∂s∂τ = slerp∂slerp(q₁, q₂, τ);
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/Quaternionic.jl/blob/d68feede90b1382512c6f8435fafb042fb0bfdd5/src/gradients.jl#L178-L216">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quaternionic.slerp∂slerp∂τ-Tuple{Rotor, Rotor, Real}" href="#Quaternionic.slerp∂slerp∂τ-Tuple{Rotor, Rotor, Real}"><code>Quaternionic.slerp∂slerp∂τ</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">slerp∂slerp∂τ(q₁, q₂, τ)</code></pre><p>Return the value and time-derivative of <code>slerp</code>.</p><p>See also <a href="#Quaternionic.slerp∂slerp-Tuple{Rotor, Rotor, Real}"><code>slerp∂slerp</code></a>, which returns the value and <em>all</em> of the derivatives of <code>slerp</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/Quaternionic.jl/blob/d68feede90b1382512c6f8435fafb042fb0bfdd5/src/gradients.jl#L251-L259">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quaternionic.squad∂squad∂t-NTuple{7, Any}" href="#Quaternionic.squad∂squad∂t-NTuple{7, Any}"><code>Quaternionic.squad∂squad∂t</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">squad∂squad∂t(qᵢ, A, B, qᵢ₊₁, ta, tb, t)</code></pre><p>Compute the value and time-derivative of <a href="#Quaternionic.squad-Union{Tuple{T}, Tuple{AbstractArray{Rotor{T}, 1}, AbstractVector{&lt;:Real}, AbstractVector{&lt;:Real}}} where T"><code>squad</code></a>.</p><p>This is primarily an internal helper function, taking various parameters computed within the <code>squad</code> function.  This will be used to compute the derivative of <code>squad</code> when the angular velocity is also requested.  To actually obtain the derivative, simply pass the relevant keyword to the <code>squad</code> function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/Quaternionic.jl/blob/d68feede90b1382512c6f8435fafb042fb0bfdd5/src/gradients.jl#L269-L280">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quaternionic.∂exp-Tuple{QuatVec}" href="#Quaternionic.∂exp-Tuple{QuatVec}"><code>Quaternionic.∂exp</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">∂exp(Z::QuatVec)</code></pre><p>Return the gradient of <code>exp(Z)</code> with respect to the components of <code>Z</code>.</p><p>The result includes &quot;off-shell&quot; components of the gradient, meaning that even though a scalar component of <code>Z</code> would not be allowed for a <code>QuatVec</code>, we measure the gradient in that direction anyway.  That is, the first element of the returned vector of quaternions is</p><p class="math-container">\[\begin{aligned}
  \left.\frac{\partial} {\partial Z_w} \exp(Z) \right|_{Z_w=0}.
\end{aligned}\]</p><p>Note that, even though <code>exp(::QuatVec)</code> is a <code>Rotor</code>, the derivative (and therefore each element of the result) is a general <code>Quaternion</code>.</p><p>See also <a href="#Quaternionic.∂log-Tuple{Rotor}"><code>∂log</code></a> for a similar function, as well as <a href="#Quaternionic.exp∂exp-Tuple{QuatVec}"><code>exp∂exp</code></a> for a function to compute the value along with the gradient.</p><p><strong>Examples</strong></p><pre><code class="language-julia">julia&gt; ∂exp∂w, ∂exp∂x, ∂exp∂y, ∂exp∂z = ∂exp(randn(QuatVecF64));
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/Quaternionic.jl/blob/d68feede90b1382512c6f8435fafb042fb0bfdd5/src/gradients.jl#L90-L116">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quaternionic.∂log-Tuple{Rotor}" href="#Quaternionic.∂log-Tuple{Rotor}"><code>Quaternionic.∂log</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">∂log(Z::Rotor)</code></pre><p>Return the gradient of <code>log(Z)</code> with respect to the components of <code>Z</code>.</p><p>The result includes &quot;off-shell&quot; components of the gradient, meaning that even though change of <code>Z</code> in a direction that changes its norm would not be allowed for a <code>Rotor</code>, we measure the gradient in that direction anyway.  That is, the elements of the returned vector of quaternions is</p><p class="math-container">\[\begin{aligned}
  \left[
    \frac{\partial} {\partial Z_w} \log(Z),
    \frac{\partial} {\partial Z_x} \log(Z),
    \frac{\partial} {\partial Z_y} \log(Z),
    \frac{\partial} {\partial Z_z} \log(Z)
  \right].
\end{aligned}\]</p><p>Note that, even though <code>log(::Rotor)</code> is a <code>QuatVec</code>, the derivative (and therefore each element of the result) is a general <code>Quaternion</code>.</p><p>See also <a href="#Quaternionic.∂exp-Tuple{QuatVec}"><code>∂exp</code></a> for a similar function, as well as <a href="#Quaternionic.log∂log-Tuple{Rotor}"><code>log∂log</code></a> for a function to compute the value along with the gradient.</p><p><strong>Examples</strong></p><pre><code class="language-julia">julia&gt; ∂log∂w, ∂log∂x, ∂log∂y, ∂log∂z = ∂log(randn(QuatVecF64));
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/Quaternionic.jl/blob/d68feede90b1382512c6f8435fafb042fb0bfdd5/src/gradients.jl#L1-L32">source</a></section></article><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-2"><a class="tag is-link" href="#citeref-2">2</a>As of this writing, <code>Zygote.jl</code> does <em>not</em> work.  I&#39;m not sure why, but I&#39;m guessing it&#39;s related to <a href="https://github.com/FluxML/Zygote.jl/issues/342"><code>Zygote</code>&#39;s troubles with complex numbers</a>.  I don&#39;t really understand AD terminology, but <a href="https://discourse.julialang.org/t/automatic-differentiation-of-complex-valued-functions/30263/8">this comment</a> suggests forward-mode AD is better for this kind of thing anyway.  In any case, pull requests for improving this package&#39;s interaction with AD are certainly welcome.</li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../manual/">« Basics</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Thursday 16 February 2023 05:04">Thursday 16 February 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
