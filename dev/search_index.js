var documenterSearchIndex = {"docs":
[{"location":"manual/#Quaternionic-functions","page":"Manual","title":"Quaternionic functions","text":"","category":"section"},{"location":"manual/#Constructors-and-Number-methods","page":"Manual","title":"Constructors and Number methods","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"At the most basic level, Quaternion{T} mimics Complex{T} as closely as possible, including the behavior of most functions in Base.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"To create new Quaternions interactively, it is typically most convenient to use the constants imx, imy, and imz — or equivalently 𝐢, 𝐣, and 𝐤 — multiplied by appropriate factors and added together.  For programmatic work, it is more common to use the Quaternion function — which takes all four components, the three vector components, or just the one scalar component, and creates a new Quaternion of the type implied by the arguments.  You can also specify the type, as in Quaternion{Float64}(...).  Type conversions with promote, widen, float, etc., work as expected.  The standard Number functions that work for Complex, such as isfinite, iszero, etc., should work analogously for Quaternion.  The hash, read, and write functions are also implemented.  As noted in the Examples, broadcasting to each component is also implemented via broadcasted.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Modules = [Quaternionic]\nPages   = [\"quaternion.jl\"]","category":"page"},{"location":"manual/#Quaternionic.imx","page":"Manual","title":"Quaternionic.imx","text":"imx\n\nThe quaternionic unit associated with rotation about the x axis.  Can also be entered as Unicode bold: 𝐢.\n\nExamples\n\njulia> imx * imx\n-1 + 0𝐢 + 0𝐣 + 0𝐤\njulia> 1.2imx\n0.0 + 1.2𝐢 + 0.0𝐣 + 0.0𝐤\n\n\n\n\n\n","category":"constant"},{"location":"manual/#Quaternionic.imy","page":"Manual","title":"Quaternionic.imy","text":"imy\n\nThe quaternionic unit associated with rotation about the y axis.  Can also be entered as Unicode bold: 𝐣.\n\nExamples\n\njulia> imy * imy\n-1 + 0𝐢 + 0𝐣 + 0𝐤\njulia> 1.2imy\n0.0 + 0.0𝐢 + 1.2𝐣 + 0.0𝐤\n\n\n\n\n\n","category":"constant"},{"location":"manual/#Quaternionic.imz","page":"Manual","title":"Quaternionic.imz","text":"imz\n\nThe quaternionic unit associated with rotation about the z axis.  Can also be entered as Unicode bold: 𝐤.\n\nExamples\n\njulia> imz * imz\n-1 + 0𝐢 + 0𝐣 + 0𝐤\njulia> 1.2imz\n0.0 + 0.0𝐢 + 0.0𝐣 + 1.2𝐤\n\n\n\n\n\n","category":"constant"},{"location":"manual/#Quaternionic.Quaternion","page":"Manual","title":"Quaternionic.Quaternion","text":"Quaternion{T<:Real} <: Number\n\nQuaternionic number type with elements of type T.\n\nQuaternionF16, QuaternionF32 and QuaternionF64 are aliases for Quaternion{Float16}, Quaternion{Float32} and Quaternion{Float64} respectively.\n\nSee also: Quaternion\n\n\n\n\n\n","category":"type"},{"location":"manual/#Quaternionic.Quaternion-NTuple{4, Real}","page":"Manual","title":"Quaternionic.Quaternion","text":"Quaternion(w, x, y, z)\nQuaternion(x, y, z)\nQuaternion(w)\nQuaternion{T}(w, x, y, z)\n\nCreates a new quaternion with the given components.  The first argument w is the scalar component, and x, y, and z are the corresponding \"vector\" components.  The type of the returned quaternion will be inferred from the input arguments.  If numeric arguments are missing, they will be set to zero. The element type T can also be specified, by passing the type parameter as usual.\n\nNote that the constants imx, imy, and imz can also be used like the complex im to create new Quaternion object.\n\nExamples\n\njulia> Quaternion(1, 2, 3, 4)\n1 + 2𝐢 + 3𝐣 + 4𝐤\njulia> Quaternion{Float64}(1, 2, 3, 4)\n1.0 + 2.0𝐢 + 3.0𝐣 + 4.0𝐤\njulia> Quaternion(1.0, 2.0, 3.0, 4.0)\n1.0 + 2.0𝐢 + 3.0𝐣 + 4.0𝐤\njulia> Quaternion(2, 3, 4)\n0 + 2𝐢 + 3𝐣 + 4𝐤\njulia> Quaternion(1)\n1 + 0𝐢 + 0𝐣 + 0𝐤\n\n\n\n\n\n","category":"method"},{"location":"manual/#Algebra-and-mathematical-functions","page":"Manual","title":"Algebra and mathematical functions","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"Along with the basic binary operators, the essential mathematical functions like conj, abs, abs2, exp, log, etc., are implemented.  Most of these functions are found in the Base module, and are simply overloaded methods of functions that should also be familiar from Complex types.  Note that we use a slightly different interpretation of angle for Quaternion, compared to Complex.  We also have absvec and abs2vec, which are not useful in a Complex context, but compute the relevant quantities for the \"vector\" component of a Quaternion.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Modules = [Quaternionic]\nPages   = [\"algebra.jl\", \"math.jl\"]","category":"page"},{"location":"manual/#Base.conj-Tuple{Quaternion}","page":"Manual","title":"Base.conj","text":"conj(q)\n\nReturn the quaternion conjugate, which flips the sign of each \"vector\" component.\n\nExamples\n\njulia> conj(Quaternion(1,2,3,4))\n1 - 2𝐢 - 3𝐣 - 4𝐤\n\n\n\n\n\n","category":"method"},{"location":"manual/#Base.abs-Tuple{Quaternion}","page":"Manual","title":"Base.abs","text":"abs(q)\n\nSquare-root of the sum the squares of the components of the quaternion\n\nExamples\n\njulia> abs(Quaternion(1,2,4,10))\n11.0\n\n\n\n\n\n","category":"method"},{"location":"manual/#Base.abs2-Tuple{Quaternion}","page":"Manual","title":"Base.abs2","text":"abs2(q)\n\nSum the squares of the components of the quaternion\n\nExamples\n\njulia> abs2(Quaternion(1,2,4,10))\n121\n\n\n\n\n\n","category":"method"},{"location":"manual/#Base.angle-Tuple{Quaternion}","page":"Manual","title":"Base.angle","text":"angle(q)\n\nPhase angle in radians of the rotation represented by this quaternion.\n\nNote that this may be different from your interpretation of the angle of a complex number in an important way.  Because quaternions act on vectors by conjugation — as in q*v*conj(q) — there are two copies of q involved in that expression; in some sense, a quaternion acts \"twice\".  Therefore, this angle may be twice what you expect from an analogy with complex numbers — dpending on how you interpret the correspondence between complex numbers and quaternions.  Also, while rotations in the complex plane have a natural choice of axis (the positive z direction), that is not the case for quaternions, which means that the sign of this angle is arbitrary, and we always choose it to be positive.\n\nExamples\n\njulia> θ=1.2;\n\njulia> R=exp(θ * imz / 2);\n\njulia> angle(R)\n1.2\n\n\n\n\n\n\n","category":"method"},{"location":"manual/#Base.exp-Union{Tuple{Quaternion{T}}, Tuple{T}} where T","page":"Manual","title":"Base.exp","text":"exp(q)\n\nExponential of a quaternion\n\nExamples\n\njulia> exp(imx*π/4)  # Rotation through π/2 (note the extra 1/2) about the x axis\n0.7071067811865476 + 0.7071067811865475𝐢 + 0.0𝐣 + 0.0𝐤\n\n\n\n\n\n","category":"method"},{"location":"manual/#Base.log-Union{Tuple{Quaternion{T}}, Tuple{T}} where T","page":"Manual","title":"Base.log","text":"log(q)\n\nLogarithm of a quaternion.\n\nAs with the usual complex logarithm, the quaternion logarithm has multiple branches, though the quaternion branches are three-dimensional: for any unit \"vector\" quaternion q̂, you could add any integer multiple of 2πq̂ to the result of this function and still get the same result after exponentiating (within numerical accuracy).  This function is the principal logarithm.\n\nThis function has discontinuous (and fairly arbitrary) behavior along the negative real axis: if the \"vector\" components of the quaternion are precisely zero and the scalar component is negative, the returned quaternion will have scalar component log(-q.w), but will also have a z component of π.  The choice of the z direction is arbitrary; the \"vector\" component of the returned quaternion could be π times any unit vector.\n\nNote that this function is not specialized to unit-quaternion inputs, so the scalar component of the returned value will be nonzero unless the input has precisely unit magnitude.\n\nExamples\n\njulia> log(exp(1.2imy))\n0.0 + 0.0𝐢 + 1.2𝐣 + 0.0𝐤\n\njulia> log(Quaternion(exp(7)))\n7.0 + 0.0𝐢 + 0.0𝐣 + 0.0𝐤\n\njulia> log(Quaternion(-exp(7)))\n7.0 + 0.0𝐢 + 0.0𝐣 + 3.141592653589793𝐤\n\n\n\n\n\n","category":"method"},{"location":"manual/#Base.sqrt-Union{Tuple{Quaternion{T}}, Tuple{T}} where T","page":"Manual","title":"Base.sqrt","text":"sqrt(q)\n\nSquare-root of a quaternion.\n\nThe general formula whenever the denominator is nonzero is\n\nsqrtq = fracq + q sqrt2q + 2qw\n\nThis can be proven by expanding q as q.w + q.vec and multiplying the expression above by itself.\n\nWhen the denominator is zero, this function has discontinuous (and fairly arbitrary) behavior, just as with the quaternion log function.  In this case, either all components are zero — in which case the result is simply the zero quaternion — or the \"vector\" components of the quaternion are precisely zero and the scalar component is negative.  If the latter is true, the denominator above will be a pure-imaginary number.  Because the quaternions come with infinitely many elements that square to -1, it is not clear which imaginary should be used, so we arbitrarily choose to set the result proportional to the z quaternion.  The choice of the z direction is arbitrary; the \"vector\" component of the returned quaternion could be in any direction.\n\nExamples\n\njulia> q = Quaternion(1.2, 3.4, 5.6, 7.8);\n\njulia> sqrtq = √q;\n\njulia> sqrtq^2 ≈ q\ntrue\n\njulia> √Quaternion(4)\n2.0 + 0.0𝐢 + 0.0𝐣 + 0.0𝐤\n\njulia> √Quaternion(-4)\n0.0 + 0.0𝐢 + 0.0𝐣 + 2.0𝐤\n\n\n\n\n\n","category":"method"},{"location":"manual/#Quaternionic.abs2vec-Tuple{Quaternion}","page":"Manual","title":"Quaternionic.abs2vec","text":"abs2vec(q)\n\nSum the squares of the \"vector\" components of the quaternion\n\nExamples\n\njulia> abs2vec(Quaternion(1,2,3,6))\n49\n\n\n\n\n\n","category":"method"},{"location":"manual/#Quaternionic.absvec-Tuple{Quaternion}","page":"Manual","title":"Quaternionic.absvec","text":"absvec(q)\n\nSquare-root of the sum of the squares of the \"vector\" components of the quaternion\n\nExamples\n\njulia> absvec(Quaternion(1,2,3,6))\n7.0\n\n\n\n\n\n","category":"method"},{"location":"manual/#Random-quaternions","page":"Manual","title":"Random quaternions","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"It is frequently convenient to construct random Quaternion objects, which can be done just as with other types by passing the desired output type to the randn function.  The rand function is not overloaded, because there would be no geometric significance to such a Quaternion; randn results are independent of the orientation of the basis used to define the quaternions.  A simple convenience function randn_rotor is also provided, to normalize each result.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Modules = [Quaternionic]\nPages   = [\"random.jl\"]","category":"page"},{"location":"manual/#Base.randn-Union{Tuple{T}, Tuple{Random.AbstractRNG, Type{Quaternion{T}}}} where T<:AbstractFloat","page":"Manual","title":"Base.randn","text":"randn([rng=GLOBAL_RNG], [T=Quaternion{Float64}], [dims...])\n\nGenerate a normally distributed random quaternion of type T with mean 0 and standard deviation of norm 1.  Optionally generate an array of such quaternions.  This module currently provides an implementation for the types QuaternionF16, QuaternionF32, and QuaternionF64 (the default).  The values are drawn from the spherically symmetric quaternionic normal distribution of variance 1 (corresponding to each component having independent normal distribution with mean zero and variance 1/4).\n\nNote that this function works with any Quaternion{<:AbstractFloat}, including Quaternion{BigFloat}, even though Base.randn does not work with BigFloat; we just use the Box-Muller transform to obtain the desired result.\n\nSee also: randn_rotor\n\nExamples\n\njulia> randn(QuaternionF64)\n0.4336736009756228 - 0.45087190792840853𝐢 - 0.24723937675211696𝐣 - 0.4514571469326208𝐤\njulia> randn(QuaternionF16, 2, 2)\n2×2 Matrix{QuaternionF16}:\n   0.4321 + 1.105𝐢 + 0.2664𝐣 - 0.1359𝐤   0.064 + 0.9263𝐢 - 0.4138𝐣 + 0.05505𝐤\n 0.2512 - 0.2585𝐢 - 0.2803𝐣 - 0.00964𝐤  -0.1256 + 0.1848𝐢 + 0.03607𝐣 - 0.752𝐤\n\n\n\n\n\n","category":"method"},{"location":"manual/#Quaternionic.randn_rotor-Union{Tuple{T}, Tuple{Random.AbstractRNG, Type{T}, Tuple{Vararg{Int64, N}} where N}} where T<:AbstractFloat","page":"Manual","title":"Quaternionic.randn_rotor","text":"randn_rotor([rng=GLOBAL_RNG], [T=Quaternion{Float64}], [dims...])\n\nGenerate a normally distributed random quaternion of type T with mean 0 and norm 1.  (Note that the norm is always precisely 1 with this function, but otherwise the individual components are randomly distributed.)  The result is spherically symmetric, and gives rise a truly random rotation.\n\nSee also: randn\n\n\n\n\n\n","category":"method"},{"location":"manual/#Conversions","page":"Manual","title":"Conversions","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"It can sometimes be useful to convert between quaternions and other representations.  Most of these functions are named to_<representation> and have a corresponding from_<representation> function.  Furthermore, most convert to/from representations of rotations.  While rotations are not the only useful application of quaternions, they are probably the most common.  The only conversions that are not specifically related to rotations are to_float_array and from_float_array.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Modules = [Quaternionic]\nPages   = [\"conversion.jl\"]","category":"page"},{"location":"manual/#Quaternionic.from_euler_angles-Tuple{Any, Any, Any}","page":"Manual","title":"Quaternionic.from_euler_angles","text":"from_euler_angles(α, β, γ)\n\nCome over from the dark side.\n\nAssumes the Euler angles correspond to the quaternion R via\n\nR = exp(α𝐤/2) * exp(β𝐣/2) * exp(γ𝐤/2)\n\nwhere 𝐣 and 𝐤 rotate about the fixed y and z axes, respectively, so this reprents an initial rotation (in the positive sense) through an angle γ about the axis z, followed by a rotation through β about the axis y, and a final rotation through α about the axis z.  This is equivalent to performing an initial rotation through α about the axis z, followed by a rotation through β about the rotated axis y, followed by a rotation through γ about the twice-rotated axis z. The angles are naturally assumed to be in radians.\n\nNOTE: Before opening an issue reporting something \"wrong\" with this function, be sure to read all of this page, especially the very last section about opening issues or pull requests.\n\nSee Also\n\nto_euler_angles: Convert quaternion to Euler angles\nto_euler_phases: Convert quaternion to Euler phases\nfrom_euler_phases: Create quaternion from Euler phases\n\n\n\n\n\n","category":"method"},{"location":"manual/#Quaternionic.from_euler_phases-Tuple{Any, Any, Any}","page":"Manual","title":"Quaternionic.from_euler_phases","text":"from_euler_phases(zₐ, zᵦ, zᵧ)\nfrom_euler_phases(z)\n\nReturn the quaternion corresponding to these Euler phases.\n\nInterpreting the input quaternion as a rotation (though its normalization scales out), we can define the complex Euler phases from the Euler angles (α, β, γ) as\n\nzₐ ≔ exp(i*α)\nzᵦ ≔ exp(i*β)\nzᵧ ≔ exp(i*γ)\n\nThese are more useful geometric quantites than the angles themselves — being involved in computing spherical harmonics and Wigner's 𝔇 matrices — and can be computed from the components of the corresponding quaternion algebraically (without the use of transcendental functions).\n\nParameters\n\nz::Vector{Complex{T}}: complex vector of length 3, representing the complex phases (zₐ, zᵦ, zᵧ) in that order.\n\nReturns\n\nR::Quaternion{T}\n\nSee Also\n\nto_euler_phases: Convert quaternion to Euler phases\nto_euler_angles: Convert quaternion to Euler angles\nfrom_euler_angles: Create quaternion from Euler angles\n\n\n\n\n\n","category":"method"},{"location":"manual/#Quaternionic.from_float_array-Union{Tuple{AbstractArray{T, N} where N}, Tuple{T}} where T<:Real","page":"Manual","title":"Quaternionic.from_float_array","text":"from_float_array(A)\n\nReinterpret a real array as an array of quaternions\n\nThe input array must have an initial dimension whose size is 4, because successive indices in that dimension will be considered successive components of the output quaternion.\n\nNote that this returns a view of the original data only if the base type of the input array isbitstype; otherwise, a new array of Quaternions must be created, and the memory copied.\n\nSee also to_float_array.\n\n\n\n\n\n","category":"method"},{"location":"manual/#Quaternionic.from_rotation_matrix-Tuple{Any}","page":"Manual","title":"Quaternionic.from_rotation_matrix","text":"from_rotation_matrix(ℛ)\n\nConvert 3x3 rotation matrix to quaternion.\n\nAssuming the 3x3 matrix ℛ rotates a vector v according to\n\nv' = ℛ * v,\n\nwe can also express this rotation in terms of a quaternion R such that\n\nv' = R * v * R⁻¹.\n\nThis function returns that quaternion, using Bar-Itzhack's algorithm to allow for non-orthogonal matrices.  J. Guidance, Vol. 23, No. 6, p. 1085\n\n\n\n\n\n","category":"method"},{"location":"manual/#Quaternionic.from_spherical_coordinates-Tuple{Any, Any}","page":"Manual","title":"Quaternionic.from_spherical_coordinates","text":"from_spherical_coordinates(θ, ϕ)\n\nReturn a quaternion corresponding to these spherical coordinates.\n\nConsidering (θ, ϕ) as a point n on the sphere, we can also construct a quaternion that rotates the z axis onto that point.  Here, we use the standard commonly used in physics: θ represents the \"polar angle\" between the z axis and the direction n, while ϕ represents the \"azimuthal angle\" between the x axis and the projection of n into the x-y plane. Both angles must be given in radians.\n\n\n\n\n\n","category":"method"},{"location":"manual/#Quaternionic.to_euler_angles-Tuple{Quaternion}","page":"Manual","title":"Quaternionic.to_euler_angles","text":"to_euler_angles(R)\n\nOpen Pandora's Box.\n\nIf somebody is trying to make you use Euler angles, tell them no, and walk away, and go and tell your mum.\n\nYou don't want to use Euler angles.  They are awful.  Stay away.  It's one thing to convert from Euler angles to quaternions; at least you're moving in the right direction.  But to go the other way?!  It's just not right.\n\nAssumes the Euler angles correspond to the quaternion R via\n\nR = exp(α𝐤/2) * exp(β𝐣/2) * exp(γ𝐤/2)\n\nwhere 𝐣 and 𝐤 rotate about the fixed y and z axes, respectively, so this reprents an initial rotation (in the positive sense) through an angle γ about the axis z, followed by a rotation through β about the axis y, and a final rotation through α about the axis z.  This is equivalent to performing an initial rotation through α about the axis z, followed by a rotation through β about the rotated axis y, followed by a rotation through γ about the twice-rotated axis z. The angles are naturally assumed to be in radians.\n\nNOTE: Before opening an issue reporting something \"wrong\" with this function, be sure to read all of this page, especially the very last section about opening issues or pull requests.\n\nReturns\n\nαβγ::Vector{T}\n\nRaises\n\nAllHell if you try to actually use Euler angles, when you could have been using quaternions like a sensible person.\n\nSee Also\n\nfrom_euler_angles: Create quaternion from Euler angles\nto_euler_phases: Convert quaternion to Euler phases\nfrom_euler_phases: Create quaternion from Euler phases\n\n\n\n\n\n","category":"method"},{"location":"manual/#Quaternionic.to_euler_phases-Union{Tuple{Quaternion{T}}, Tuple{T}} where T","page":"Manual","title":"Quaternionic.to_euler_phases","text":"to_euler_phases(q)\nto_euler_phases!(z, q)\n\nConvert input quaternion to complex phases of Euler angles\n\nInterpreting the input quaternion as a rotation (though its normalization scales out), we can define the complex Euler phases from the Euler angles (α, β, γ) as\n\nzₐ ≔ exp(i*α)\nzᵦ ≔ exp(i*β)\nzᵧ ≔ exp(i*γ)\n\nThese are more useful geometric quantites than the angles themselves — being involved in computing spherical harmonics and Wigner's 𝔇 matrices — and can be computed from the components of the corresponding quaternion algebraically (without the use of transcendental functions).\n\nReturns\n\nz::Vector{Complex{T}}: complex phases (zₐ, zᵦ, zᵧ) in that order.\n\nSee Also\n\nfrom_euler_phases: Create quaternion from Euler phases\nto_euler_angles: Convert quaternion to Euler angles\nfrom_euler_angles: Create quaternion from Euler angles\n\n\n\n\n\n","category":"method"},{"location":"manual/#Quaternionic.to_float_array-Union{Tuple{AbstractArray{Quaternion{T}, N} where N}, Tuple{T}} where T<:Real","page":"Manual","title":"Quaternionic.to_float_array","text":"to_float_array(A)\n\nView a quaternion array as an array of real numbers\n\nThe output array will have an extra initial dimension whose size is 4, because successive indices in that dimension correspond to successive components of the quaternion.\n\nNote that this returns a view of the original data only if the base type of the input array isbitstype; otherwise, a new array of that type must be created, and the memory copied.\n\nSee also from_float_array.\n\n\n\n\n\n","category":"method"},{"location":"manual/#Quaternionic.to_rotation_matrix-Tuple{Any}","page":"Manual","title":"Quaternionic.to_rotation_matrix","text":"to_rotation_matrix(q)\n\nConvert quaternion to 3x3 rotation matrix.\n\nAssuming the quaternion R rotates a vector v according to\n\nv' = R * v * R⁻¹,\n\nwe can also express this rotation in terms of a 3x3 matrix ℛ such that\n\nv' = ℛ * v.\n\nThis function returns that matrix.\n\n\n\n\n\n","category":"method"},{"location":"manual/#Quaternionic.to_spherical_coordinates-Tuple{Quaternion}","page":"Manual","title":"Quaternionic.to_spherical_coordinates","text":"to_spherical_coordinates(q)\n\nReturn the spherical coordinates corresponding to this quaternion.\n\nWe can treat the quaternion as a transformation taking the z axis to some direction n.  This direction can be described in terms of spherical coordinates (θ, ϕ).  Here, we use the standard commonly used in physics: θ represents the \"polar angle\" between the z axis and the direction n, while ϕ represents the \"azimuthal angle\" between the x axis and the projection of n into the x-y plane.  Both angles are given in radians.\n\n\n\n\n\n","category":"method"},{"location":"manual/#Distances","page":"Manual","title":"Distances","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"There are several ways of measuring the \"distance\" between two quaternions: d(q_1 q_2).  Fundamentally, any comparison between two quaternions q_1 and q_2 must make use of a binary operation, for which there are two obvious choices: addition or multiplication.  For either choice, we operate on q_1 and the appropriate inverse (either additive or multiplicative) of q_2.  That is, d should be a function of either q_1 - q_2 or q_1q_2.[1]","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"[1]: For q_1q_2, we are dealing with the multiplicative group of quaternions, which does not include 0, so we will assume that no quaternion involved in such a function can be 0.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Now, we also have a number of criteria we would like any distance function to satisfy.  For any quaternions q_1 and q_2 and any unit quaternion q_3, we require","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"real-valued: d(q_1 q_2) in mathbbR\nsymmetry: d(q_1 q_2) = d(q_2 q_1)\ninvariance: d(q_3 q_1 q_3 q_2) = d(q_1 q_2) = d(q_1 q_3 q_2 q_3)\nidentity: d(q_1 q_1) = 0\npositive-definiteness: d(q_1 q_2)  0 whenever q_1  q_2","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"(Of course, it should be noted that these criteria all hold in the exact case; when using floating-point numbers, will likely be violated near edge cases.)","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"It is not hard to see that these criteria can be satisfied by any of","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"abs2(q₁ - q₂)\nabs(q₁ - q₂)\nabs2(log(q₁ / q₂)\nabs(log(q₁ / q₂))","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"If q_1 and q_2 are interpreted as rotations, we frequently don't care about their signs, and just want the smallest distance between them, for any choice of sign.  Furthermore, in the multiplicative case, the log functions will involve calculation of the log of the magnitudes of the quaternions, which should be 1.  In this case, we relax the \"positive-definiteness\" criterion to allow d(q_1 q_2) to equal zero when q_1 and q_2 are related by a nonzero scalar multiple.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"While these functions are simple to implement as needed, it is also useful to have a single function to remind us of all the possibilities.  The distance function implements all these possible choices with keyword arguments.  The distance_rotation function is similar, but restricts to the multiplicative case, and assumes rotations.  These two functions, with their default arguments, are likely to be the most commonly needed functions.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Modules = [Quaternionic]\nPages   = [\"distance.jl\"]","category":"page"},{"location":"manual/#Quaternionic.distance-Tuple{Any, Any}","page":"Manual","title":"Quaternionic.distance","text":"distance(q₁, q₂; multiplicative=false, sqrt=false, rotation=false)\n\nMeasure the \"distance\" between two quaternions.\n\nBy default, this function just returns the natural measure in the additive group of quaternions:\n\nabs2(q₁ - q₂)\n\nIf multiplicative=true is passed as a keyword, the function returns the natural measure in the multiplicative group:\n\nabs2(log(q₁ / q₂))\n\n[Note that this will return NaN if either input is 0.]\n\nIf sqrt=true is passed, the square-root of the result will be taken (so, abs instead of abs2).\n\nFinally, if rotation=true is passed, the input quaternions will be interpreted as quaternions, in which case the result will be the smallest possible value for any combination of their signs.\n\nSee also distance_rotation.\n\nExamples\n\njulia> distance(imz, -imz)\n4\njulia> distance(imz, -imz, rotation=true)\n0\njulia> distance(1, imx, multiplicative=true, sqrt=true)  # π/2\n1.5707963267948966\n\n\n\n\n\n","category":"method"},{"location":"manual/#Quaternionic.distance_rotation-Tuple{Any, Any}","page":"Manual","title":"Quaternionic.distance_rotation","text":"distance_rotation(q₁, q₂; sqrt=false)\n\nReturn abs2(log(q₁/q₂)), but assume that the signs and magnitudes of the input quaternions do not matter.  If sqrt=true, we return the square-root of that result.\n\nThis function is just a simple wrapper calling the distance function as\n\ndistance(q₁, q₂; multiplicative=true, sqrt=sqrt, rotation=true)\n\n\n\n\n\n","category":"method"},{"location":"#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Quaternions for Julia","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The goal of this package is to provide a simple but flexible and complete implementation of quaternions, without restricting the interpretation of quaternions to being rotations, but also providing extensive support for rotations.","category":"page"},{"location":"#Examples","page":"Introduction","title":"Examples","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"There are numerous ways to construct a Quaternion — the simplest being to just give the components:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"julia> using Quaternionic\n\njulia> q = Quaternion(1.0, 2.0, 3.0, 4.0)\n1.0 + 2.0𝐢 + 3.0𝐣 + 4.0𝐤\njulia> p = Quaternion(4, 3, 2, 1)\n4 + 3𝐢 + 2𝐣 + 1𝐤","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Each quaternion type is parametrized by the types of its components (which are promoted to be all the same type).  Any subtype of Real is allowed, and is detected automatically.  For example, q has type Quaternion{Float64}, while p has type Quaternion{Int64}.[1] The base type may be given explicitly if desired, to override the detected type:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"julia> r = Quaternion{Float64}(4, 3, 2, 1)\n4.0 + 3.0𝐢 + 2.0𝐣 + 1.0𝐤","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The various Float and Int types work well, as do BigFloat, and the Num type from Symbolics.jl. In particular, we can use symbolic expressions as components:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"julia> using Quaternionic, Symbolics\n\njulia> @variables a b c d e;\n\njulia> Quaternion(a-b, b*c, c/d, d+e)\na - b + b*c𝐢 + {c*(d^-1)}𝐣 + {d + e}𝐤","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"It is also possible to construct random quaternions using randn with a Quaternion type. In analogy with the complex types, the aliases QuaternionF64, QuaternionF32, and QuaternionF16 are provided, as well as the constants imx, imy, and imz, and (for copy-paste convenience) the aliases 𝐢, 𝐣, and 𝐤 (as Unicode bold characters):","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"julia> QuaternionF64\nQuaternionF64 (alias for Quaternion{Float64})\njulia> 0.1 + 2.3imx + 4.5imz\n0.1 + 2.3𝐢 + 0.0𝐣 + 4.5𝐤\njulia> 0.1 + 2.3𝐢 + 0.0𝐣 + 4.5𝐤\n0.1 + 2.3𝐢 + 0.0𝐣 + 4.5𝐤","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"As with the complex im, the result of multiplying imx, etc., with any real number will be a quaternion with the type of the other number.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"[1]: Note that, mathematically speaking, quaternions can only be defined over a field, which necessarily cannot be an integer type (because the multiplicative inverse of an integer is not generally an integer).  Nonetheless, it is possible to define a Quaternion{<:Integer}, which should behave as expected.  However, many functions (such as exp, log, etc.)  will then return a Quaternion of some different type, just as is the case for Complex{<:Integer}.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Components of a quaternion can be accessed as fields:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"julia> q.w, q.x, q.y, q.z\n(1.0, 2.0, 3.0, 4.0)","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"You can also extract the \"vector\" component (the last three elements) as","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"julia> q.vec\n3-element Vector{Float64}:\n 2.0\n 3.0\n 4.0","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"For convenience, the scalar and vector components can also be accessed in analogy with complex numbers as","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"julia> q.re\n1.0\njulia> q.im\n3-element Vector{Float64}:\n 2.0\n 3.0\n 4.0\njulia> real(q)\n1.0\njulia> imag(q)\n3-element Vector{Float64}:\n 2.0\n 3.0\n 4.0","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"It is also possible to index an individual Quaternion just as you would an array (of length 4):","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"julia> q[1]\n1.0\njulia> q[[3, 2]]\n2-element Vector{Float64}:\n 3.0\n 2.0","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Functions may also be broadcast to each component of a Quaternion.  For example, this can be particularly helpful when simplifying Symbolics expressions:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"julia> @variables q[1:4];\n\njulia> Q = Quaternion(q);\n\njulia> simplify.(Q * imz * conj(Q))\n0 + {2q₁*q₃ + 2q₂*q₄}𝐢 + {2q₃*q₄ - (2q₁*q₂)}𝐣 + {q₁^2 + q₄^2 - (q₂^2) - (q₃^2)}𝐤","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The basic algebraic operations work as you would expect:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"julia> p + q\n5.0 + 5.0𝐢 + 5.0𝐣 + 5.0𝐤\njulia> p - q\n3.0 + 1.0𝐢 - 1.0𝐣 - 3.0𝐤\njulia> p * q\n-12.0 + 16.0𝐢 + 4.0𝐣 + 22.0𝐤\njulia> q * p  # Note the non-commutativity\n-12.0 + 6.0𝐢 + 24.0𝐣 + 12.0𝐤\njulia> q / p\n0.6666666666666666 + 0.3333333333333333𝐢 + 0.0𝐣 + 0.6666666666666666𝐤","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Essential mathematical functions familiar from complex math, such as conj, abs, abs2, log, exp, etc., are also available.","category":"page"},{"location":"#Contents","page":"Introduction","title":"Contents","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Depth = 4","category":"page"},{"location":"#Function-list","page":"Introduction","title":"Function list","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"The following list contains the public functions inside the Quaternionic module.  Note that there are also many standard math functions defined for Quaternions that live in the Base module, as noted above.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Modules = [Quaternionic]","category":"page"}]
}
