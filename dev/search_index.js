var documenterSearchIndex = {"docs":
[{"location":"manual/#Quaternionic-functions","page":"Manual","title":"Quaternionic functions","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"From AbstractQuaternion{T} we define three subtypes:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Quaternion{T}, which is an element of the general algebra of quaternions over any T<:Real.\nRotor{T}, which is an element of the multiplicative group of unit quaternions, and is interpreted as mapping to a rotation.  The magnitude is assumed to be 1 (though, for efficiency, this is not generally confirmed), and the sign may be freely changed in certain cases.\nQuatVec{T}, which is an element of the additive group of quaternions with 0 scalar part; a \"pure vector\" quaternion.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"For simplicity, almost every function in this package is defined for general Quaternions, so you may not need any other type.  However, it can frequently be more accurate and more efficient to use the other subtypes where relevant.","category":"page"},{"location":"manual/#Constructors,-constants,-and-conversions","page":"Manual","title":"Constructors, constants, and conversions","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"At the most basic level, Quaternion{T} mimics Complex{T} as closely as possible, including the behavior of most functions in Base.  The Rotor{T} and QuatVec{T} subtypes behave very similarly, except that most of their constructors automatically impose the constraints that the norm is 1 and the scalar component is 0, respectively.  Also note that when a certain operation is not defined for either of those subtypes, the functions will usually convert to a general Quaternion automatically.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"To create new Quaternions interactively, it is typically most convenient to use the constants imx, imy, and imz — or equivalently 𝐢, 𝐣, and 𝐤 — multiplied by appropriate factors and added together.  For programmatic work, it is more common to use the Quaternion function — which takes all four components, the three vector components, or just the one scalar component, and creates a new Quaternion of the type implied by the arguments.  You can also specify the type, as in Quaternion{Float64}(...).  Type conversions with promote, widen, float, etc., work as expected.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Modules = [Quaternionic]\nPages   = [\"quaternion.jl\"]\nOrder   = [:module, :type, :constant, :function, :macro]","category":"page"},{"location":"manual/#Quaternionic.QuatVec","page":"Manual","title":"Quaternionic.QuatVec","text":"QuatVec{T<:Real} <: Number\n\nPure-vector quaternion with elements of type T.  These objects can be significantly faster and more accurate in certain operations than general Quaternions.\n\nQuatVecF16, QuatVecF32 and QuatVecF64 are aliases for QuatVec{Float16}, QuatVec{Float32} and QuatVec{Float64} respectively.  See also Quaternion and Rotor.\n\nThe functions\n\nQuatVec(w, x, y, z)\nQuatVec(x, y, z)\nQuatVec(w)\nQuatVec{T}(w, x, y, z)\n\ncreate a new rotor with the given components (where the components are as described in Quaternion), except that the scalar argument w is always set to 0.\n\nExamples\n\njulia> QuatVec(1, 2, 3, 4)\n0 + 2𝐢 + 3𝐣 + 4𝐤\njulia> QuatVec(Quaternion(1, 2, 3, 4))\n0 + 2𝐢 + 3𝐣 + 4𝐤\njulia> QuatVec(2, 3, 4)\n0 + 2𝐢 + 3𝐣 + 4𝐤\njulia> QuatVec(1)\n0 + 0𝐢 + 0𝐣 + 0𝐤\n\n\n\n\n\n","category":"type"},{"location":"manual/#Quaternionic.Quaternion","page":"Manual","title":"Quaternionic.Quaternion","text":"Quaternion{T<:Real} <: Number\n\nQuaternionic number type with elements of type T.\n\nQuaternionF16, QuaternionF32 and QuaternionF64 are aliases for Quaternion{Float16}, Quaternion{Float32} and Quaternion{Float64} respectively.  See also Rotor and QuatVec.\n\nThe functions\n\nQuaternion(w, x, y, z)\nQuaternion(x, y, z)\nQuaternion(w)\nQuaternion{T}(w, x, y, z)\n\ncreate a new quaternion with the given components.  The argument w is the scalar component, and x, y, and z are the corresponding \"vector\" components.  If any of these arguments is missing, it will be set to zero.  The type of the returned quaternion will be inferred from the input arguments, or can be specified, by passing the type parameter T as above.\n\nNote that the constants imx, imy, and imz can also be used like the complex im to create new Quaternion object.\n\nExamples\n\njulia> Quaternion(1, 2, 3, 4)\n1 + 2𝐢 + 3𝐣 + 4𝐤\njulia> Quaternion{Float64}(1, 2, 3, 4)\n1.0 + 2.0𝐢 + 3.0𝐣 + 4.0𝐤\njulia> Quaternion(1.0, 2.0, 3.0, 4.0)\n1.0 + 2.0𝐢 + 3.0𝐣 + 4.0𝐤\njulia> Quaternion(2, 3, 4)\n0 + 2𝐢 + 3𝐣 + 4𝐤\njulia> Quaternion(1)\n1 + 0𝐢 + 0𝐣 + 0𝐤\n\n\n\n\n\n","category":"type"},{"location":"manual/#Quaternionic.Rotor","page":"Manual","title":"Quaternionic.Rotor","text":"Rotor{T<:Real} <: Number\n\nQuaternion of unit magnitude with elements of type T.  These objects can be significantly faster and more accurate in certain operations representing rotations.\n\nA rotor is typically considered to be an element of the group mathrmSpin(3)  mathrmSU(2), which can be thought of as the subgroup of quaternions with norm 1.  They are particularly useful as representations of rotations because a rotor R acts on a vector vecv by \"conjugation\" as\n\nvecv = R vecv R^-1\n\nThis preserves the inner product between any two vectors conjugated in this way, and so is a rotation.  Note that, because there are two factors of R here, the sign of R does not affect the result.  Therefore, mathrmSpin(3) forms a double cover of the rotation group mathrmSO(3).  For this reason, it will occasionally be useful to disregard or arbitrarily change the sign of a Rotor (as in distance functions) — though this is not generally the default, and may cause problems if the input rotors change sign when the corresponding rotations are not so different (cf. unflip).\n\nRotorF16, RotorF32 and RotorF64 are aliases for Rotor{Float16}, Rotor{Float32} and Rotor{Float64} respectively.  See also Quaternion and QuatVec.\n\nThe functions\n\nRotor(w, x, y, z)\nRotor(x, y, z)\nRotor(w)\nRotor{T}(w, x, y, z)\n\ncreate a new rotor with the given components (where the components are as described in Quaternion), automatically normalizing them on input. If you would like to bypass this normalization step, you can call\n\nRotor{T}(v)\n\nwhere v<:AbstractArray, and can be converted to an SVector{4, T}.\n\nHowever, once a Rotor is created, its norm will always be assumed to be precisely 1.  So if its true norm is significantly different, you will like see weird results — including vectors with very different lengths after \"rotation\" by a non-unit Rotor.\n\nNote that simply creating a Quaternion that happens to have norm 1 does not make it a Rotor.  However, you can pass such a Quaternion to the Rotor function and get the desired result.\n\nExamples\n\njulia> Rotor(1, 2, 3, 4)\n0.18257418583505536 + 0.3651483716701107𝐢 + 0.5477225575051661𝐣 + 0.7302967433402214𝐤\njulia> Rotor(Quaternion(1, 2, 3, 4))\n0.18257418583505536 + 0.3651483716701107𝐢 + 0.5477225575051661𝐣 + 0.7302967433402214𝐤\njulia> Rotor{Float16}(1, 2, 3, 4)\n0.1826 + 0.3652𝐢 + 0.548𝐣 + 0.7305𝐤\njulia> Rotor(2, 3, 4)\n0.0 + 0.3713906763541037𝐢 + 0.5570860145311556𝐣 + 0.7427813527082074𝐤\njulia> Rotor(1)\n1 + 0𝐢 + 0𝐣 + 0𝐤\n\n\n\n\n\n","category":"type"},{"location":"manual/#Quaternionic.imx","page":"Manual","title":"Quaternionic.imx","text":"imx\n\nThe quaternionic unit associated with rotation about the x axis.  Can also be entered as Unicode bold: 𝐢.\n\nExamples\n\njulia> imx * imx\n-1 + 0𝐢 + 0𝐣 + 0𝐤\njulia> 1.2imx\n0.0 + 1.2𝐢 + 0.0𝐣 + 0.0𝐤\n\n\n\n\n\n","category":"constant"},{"location":"manual/#Quaternionic.imy","page":"Manual","title":"Quaternionic.imy","text":"imy\n\nThe quaternionic unit associated with rotation about the y axis.  Can also be entered as Unicode bold: 𝐣.\n\nExamples\n\njulia> imy * imy\n-1 + 0𝐢 + 0𝐣 + 0𝐤\njulia> 1.2imy\n0.0 + 0.0𝐢 + 1.2𝐣 + 0.0𝐤\n\n\n\n\n\n","category":"constant"},{"location":"manual/#Quaternionic.imz","page":"Manual","title":"Quaternionic.imz","text":"imz\n\nThe quaternionic unit associated with rotation about the z axis.  Can also be entered as Unicode bold: 𝐤.\n\nExamples\n\njulia> imz * imz\n-1 + 0𝐢 + 0𝐣 + 0𝐤\njulia> 1.2imz\n0.0 + 0.0𝐢 + 0.0𝐣 + 1.2𝐤\n\n\n\n\n\n","category":"constant"},{"location":"manual/#Number-functions-from-Base","page":"Manual","title":"Number functions from Base","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"The standard Number functions that work for Complex, such as isfinite, iszero, etc., should work analogously for Quaternion.  The hash, read, and write functions are also implemented.  As noted in the Examples, broadcasting to each component is also implemented via broadcasted.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Modules = [Quaternionic]\nPages   = [\"base.jl\"]","category":"page"},{"location":"manual/#Algebra-and-mathematical-functions","page":"Manual","title":"Algebra and mathematical functions","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"Along with the basic binary operators, the essential mathematical functions like conj, abs, abs2, exp, log, etc., are implemented.  Most of these functions are found in the Base module, and are simply overloaded methods of functions that should also be familiar from Complex types.  Note that we use a slightly different interpretation of angle for Quaternion, compared to Complex.  We also have absvec and abs2vec, which are not useful in a Complex context, but compute the relevant quantities for the \"vector\" component of a Quaternion.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Modules = [Quaternionic]\nPages   = [\"algebra.jl\", \"math.jl\"]","category":"page"},{"location":"manual/#Base.conj-Tuple{Q} where Q<:AbstractQuaternion","page":"Manual","title":"Base.conj","text":"conj(q)\n\nReturn the quaternion conjugate, which flips the sign of each \"vector\" component.\n\nExamples\n\njulia> conj(Quaternion(1,2,3,4))\n1 - 2𝐢 - 3𝐣 - 4𝐤\n\n\n\n\n\n","category":"method"},{"location":"manual/#Quaternionic.:⋅-Union{Tuple{Q}, Tuple{P}, Tuple{P, P}} where {P<:AbstractQuaternion, Q<:AbstractQuaternion}","page":"Manual","title":"Quaternionic.:⋅","text":"p ⋅ q\n\nEvaluate the inner (\"dot\") product between two quaternions.  Equal to the scalar part of p * conj(q).\n\nNote that this function is not very commonly used, except as a quick way to determine whether the two quaternions are more anti-parallel than parallel, for functions like unflip.\n\n\n\n\n\n","category":"method"},{"location":"manual/#Base.abs-Tuple{AbstractQuaternion}","page":"Manual","title":"Base.abs","text":"abs(q)\n\nSquare-root of the sum the squares of the components of the quaternion\n\nExamples\n\njulia> abs(Quaternion(1,2,4,10))\n11.0\n\n\n\n\n\n","category":"method"},{"location":"manual/#Base.abs2-Tuple{AbstractQuaternion}","page":"Manual","title":"Base.abs2","text":"abs2(q)\n\nSum the squares of the components of the quaternion\n\nExamples\n\njulia> abs2(Quaternion(1,2,4,10))\n121\n\n\n\n\n\n","category":"method"},{"location":"manual/#Base.angle-Union{Tuple{Quaternion{T}}, Tuple{T}} where T","page":"Manual","title":"Base.angle","text":"angle(q)\n\nPhase angle in radians of the rotation represented by this quaternion.\n\nNote that this may be different from your interpretation of the angle of a complex number in an important way.  Because quaternions act on vectors by conjugation — as in q*v*conj(q) — there are two copies of q involved in that expression; in some sense, a quaternion acts \"twice\".  Therefore, this angle may be twice what you expect from an analogy with complex numbers — dpending on how you interpret the correspondence between complex numbers and quaternions.  Also, while rotations in the complex plane have a natural choice of axis (the positive z direction), that is not the case for quaternions, which means that the sign of this angle is arbitrary, and we always choose it to be positive.\n\nExamples\n\njulia> θ=1.2;\n\njulia> R=exp(θ * imz / 2);\n\njulia> angle(R)\n1.2\n\n\n\n\n\n\n","category":"method"},{"location":"manual/#Base.exp-Union{Tuple{Quaternion{T}}, Tuple{T}} where T","page":"Manual","title":"Base.exp","text":"exp(q)\n\nExponential of a quaternion\n\nExamples\n\njulia> exp(imx*π/4)  # Rotation through π/2 (note the extra 1/2) about the x axis\n0.7071067811865476 + 0.7071067811865475𝐢 + 0.0𝐣 + 0.0𝐤\n\n\n\n\n\n","category":"method"},{"location":"manual/#Base.log-Union{Tuple{Quaternion{T}}, Tuple{T}} where T","page":"Manual","title":"Base.log","text":"log(q)\n\nLogarithm of a quaternion.\n\nAs with the usual complex logarithm, the quaternion logarithm has multiple branches, though the quaternion branches are three-dimensional: for any unit \"vector\" quaternion q̂, you could add any integer multiple of 2πq̂ to the result of this function and still get the same result after exponentiating (within numerical accuracy).  This function is the principal logarithm.\n\nThis function has discontinuous (and fairly arbitrary) behavior along the negative real axis: if the \"vector\" components of the quaternion are precisely zero and the scalar component is negative, the returned quaternion will have scalar component log(-q.w), but will also have a z component of π.  The choice of the z direction is arbitrary; the \"vector\" component of the returned quaternion could be π times any unit vector.\n\nNote that this function is not specialized to unit-quaternion inputs, so the scalar component of the returned value will be nonzero unless the input has precisely unit magnitude.\n\nExamples\n\njulia> log(exp(1.2imy))\n0.0 + 0.0𝐢 + 1.2𝐣 + 0.0𝐤\n\njulia> log(Quaternion(exp(7)))\n7.0 + 0.0𝐢 + 0.0𝐣 + 0.0𝐤\n\njulia> log(Quaternion(-exp(7)))\n7.0 + 0.0𝐢 + 0.0𝐣 + 3.141592653589793𝐤\n\n\n\n\n\n","category":"method"},{"location":"manual/#Base.sqrt-Union{Tuple{Quaternion{T}}, Tuple{T}} where T","page":"Manual","title":"Base.sqrt","text":"sqrt(q)\n\nSquare-root of a quaternion.\n\nThe general formula whenever the denominator is nonzero is\n\nsqrtq = fracq + q sqrt2q + 2qw\n\nThis can be proven by expanding q as q.w + q.vec and multiplying the expression above by itself.\n\nWhen the denominator is zero, this function has discontinuous (and fairly arbitrary) behavior, just as with the quaternion log function.  In this case, either all components are zero — in which case the result is simply the zero quaternion — or the \"vector\" components of the quaternion are precisely zero and the scalar component is negative.  If the latter is true, the denominator above will be a pure-imaginary number.  Because the quaternions come with infinitely many elements that square to -1, it is not clear which imaginary should be used, so we arbitrarily choose to set the result proportional to the z quaternion.  The choice of the z direction is arbitrary; the \"vector\" component of the returned quaternion could be in any direction.\n\nExamples\n\njulia> q = Quaternion(1.2, 3.4, 5.6, 7.8);\n\njulia> sqrtq = √q;\n\njulia> sqrtq^2 ≈ q\ntrue\n\njulia> √Quaternion(4)\n2.0 + 0.0𝐢 + 0.0𝐣 + 0.0𝐤\n\njulia> √Quaternion(-4)\n0.0 + 0.0𝐢 + 0.0𝐣 + 2.0𝐤\n\n\n\n\n\n","category":"method"},{"location":"manual/#Quaternionic.abs2vec-Tuple{AbstractQuaternion}","page":"Manual","title":"Quaternionic.abs2vec","text":"abs2vec(q)\n\nSum the squares of the \"vector\" components of the quaternion\n\nExamples\n\njulia> abs2vec(Quaternion(1,2,3,6))\n49\n\n\n\n\n\n","category":"method"},{"location":"manual/#Quaternionic.absvec-Tuple{AbstractQuaternion}","page":"Manual","title":"Quaternionic.absvec","text":"absvec(q)\n\nSquare-root of the sum of the squares of the \"vector\" components of the quaternion\n\nExamples\n\njulia> absvec(Quaternion(1,2,3,6))\n7.0\n\n\n\n\n\n","category":"method"},{"location":"manual/#Random-quaternions","page":"Manual","title":"Random quaternions","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"It is frequently convenient to construct random Quaternion objects, which can be done just as with other types by passing the desired output type to the randn function.  The rand function is not overloaded, because there would be no geometric significance to such a Quaternion; randn results are independent of the orientation of the basis used to define the quaternions. Note that it is possible to get random rotors and vectors by passing the appropriate tyepes to the randn function.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Modules = [Quaternionic]\nPages   = [\"random.jl\"]","category":"page"},{"location":"manual/#Base.randn-Union{Tuple{T}, Tuple{Random.AbstractRNG, Type{var\"#s11\"} where var\"#s11\"<:AbstractQuaternion{T}}} where T<:AbstractFloat","page":"Manual","title":"Base.randn","text":"randn([rng=GLOBAL_RNG], T=Quaternion{Float64}, [dims...])\n\nGenerate a normally distributed random quaternion of type T with mean 0 and standard deviation of norm 1.  Optionally generate an array of such quaternions.  This module currently provides an implementation for the types QuaternionF16, QuaternionF32, and QuaternionF64 (the default).  The values are drawn from the spherically symmetric quaternionic normal distribution of variance 1 (corresponding to each component having independent normal distribution with mean zero and variance 1/4).\n\nNote that this function works with Quaternion{BigFloat}, even though Base.randn does not work with BigFloat; we just use the Box-Muller transform to obtain the desired result.\n\nIf the quaternion type passed in is Rotor, the result will be normalized correctly. Because the distribution is spherically symmetric, the result is a truly random rotation.\n\nIf the quaternion type is QuatVec, the result will have a 0 scalar component, and the vector will have mean 0 standard deviation of norm 1.\n\nExamples\n\njulia> randn(QuaternionF64)\n0.4336736009756228 - 0.45087190792840853𝐢 - 0.24723937675211696𝐣 - 0.4514571469326208𝐤\njulia> randn(QuaternionF16, 2, 2)\n2×2 Matrix{QuaternionF16}:\n   0.4321 + 1.105𝐢 + 0.2664𝐣 - 0.1359𝐤   0.064 + 0.9263𝐢 - 0.4138𝐣 + 0.05505𝐤\n 0.2512 - 0.2585𝐢 - 0.2803𝐣 - 0.00964𝐤  -0.1256 + 0.1848𝐢 + 0.03607𝐣 - 0.752𝐤\n\n\n\n\n\n","category":"method"},{"location":"manual/#Conversions","page":"Manual","title":"Conversions","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"It can sometimes be useful to convert between quaternions and other representations.  Most of these functions are named to_<representation> and have a corresponding from_<representation> function.  Furthermore, most convert to/from representations of rotations.  While rotations are not the only useful application of quaternions, they are probably the most common.  The only conversions that are not specifically related to rotations are to_float_array and from_float_array.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Modules = [Quaternionic]\nPages   = [\"conversion.jl\"]","category":"page"},{"location":"manual/#Quaternionic.from_euler_angles-Tuple{Any, Any, Any}","page":"Manual","title":"Quaternionic.from_euler_angles","text":"from_euler_angles(α, β, γ)\n\nCome over from the dark side.\n\nAssumes the Euler angles correspond to the quaternion R via\n\nR = exp(α𝐤/2) * exp(β𝐣/2) * exp(γ𝐤/2)\n\nwhere 𝐣 and 𝐤 rotate about the fixed y and z axes, respectively, so this reprents an initial rotation (in the positive sense) through an angle γ about the axis z, followed by a rotation through β about the axis y, and a final rotation through α about the axis z.  This is equivalent to performing an initial rotation through α about the axis z, followed by a rotation through β about the rotated axis y, followed by a rotation through γ about the twice-rotated axis z. The angles are naturally assumed to be in radians.\n\nNOTE: Before opening an issue reporting something \"wrong\" with this function, be sure to read all of this page, especially the very last section about opening issues or pull requests.\n\nSee Also\n\nto_euler_angles: Convert quaternion to Euler angles\nto_euler_phases: Convert quaternion to Euler phases\nfrom_euler_phases: Create quaternion from Euler phases\n\n\n\n\n\n","category":"method"},{"location":"manual/#Quaternionic.from_euler_phases-Tuple{Any, Any, Any}","page":"Manual","title":"Quaternionic.from_euler_phases","text":"from_euler_phases(zₐ, zᵦ, zᵧ)\nfrom_euler_phases(z)\n\nReturn the quaternion corresponding to these Euler phases.\n\nInterpreting the input quaternion as a rotation (though its normalization scales out), we can define the complex Euler phases from the Euler angles (α, β, γ) as\n\nzₐ ≔ exp(i*α)\nzᵦ ≔ exp(i*β)\nzᵧ ≔ exp(i*γ)\n\nThese are more useful geometric quantites than the angles themselves — being involved in computing spherical harmonics and Wigner's 𝔇 matrices — and can be computed from the components of the corresponding quaternion algebraically (without the use of transcendental functions).\n\nParameters\n\nz::Vector{Complex{T}}: complex vector of length 3, representing the complex phases (zₐ, zᵦ, zᵧ) in that order.\n\nReturns\n\nR::Quaternion{T}\n\nSee Also\n\nto_euler_phases: Convert quaternion to Euler phases\nto_euler_angles: Convert quaternion to Euler angles\nfrom_euler_angles: Create quaternion from Euler angles\n\n\n\n\n\n","category":"method"},{"location":"manual/#Quaternionic.from_float_array-Union{Tuple{AbstractArray{T, N} where N}, Tuple{T}} where T<:Real","page":"Manual","title":"Quaternionic.from_float_array","text":"from_float_array(A)\n\nReinterpret a real array as an array of quaternions\n\nThe input array must have an initial dimension whose size is 4, because successive indices in that dimension will be considered successive components of the output quaternion.\n\nNote that this returns a view of the original data [via reinterpret(reshape,...)] only if the base type of the input array isbitstype; otherwise, a new array of Quaternions must be created, and the memory copied.\n\nSee also to_float_array.\n\n\n\n\n\n","category":"method"},{"location":"manual/#Quaternionic.from_rotation_matrix-Tuple{Any}","page":"Manual","title":"Quaternionic.from_rotation_matrix","text":"from_rotation_matrix(ℛ)\n\nConvert 3x3 rotation matrix to quaternion.\n\nAssuming the 3x3 matrix ℛ rotates a vector v according to\n\nv' = ℛ * v,\n\nwe can also express this rotation in terms of a quaternion R such that\n\nv' = R * v * R⁻¹.\n\nThis function returns that quaternion, using Bar-Itzhack's algorithm to allow for non-orthogonal matrices.  J. Guidance, Vol. 23, No. 6, p. 1085\n\n\n\n\n\n","category":"method"},{"location":"manual/#Quaternionic.from_spherical_coordinates-Tuple{Any, Any}","page":"Manual","title":"Quaternionic.from_spherical_coordinates","text":"from_spherical_coordinates(θ, ϕ)\n\nReturn a rotor corresponding to these spherical coordinates.\n\nConsidering (θ, ϕ) as a point n on the sphere, we can also construct a quaternion that rotates the z axis onto that point.  Here, we use the standard commonly used in physics: θ represents the \"polar angle\" between the z axis and the direction n, while ϕ represents the \"azimuthal angle\" between the x axis and the projection of n into the x-y plane. Both angles must be given in radians.\n\n\n\n\n\n","category":"method"},{"location":"manual/#Quaternionic.to_euler_angles-Tuple{AbstractQuaternion}","page":"Manual","title":"Quaternionic.to_euler_angles","text":"to_euler_angles(R)\n\nOpen Pandora's Box.\n\nIf somebody is trying to make you use Euler angles, tell them no, and walk away, and go and tell your mum.\n\nYou don't want to use Euler angles.  They are awful.  Stay away.  It's one thing to convert from Euler angles to quaternions; at least you're moving in the right direction.  But to go the other way?!  It's just not right.\n\nAssumes the Euler angles correspond to the quaternion R via\n\nR = exp(α𝐤/2) * exp(β𝐣/2) * exp(γ𝐤/2)\n\nwhere 𝐣 and 𝐤 rotate about the fixed y and z axes, respectively, so this reprents an initial rotation (in the positive sense) through an angle γ about the axis z, followed by a rotation through β about the axis y, and a final rotation through α about the axis z.  This is equivalent to performing an initial rotation through α about the axis z, followed by a rotation through β about the rotated axis y, followed by a rotation through γ about the twice-rotated axis z. The angles are naturally assumed to be in radians.\n\nNOTE: Before opening an issue reporting something \"wrong\" with this function, be sure to read all of this page, especially the very last section about opening issues or pull requests.\n\nReturns\n\nαβγ::Vector{T}\n\nRaises\n\nAllHell if you try to actually use Euler angles, when you could have been using quaternions like a sensible person.\n\nSee Also\n\nfrom_euler_angles: Create quaternion from Euler angles\nto_euler_phases: Convert quaternion to Euler phases\nfrom_euler_phases: Create quaternion from Euler phases\n\n\n\n\n\n","category":"method"},{"location":"manual/#Quaternionic.to_euler_phases-Union{Tuple{AbstractQuaternion{T}}, Tuple{T}} where T","page":"Manual","title":"Quaternionic.to_euler_phases","text":"to_euler_phases(q)\nto_euler_phases!(z, q)\n\nConvert input quaternion to complex phases of Euler angles\n\nInterpreting the input quaternion as a rotation (though its normalization scales out), we can define the complex Euler phases from the Euler angles (α, β, γ) as\n\nzₐ ≔ exp(i*α)\nzᵦ ≔ exp(i*β)\nzᵧ ≔ exp(i*γ)\n\nThese are more useful geometric quantites than the angles themselves — being involved in computing spherical harmonics and Wigner's 𝔇 matrices — and can be computed from the components of the corresponding quaternion algebraically (without the use of transcendental functions).\n\nReturns\n\nz::Vector{Complex{T}}: complex phases (zₐ, zᵦ, zᵧ) in that order.\n\nSee Also\n\nfrom_euler_phases: Create quaternion from Euler phases\nto_euler_angles: Convert quaternion to Euler angles\nfrom_euler_angles: Create quaternion from Euler angles\n\n\n\n\n\n","category":"method"},{"location":"manual/#Quaternionic.to_float_array-Union{Tuple{AbstractArray{var\"#s11\", N} where {var\"#s11\"<:AbstractQuaternion{T}, N}}, Tuple{T}} where T<:Real","page":"Manual","title":"Quaternionic.to_float_array","text":"to_float_array(A)\n\nView a quaternion array as an array of real numbers\n\nThe output array will have an extra initial dimension whose size is 4, because successive indices in that dimension correspond to successive components of the quaternion.\n\nNote that this returns a view of the original data only if the base type of the input array isbitstype; otherwise, a new array of that type must be created, and the memory copied.\n\nSee also from_float_array.\n\n\n\n\n\n","category":"method"},{"location":"manual/#Quaternionic.to_rotation_matrix-Tuple{Q} where Q<:AbstractQuaternion","page":"Manual","title":"Quaternionic.to_rotation_matrix","text":"to_rotation_matrix(q)\n\nConvert quaternion to 3x3 rotation matrix.\n\nAssuming the quaternion R rotates a vector v according to\n\nv' = R * v * R⁻¹,\n\nwe can also express this rotation in terms of a 3x3 matrix ℛ such that\n\nv' = ℛ * v.\n\nThis function returns that matrix.\n\n\n\n\n\n","category":"method"},{"location":"manual/#Quaternionic.to_spherical_coordinates-Tuple{Q} where Q<:AbstractQuaternion","page":"Manual","title":"Quaternionic.to_spherical_coordinates","text":"to_spherical_coordinates(q)\n\nReturn the spherical coordinates corresponding to this quaternion.\n\nWe can treat the quaternion as a transformation taking the z axis to some direction n.  This direction can be described in terms of spherical coordinates (θ, ϕ).  Here, we use the standard commonly used in physics: θ represents the \"polar angle\" between the z axis and the direction n, while ϕ represents the \"azimuthal angle\" between the x axis and the projection of n into the x-y plane.  Both angles are given in radians.\n\n\n\n\n\n","category":"method"},{"location":"manual/#Distances","page":"Manual","title":"Distances","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"There are several ways of measuring the \"distance\" between two quaternions: d(q_1 q_2).  Fundamentally, any comparison between two quaternions q_1 and q_2 must make use of a binary operation, for which there are two obvious choices: addition or multiplication.  For either choice, we operate on q_1 and the appropriate inverse (either additive or multiplicative) of q_2.  That is, d should be a function of either q_1 - q_2 or q_1q_2.[1]","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"[1]: For q_1q_2, we are dealing with the multiplicative group of quaternions, which does not include 0, so we will assume that no quaternion involved in such a function can be 0.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Now, we also have a number of criteria we would like any distance function to satisfy.  For any quaternions q_1 and q_2 and any unit quaternion q_3, we require","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"real-valued: d(q_1 q_2) in mathbbR\nsymmetry: d(q_1 q_2) = d(q_2 q_1)\ninvariance: d(q_3 q_1 q_3 q_2) = d(q_1 q_2) = d(q_1 q_3 q_2 q_3)\nidentity: d(q_1 q_1) = 0\npositive-definiteness: d(q_1 q_2)  0 whenever q_1  q_2","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"(Of course, it should be noted that these criteria all hold in the exact case; when using floating-point numbers, will likely be violated near edge cases.)","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"It is not hard to see that these criteria can be satisfied by any of","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"abs(q₁ - q₂)\nabs2(q₁ - q₂)\nabs(log(q₁ / q₂))\nabs2(log(q₁ / q₂)","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"If q_1 and q_2 are interpreted as rotations, we frequently don't care about their signs, and just want the smallest distance between them, for any choice of sign.  Furthermore, in the multiplicative case, the log functions will involve calculation of the log of the magnitudes of the quaternions, which should be 1.  In this case, we relax the \"positive-definiteness\" criterion to allow d(q_1 q_2) to equal zero when q_1 and q_2 are related by a nonzero scalar multiple.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"For Rotor types, the latter two multiplicative options are most relevant, while for other types the additive options are more relevant.  These are the default behaviors of the distance and distance2 functions.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Modules = [Quaternionic]\nPages   = [\"distance.jl\"]","category":"page"},{"location":"manual/#Quaternionic.distance-Tuple{AbstractQuaternion, AbstractQuaternion}","page":"Manual","title":"Quaternionic.distance","text":"distance(q₁, q₂)\ndistance2(q₁, q₂)\n\nMeasure the \"distance\" between two quaternions, or the squared distance with distance2.\n\nBy default, this function just returns the natural measure in the additive group of quaternions:\n\nabs2(q₁ - q₂)\n\nIf both arguments are Rotors, the function returns the natural measure in the rotation group, which is roughly\n\nabs2(log(q₁ / q₂))\n\nNote that for Rotors, this method is (efficiently) independent of the scaling of q₁ and q₂, including up to factors of -1, as is appropriate for the rotation group.\n\nExamples\n\njulia> distance(imx, imy)\n1.4142135623730951\njulia> distance(Rotor(imx), Rotor(imy))\n1.5707963267948966\njulia> distance(imz, -imz)\n2.0\njulia> distance(Rotor(imz), Rotor(-imz))\n0.0\n\n\n\n\n\n","category":"method"},{"location":"manual/#Interpolation","page":"Manual","title":"Interpolation","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"Component-wise interpolation of quaternions does not generally yield good results when the quaternions are interpreted as rotations.  The basic reason is that rotations correspond to unit quaternions, but component-wise interpolation does not respect this constraint.  There are two specialized functions for dealing with this problem.  The first is slerp, which is an abbreviation of \"Spherical Linear intERPolation\", and is the direct analog of standard linear interpolation of functions ℝ → ℝ.  The second is squad, which is an abbreviation of \"Spherical QUADrangle interpolation\", and is more analogous to cubic interpolation by Bézier splines. The first is relatively fast but has discontinuous first derivatives at the input points, while the second is somewhat slower but has continuous first and second derivatives.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"In both cases, it is important for extraneous sign flips to be eliminated before passing quaternions to the interpolating functions.  For this purpose, there is the unflip utility function, which can also be called automatically by passing the corresponding keywords to slerp and squad.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Modules = [Quaternionic]\nPages   = [\"interpolation.jl\"]","category":"page"},{"location":"manual/#Quaternionic.slerp-Union{Tuple{R2}, Tuple{R1}, Tuple{R1, R2, Real}} where {R1<:Union{Quaternion, Rotor}, R2<:Union{Quaternion, Rotor}}","page":"Manual","title":"Quaternionic.slerp","text":"slerp(q₁, q₂, τ; [unflip=false])\n\nSpherical linear interpolation of quaternions\n\nThe result of a \"slerp\" is given by\n\n    (q₂ / q₁)^τ * q₁\n\nWhen τ is 0, this evaluates to q₁; when τ is 1, this evaluates to q₂; for any other values the result varies between the two.\n\nNote that applying this to successive pairs of quaternions as in slerp(q₁, q₂, τₐ) and slerp(q₂, q₃, τᵦ) will be continuous, but the derivative will be discontinuous when moving from the first pair to the second.  See squad for a more continuous curve.\n\nIf unflip=true is passed as a keyword, and the input quaternions are more anti-parallel than parallel, the sign of q₂ will be flipped before the result is computed.\n\n\n\n\n\n","category":"method"},{"location":"manual/#Quaternionic.squad-Tuple{AbstractVector{var\"#s48\"} where var\"#s48\"<:Rotor, AbstractVector{var\"#s49\"} where var\"#s49\"<:Real, AbstractVector{var\"#s50\"} where var\"#s50\"<:Real}","page":"Manual","title":"Quaternionic.squad","text":"squad(Rin, tin, tout; [unflip=false], [validate=false])\n\nPerform \"Spherical QUADrangle interpolation\" on the input Rotors Rin with corresponding times tin, to the output times tout.\n\nThis is a slightly generalized version of Shoemake's \"spherical Bézier curves\", to allow for time steps of varying sizes.\n\nThe input Rin and tin must be vectors of the same length.  The output tout may be either a single real number or a vector of real numbers.  Both tin and tout are assumed to be sorted, and tout is assumed to be contained entirely within tin; no extrapolation will be done.\n\nIf unflip=true is passed as a keyword, the unflip function will be applied to Rin.\n\nIf validate=true is passed as a keyword, the time ordering of the input tin and tout will be tested to ensure that no extrapolation will be done.\n\nSee also squad_control_points.\n\n\n\n\n\n","category":"method"},{"location":"manual/#Quaternionic.squad_control_points-Tuple{AbstractVector{var\"#s10\"} where var\"#s10\"<:Rotor, AbstractVector{var\"#s9\"} where var\"#s9\"<:AbstractFloat, Int64}","page":"Manual","title":"Quaternionic.squad_control_points","text":"squad_control_points(R::AbstractVector{Rotor}, t::AbstractVector{<:AbstractFloat}, i::Int)\n\nThis is a helper function for the squad routines, returning the control points between one pair of input rotors.\n\nThe expressions for A and B (assuming all indices are valid) are\n\nbeginaligned\nA_i = R_i expleft\n  frac14\n  left\n    logleft(barR_i-1 R_iright) fract_i+1 - t_i t_i - t_i-1\n    - logleft(barR_i R_i+1right)\n  right\nright\n\nB_i = R_i+1 expleft\n  -frac14\n  left\n    logleft(barR_i+1 R_i+2right) fract_i+1 - t_i t_i+2 - t_i+1\n    - logleft(barR_i R_i+1right)\n  right\nright\nendaligned\n\nThe indices will be invalid for A[begin] and A[end], and for B[end-1] and B[end].  We can simply extend the input R values by linearly extrapolating, which results in the following simplified results:\n\nbeginaligned\nA_mathrmbegin = R_mathrmbegin \nA_mathrmend = R_mathrmend \nB_mathrmend-1 = R_mathrmend \nB_mathrmend = R_mathrmend barR_mathrmend-1 R_mathrmend \n                 = 2left(R_mathrmendcdot R_mathrmend-1right) R_mathrmend - R_mathrmend-1\nendaligned\n\n\n\n\n\n","category":"method"},{"location":"manual/#Quaternionic.unflip-Tuple{AbstractArray{var\"#s8\", N} where {var\"#s8\"<:AbstractQuaternion, N}}","page":"Manual","title":"Quaternionic.unflip","text":"unflip(q, [dim=1])\nunflip!(q, [dim=1])\n\nFlip the signs of successive quaternions along dimension dim so that they are as continuous as possible.\n\nIf q represents a series of rotations, the sign of each element is arbitrary. However, for certain purposes — such as interpolation and differentiation — the continuity of the quaternions matters, and so we want the quaternions to be as continuous as possible without changing the rotations that they represent.\n\nExamples\n\njulia> q = [imx, -imx, imx, -imx];\n\njulia> unflip(q)\n4-element Vector{QuatVec{Int64}}:\n 0 + 1𝐢 + 0𝐣 + 0𝐤\n 0 + 1𝐢 + 0𝐣 + 0𝐤\n 0 + 1𝐢 + 0𝐣 + 0𝐤\n 0 + 1𝐢 + 0𝐣 + 0𝐤\n\n\n\n\n\n","category":"method"},{"location":"#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Quaternions for Julia","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The goal of this package is to provide a simple but flexible and complete implementation of quaternions, without restricting the interpretation of quaternions to being rotations — while also providing extensive support for rotations — along with thorough testing, documentation, and integration with the rest of Julia.  Wherever possible, standard functions that work with Complex will also work with Quaternion.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"In addition to a basic Quaternion{T} type, we also have Rotor{T} and QuatVec{T} specializations, which can improve the accuracy and efficiency of certain applications.  Each of these can be defined over any T<:Real; in addition to the standard primitive types (Float64, etc.), BigFloat and Symbolics.Num are tested extensively.","category":"page"},{"location":"#Examples","page":"Introduction","title":"Examples","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"There are numerous ways to construct a Quaternion — the simplest being to just give the components:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"julia> using Quaternionic\n\njulia> q = Quaternion(1.0, 2.0, 3.0, 4.0)\n1.0 + 2.0𝐢 + 3.0𝐣 + 4.0𝐤\njulia> p = Quaternion(4, 3, 2, 1)\n4 + 3𝐢 + 2𝐣 + 1𝐤","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Each quaternion type is parametrized by the types of its components (which are promoted to be all the same type).  Any subtype of Real is allowed, and is detected automatically.  For example, q has type Quaternion{Float64}, while p has type Quaternion{Int64}.[1] The base type may be given explicitly if desired, to override the detected type:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"julia> r = Quaternion{Float64}(4, 3, 2, 1)\n4.0 + 3.0𝐢 + 2.0𝐣 + 1.0𝐤","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The various Float and Int types work well, as do BigFloat, and the Num type from Symbolics.jl. In particular, we can use symbolic expressions as components:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"julia> using Quaternionic, Symbolics\n\njulia> @variables a b c d e;\n\njulia> Quaternion(a-b, b*c, c/d, d+e)\na - b + b*c𝐢 + (c*(d^-1))𝐣 + (d + e)𝐤","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"It is also possible to construct random quaternions using randn with a Quaternion type. In analogy with the complex types, the aliases QuaternionF64, QuaternionF32, and QuaternionF16 are provided, as well as the constants imx, imy, and imz, and (for copy-paste convenience) the aliases 𝐢, 𝐣, and 𝐤 (as Unicode bold characters):","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"julia> QuaternionF64\nQuaternionF64 (alias for Quaternion{Float64})\njulia> 0.1 + 2.3imx + 4.5imz\n0.1 + 2.3𝐢 + 0.0𝐣 + 4.5𝐤\njulia> 0.1 + 2.3𝐢 + 0.0𝐣 + 4.5𝐤\n0.1 + 2.3𝐢 + 0.0𝐣 + 4.5𝐤","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"As with the complex im, the result of multiplying imx, etc., with any real number will be a quaternion with the type of the other number.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"[1]: Note that, mathematically speaking, quaternions can only be defined over a field, which necessarily cannot be an integer type (because the multiplicative inverse of an integer is not generally an integer).  Nonetheless, it is possible to define a Quaternion{<:Integer}, which should behave as expected.  However, many functions (such as exp, log, etc.)  will then return a Quaternion of some different type, just as is the case for Complex{<:Integer}.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Components of a quaternion can be accessed as fields:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"julia> q.w, q.x, q.y, q.z\n(1.0, 2.0, 3.0, 4.0)","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"You can also extract the \"vector\" component (the last three elements) as","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"julia> q.vec\n3-element Vector{Float64}:\n 2.0\n 3.0\n 4.0","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"For convenience, the scalar and vector components can also be accessed in analogy with complex numbers as","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"julia> q.re\n1.0\njulia> q.im\n3-element Vector{Float64}:\n 2.0\n 3.0\n 4.0\njulia> real(q)\n1.0\njulia> imag(q)\n3-element Vector{Float64}:\n 2.0\n 3.0\n 4.0","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"It is also possible to index an individual Quaternion just as you would an array (of length 4):","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"julia> q[1]\n1.0\njulia> q[[3, 2]]\n2-element Vector{Float64}:\n 3.0\n 2.0","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Functions may also be broadcast to each component of a Quaternion.  For example, this can be particularly helpful when simplifying Symbolics expressions:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"julia> @variables q[1:4];\n\njulia> Q = Quaternion(q...);\n\njulia> simplify.(Q * imz * conj(Q))\n0 + (2q[1]*q[3] + 2q[2]*q[4])𝐢 + (2q[3]*q[4] - (2q[1]*q[2]))𝐣 + (q[1]^2 + q[4]^2 - (q[2]^2) - (q[3]^2))𝐤","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The basic algebraic operations work as you would expect:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"julia> p + q\n5.0 + 5.0𝐢 + 5.0𝐣 + 5.0𝐤\njulia> p - q\n3.0 + 1.0𝐢 - 1.0𝐣 - 3.0𝐤\njulia> p * q\n-12.0 + 16.0𝐢 + 4.0𝐣 + 22.0𝐤\njulia> q * p  # Note the non-commutativity\n-12.0 + 6.0𝐢 + 24.0𝐣 + 12.0𝐤\njulia> q / p\n0.6666666666666666 + 0.3333333333333333𝐢 + 0.0𝐣 + 0.6666666666666666𝐤","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Essential mathematical functions familiar from complex math, such as conj, abs, abs2, log, exp, etc., are also available.","category":"page"},{"location":"#Contents","page":"Introduction","title":"Contents","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Depth = 4","category":"page"},{"location":"#Function-list","page":"Introduction","title":"Function list","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"The following list contains the public functions inside the Quaternionic module.  Note that there are also many standard math functions defined for Quaternions that live in the Base module, as noted above.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Modules = [Quaternionic]","category":"page"}]
}
