var documenterSearchIndex = {"docs":
[{"location":"functions/#Function-list","page":"All functions","title":"Function list","text":"","category":"section"},{"location":"functions/","page":"All functions","title":"All functions","text":"The following list contains the public functions inside the Quaternionic module.  Note that there are also many standard math functions defined for Quaternions that live in the Base module, as noted above.","category":"page"},{"location":"functions/","page":"All functions","title":"All functions","text":"Modules = [Quaternionic]","category":"page"},{"location":"differentiation/#Differentiating-by-quaternionic-arguments","page":"Differentiating by quaternions","title":"Differentiating by quaternionic arguments","text":"","category":"section"},{"location":"differentiation/","page":"Differentiating by quaternions","title":"Differentiating by quaternions","text":"As with complex arguments, differentiation with respect to quaternionic arguments treats the components of the quaternionic argument as independent real arguments.  These rules are implemented for this package in ChainRulesCore, which means that they should work seamlessly with any package that relies on ChainRulesCore, such as Zygote.  Derivatives can also be calculated automatically using ForwardDiff.jl","category":"page"},{"location":"differentiation/","page":"Differentiating by quaternions","title":"Differentiating by quaternions","text":"As with complex differentiation, there are numerous notions of quaternionic differentiation ‚Äî including generalizations of the holomorphic and Wirtinger derivatives, as well as left- and right-multiplicative derivatives.  The goal here is to provide the basic differentiation rules upon which these derivatives can be implemented, but not to implement those derivatives themselves. It is recommended that you carefully check how the definitions of frule and rrule translate into your specific notion of quaternionic derivatives, since getting this wrong will quietly give you wrong results.","category":"page"},{"location":"differentiation/#Simple-generalization-of-complex-differentiation","page":"Differentiating by quaternions","title":"Simple generalization of complex differentiation","text":"","category":"section"},{"location":"differentiation/","page":"Differentiating by quaternions","title":"Differentiating by quaternions","text":"The ChainRulesCore docs have this to say (and the Zygote docs essentially the same thing) about differentation with respect to complex arguments:","category":"page"},{"location":"differentiation/","page":"Differentiating by quaternions","title":"Differentiating by quaternions","text":"ChainRules follows the convention that frule applied to a function f(x + i y) = u(xy) + i v(xy) with perturbation Delta x + i Delta y returns the value andtfracpartial upartial x  Delta x + tfracpartial upartial y  Delta y + i  Bigl( tfracpartial vpartial x  Delta x + tfracpartial vpartial y  Delta y Bigr)Similarly, rrule applied to the same function returns the value and a pullback function which, when applied to the adjoint Delta u + i Delta v, returnsDelta u  tfracpartial upartial x + Delta v  tfracpartial vpartial x + i  Bigl(Delta u  tfracpartial u partial y + Delta v  tfracpartial vpartial y Bigr)If we interpret complex numbers as vectors in mathbbR^2, then frule (rrule) corresponds to multiplication with the (transposed) Jacobian of f(z), i.e. frule corresponds tobeginpmatrix\ntfracpartial upartial x  Delta x + tfracpartial upartial y  Delta y\n\ntfracpartial vpartial x  Delta x + tfracpartial vpartial y  Delta y\nendpmatrix\n=\nbeginpmatrix\ntfracpartial upartial x  tfracpartial upartial y \ntfracpartial vpartial x  tfracpartial vpartial y \nendpmatrix\nbeginpmatrix\nDelta x  Delta y\nendpmatrixand rrule corresponds tobeginpmatrix\ntfracpartial upartial x  Delta u + tfracpartial vpartial x  Delta v\n\ntfracpartial upartial y  Delta u + tfracpartial vpartial y  Delta v\nendpmatrix\n=\nbeginpmatrix\ntfracpartial upartial x  tfracpartial upartial y \ntfracpartial vpartial x  tfracpartial vpartial y \nendpmatrix^mathsfT\nbeginpmatrix\nDelta u  Delta v\nendpmatrix","category":"page"},{"location":"differentiation/","page":"Differentiating by quaternions","title":"Differentiating by quaternions","text":"We can extend that naturally for differentiation with respect to quaternionic arguments.  We start by working with Quaternion-valued functions of a single Quaternion argument, and then explain how QuatVec and Rotor relate to these rules.  Now, the statement for quaternionic differentiation analogous to the above is:","category":"page"},{"location":"differentiation/","page":"Differentiating by quaternions","title":"Differentiating by quaternions","text":"Quaternionic follows the convention that frule applied to a function","category":"page"},{"location":"differentiation/","page":"Differentiating by quaternions","title":"Differentiating by quaternions","text":"f(w + ùê¢ x + ùê£ y + ùê§ z) = s(wxyz) + ùê¢ t(wxyz) + ùê£ u(wxyz) + ùê§ v(wxyz)","category":"page"},{"location":"differentiation/","page":"Differentiating by quaternions","title":"Differentiating by quaternions","text":"with perturbation Delta w + ùê¢ Delta x + ùê£ Delta y + ùê§ Delta z returns the value and","category":"page"},{"location":"differentiation/","page":"Differentiating by quaternions","title":"Differentiating by quaternions","text":"beginaligned\nleft(\n    tfracpartial spartial w  Delta w + tfracpartial spartial x  Delta x + tfracpartial spartial y  Delta y + tfracpartial spartial z  Delta z\nright)\n+\nùê¢ left(\n    tfracpartial tpartial w  Delta w + tfracpartial tpartial x  Delta x + tfracpartial tpartial y  Delta y + tfracpartial tpartial z  Delta z\nright) \n+\nùê£ left(\n    tfracpartial upartial w  Delta w + tfracpartial upartial x  Delta x + tfracpartial upartial y  Delta y + tfracpartial upartial z  Delta z\nright)\n+\nùê§ left(\n    tfracpartial vpartial w  Delta w + tfracpartial vpartial x  Delta x + tfracpartial vpartial y  Delta y + tfracpartial vpartial z  Delta z\nright)\nendaligned","category":"page"},{"location":"differentiation/","page":"Differentiating by quaternions","title":"Differentiating by quaternions","text":"Similarly, rrule applied to the same function returns the value and a pullback function which, when applied to the adjoint Delta s + ùê¢ Delta t + ùê£ Delta u + ùê§ Delta v, returns","category":"page"},{"location":"differentiation/","page":"Differentiating by quaternions","title":"Differentiating by quaternions","text":"beginaligned\nleft(\n    Delta s  tfracpartial spartial w + Delta t  tfracpartial tpartial w + Delta u  tfracpartial upartial w + Delta v  tfracpartial vpartial w\nright)\n+\nùê¢ left(\n    Delta s  tfracpartial spartial x + Delta t  tfracpartial tpartial x + Delta u  tfracpartial upartial x + Delta v  tfracpartial vpartial x\nright) \n+\nùê£ left(\n    Delta s  tfracpartial spartial y + Delta t  tfracpartial tpartial y + Delta u  tfracpartial upartial y + Delta v  tfracpartial vpartial y\nright)\n+\nùê§ left(\n    Delta s  tfracpartial spartial z + Delta t  tfracpartial tpartial z + Delta u  tfracpartial upartial z + Delta v  tfracpartial vpartial z\nright)\nendaligned","category":"page"},{"location":"differentiation/","page":"Differentiating by quaternions","title":"Differentiating by quaternions","text":"If we interpret quaternionic numbers as vectors in mathbbR^4, then frule (respectively, rrule) corresponds to multiplication with the Jacobian (respectively, transposed Jacobian) of f(z).  That is, frule corresponds to","category":"page"},{"location":"differentiation/","page":"Differentiating by quaternions","title":"Differentiating by quaternions","text":"beginpmatrix\ntfracpartial spartial w  Delta w + tfracpartial spartial x  Delta x + tfracpartial spartial y  Delta y + tfracpartial spartial z  Delta z\n\ntfracpartial tpartial w  Delta w + tfracpartial tpartial x  Delta x + tfracpartial tpartial y  Delta y + tfracpartial tpartial z  Delta z\n\ntfracpartial upartial w  Delta w + tfracpartial upartial x  Delta x + tfracpartial upartial y  Delta y + tfracpartial upartial z  Delta z\n\ntfracpartial vpartial w  Delta w + tfracpartial vpartial x  Delta x + tfracpartial vpartial y  Delta y + tfracpartial vpartial z  Delta z\nendpmatrix\n=\nbeginpmatrix\ntfracpartial spartial w  tfracpartial spartial x  tfracpartial spartial y  tfracpartial spartial z\n\ntfracpartial tpartial w  tfracpartial tpartial x  tfracpartial tpartial y  tfracpartial tpartial z\n\ntfracpartial upartial w  tfracpartial upartial x  tfracpartial upartial y  tfracpartial upartial z\n\ntfracpartial vpartial w  tfracpartial vpartial x  tfracpartial vpartial y  tfracpartial vpartial z\nendpmatrix\nbeginpmatrix\nDelta w  Delta x  Delta y  Delta z\nendpmatrix","category":"page"},{"location":"differentiation/","page":"Differentiating by quaternions","title":"Differentiating by quaternions","text":"and rrule corresponds to","category":"page"},{"location":"differentiation/","page":"Differentiating by quaternions","title":"Differentiating by quaternions","text":"beginpmatrix\ntfracpartial spartial w  Delta s + tfracpartial tpartial w  Delta t + tfracpartial upartial w  Delta u + tfracpartial vpartial w  Delta v\n\ntfracpartial spartial x  Delta s + tfracpartial tpartial x  Delta t + tfracpartial upartial x  Delta u + tfracpartial vpartial x  Delta v\n\ntfracpartial spartial y  Delta s + tfracpartial tpartial y  Delta t + tfracpartial upartial y  Delta u + tfracpartial vpartial y  Delta v\n\ntfracpartial spartial z  Delta s + tfracpartial tpartial z  Delta t + tfracpartial upartial z  Delta u + tfracpartial vpartial z  Delta v\nendpmatrix\n=\nbeginpmatrix\ntfracpartial spartial w  tfracpartial spartial x  tfracpartial spartial y  tfracpartial spartial z\n\ntfracpartial tpartial w  tfracpartial tpartial x  tfracpartial tpartial y  tfracpartial tpartial z\n\ntfracpartial upartial w  tfracpartial upartial x  tfracpartial upartial y  tfracpartial upartial z\n\ntfracpartial vpartial w  tfracpartial vpartial x  tfracpartial vpartial y  tfracpartial vpartial z\nendpmatrix^mathsfT\nbeginpmatrix\nDelta s  Delta t  Delta u  Delta v\nendpmatrix","category":"page"},{"location":"differentiation/#Applications-to-QuatVec-and-Rotor","page":"Differentiating by quaternions","title":"Applications to QuatVec and Rotor","text":"","category":"section"},{"location":"differentiation/","page":"Differentiating by quaternions","title":"Differentiating by quaternions","text":"To understand how this works for QuatVec and Rotor inputs or outputs, we just consider that these are submanifolds of the Quaternion manifold.  The only subtlety is that ‚Äî while the tangent space to Quaternion and QuatVec are naturally identified with Quaternion and QuatVec themselves ‚Äî the tangent space of the Rotor submanifold is naturally identified with Quaternion.","category":"page"},{"location":"differentiation/","page":"Differentiating by quaternions","title":"Differentiating by quaternions","text":"Thus, for a QuatVec input, w must always be 0, which means that the tangent must always have Delta w = 0, and we always treat the output functions (stuv) as independent of w so that partial s  partial w and so on are always 0.  Similarly, for QuatVec outputs, s must always be 0, so that the tangent must always have Delta s = 0, and partial s  partial w and so on are always 0.  With these considerations in mind, it's not hard to simplify the expressions above for QuatVec inputs and outputs.","category":"page"},{"location":"differentiation/","page":"Differentiating by quaternions","title":"Differentiating by quaternions","text":"On the other hand, because the tangent space to the Rotor submanifold is naturally identified with Quaternion, while there is a natural constraint on the norms of the input and output arguments, there are no structural constraints on the tangent vectors (just that they must be orthogonal to the arguments themselves).  Thus, the expressions above for Quaternion inputs and outputs will look formally identical for Rotor inputs or outputs.","category":"page"},{"location":"differentiation/#Older-functions","page":"Differentiating by quaternions","title":"Older functions","text":"","category":"section"},{"location":"differentiation/","page":"Differentiating by quaternions","title":"Differentiating by quaternions","text":"In this vein, we also have some very explicit functions for computing \"primals\" (values) and derivatives of functions of log and exp.  These are older, and likely to be deprecated at some point in favor of ChainRulesCore-based AD. Also, because of massive simplifications that result when using the right types, these derivatives are more strict about input types than the main functions themselves.  For example, the derivatives of exp are defined only for QuatVec arguments; the derivatives of log are defined only for Rotor arguments; etc.","category":"page"},{"location":"differentiation/","page":"Differentiating by quaternions","title":"Differentiating by quaternions","text":"Modules = [Quaternionic]\nPages   = [\"gradients_exp_log.jl\"]","category":"page"},{"location":"differentiation/#Quaternionic.exp‚àÇexp-Tuple{QuatVec}","page":"Differentiating by quaternions","title":"Quaternionic.exp‚àÇexp","text":"exp‚àÇexp(Z::QuatVec)\n\nReturn the value and gradient of exp(Z) with respect to the components of Z.\n\nSee ‚àÇexp for more explanation of the components of the gradient.\n\nExamples\n\njulia> e, ‚àÇe = exp‚àÇexp(randn(QuatVecF64));\n\n\n\n\n\n\n","category":"method"},{"location":"differentiation/#Quaternionic.log‚àÇlog-Tuple{Rotor}","page":"Differentiating by quaternions","title":"Quaternionic.log‚àÇlog","text":"log‚àÇlog(Z::Rotor)\n\nReturn the value and gradient of log(Z) with respect to the components of Z.\n\nSee ‚àÇlog for more explanation of the components of the gradient.\n\nExamples\n\njulia> l, ‚àÇl = log‚àÇlog(randn(RotorF64));\n\n\n\n\n\n\n","category":"method"},{"location":"differentiation/#Quaternionic.‚àÇexp-Tuple{QuatVec}","page":"Differentiating by quaternions","title":"Quaternionic.‚àÇexp","text":"‚àÇexp(Z::QuatVec)\n\nReturn the gradient of exp(Z) with respect to the components of Z.\n\nThe result includes \"off-shell\" components of the gradient, meaning that even though a scalar component of Z would not be allowed for a QuatVec, we measure the gradient in that direction anyway.  That is, the first element of the returned vector of quaternions is\n\nbeginaligned\n  leftfracpartial partial Z_w exp(Z) right_Z_w=0\nendaligned\n\nNote that, even though exp(::QuatVec) is a Rotor, the derivative (and therefore each element of the result) is a general Quaternion.\n\nSee also ‚àÇlog for a similar function, as well as exp‚àÇexp for a function to compute the value along with the gradient.\n\nExamples\n\njulia> ‚àÇexp‚àÇw, ‚àÇexp‚àÇx, ‚àÇexp‚àÇy, ‚àÇexp‚àÇz = ‚àÇexp(randn(QuatVecF64));\n\n\n\n\n\n\n","category":"method"},{"location":"differentiation/#Quaternionic.‚àÇlog-Tuple{Rotor}","page":"Differentiating by quaternions","title":"Quaternionic.‚àÇlog","text":"‚àÇlog(Z::Rotor)\n\nReturn the gradient of log(Z) with respect to the components of Z.\n\nThe result includes \"off-shell\" components of the gradient, meaning that even though change of Z in a direction that changes its norm would not be allowed for a Rotor, we measure the gradient in that direction anyway.  That is, the elements of the returned vector of quaternions is\n\nbeginaligned\n  left\n    fracpartial partial Z_w log(Z)\n    fracpartial partial Z_x log(Z)\n    fracpartial partial Z_y log(Z)\n    fracpartial partial Z_z log(Z)\n  right\nendaligned\n\nNote that, even though log(::Rotor) is a QuatVec, the derivative (and therefore each element of the result) is a general Quaternion.\n\nSee also ‚àÇexp for a similar function, as well as log‚àÇlog for a function to compute the value along with the gradient.\n\nExamples\n\njulia> ‚àÇlog‚àÇw, ‚àÇlog‚àÇx, ‚àÇlog‚àÇy, ‚àÇlog‚àÇz = ‚àÇlog(randn(QuatVecF64));\n\n\n\n\n\n\n","category":"method"},{"location":"functions_of_time/#Functions-of-time","page":"Functions of time","title":"Functions of time","text":"","category":"section"},{"location":"functions_of_time/","page":"Functions of time","title":"Functions of time","text":"When using quaternions to represent rotations and orientations, we frequently model dynamical systems, which means that the quaternions must be regarded as functions of time.  The preceding functions can all be applied at each instant of time, but we also need to be deal with the change of quaternions over time, for which there are several important techniques:","category":"page"},{"location":"functions_of_time/","page":"Functions of time","title":"Functions of time","text":"Interpolation ‚Äî Taking discretely sampled quaternionic time series and interpolating to different samples, and possibly differentiating.\nAngular velocity ‚Äî Both differentiation of a quaternionic function of time to get angular velocity, and integration of angular velocity to get an orientation as a function of time.\nMinimal rotation ‚Äî Finding the least dynamical motion that can achieve pointing in a certain direction.\nDifferentiating by quaternionic arguments ‚Äî Thanks to the chain rule, differentiating many nontrivial quaternionic functions of time will also involve differentiating with respect to components of quaternionic arguments.","category":"page"},{"location":"functions_of_time/#Interpolation","page":"Functions of time","title":"Interpolation","text":"","category":"section"},{"location":"functions_of_time/","page":"Functions of time","title":"Functions of time","text":"Component-wise interpolation of quaternions does not generally yield good results when the quaternions are interpreted as rotations.  The basic reason is that rotations correspond to unit quaternions, but component-wise interpolation does not respect this constraint.  There are two specialized functions for dealing with this problem.  The first is slerp, which is an abbreviation of \"Spherical Linear intERPolation\", and is the direct analog of standard linear interpolation of functions ‚Ñù ‚Üí ‚Ñù.  The second is squad, which is an abbreviation of \"Spherical QUADrangle interpolation\", and is more analogous to cubic interpolation by B√©zier splines. The first is relatively fast but has discontinuous first derivatives at the input points, while the second is somewhat slower but has continuous first and second derivatives.","category":"page"},{"location":"functions_of_time/","page":"Functions of time","title":"Functions of time","text":"In both cases, it is important for extraneous sign flips to be eliminated before passing quaternions to the interpolating functions.  For this purpose, there is the unflip utility function, which can also be called automatically by passing the corresponding keywords to slerp and squad.","category":"page"},{"location":"functions_of_time/","page":"Functions of time","title":"Functions of time","text":"It can be very useful to compute the derivative of various functions with respect to their arguments ‚Äî for example, when computing angular velocity of a squad interpolant.[1]  See Differentiating by quaternionic arguments for more details.  The value and derivative of slerp can be simultaneously evaluated and differentiated analytically with slerp‚àÇslerp‚àÇœÑ (or automatically with ForwardDiff).  While, squad and its derivative can be evaluated with squad‚àÇsquad‚àÇt, this is a relatively low-level function; it is easier to use the relevant keyword arguments to squad.","category":"page"},{"location":"functions_of_time/","page":"Functions of time","title":"Functions of time","text":"[1]: Essentially, we treat each quaternionic argument as a series of four real arguments.  For each input argument, the output is generally a quaternion; interpreting those outputs as also being a series of four real quantities, these derivatives could also be thought of as Jacobian matrices of the relevant functions, though the actual return types are collections of Quaternion objects.","category":"page"},{"location":"functions_of_time/","page":"Functions of time","title":"Functions of time","text":"Modules = [Quaternionic]\nPages   = [\"interpolation.jl\"]","category":"page"},{"location":"functions_of_time/#Quaternionic.slerp-Union{Tuple{R2}, Tuple{R1}, Tuple{R1, R2, Real}} where {R1<:Union{Quaternion, Rotor}, R2<:Union{Quaternion, Rotor}}","page":"Functions of time","title":"Quaternionic.slerp","text":"slerp(q‚ÇÅ, q‚ÇÇ, œÑ; [unflip=false])\n\n\"Spherical Linear intERPolation\" of a pair of quaternions.\n\nThe result of a \"slerp\" is given by\n\n    (q‚ÇÇ / q‚ÇÅ)^œÑ * q‚ÇÅ\n\nWhen œÑ is 0, this evaluates to q‚ÇÅ; when œÑ is 1, this evaluates to q‚ÇÇ; for any other values the result varies between the two.\n\nNote that applying this to successive pairs of quaternions as in slerp(q‚ÇÅ, q‚ÇÇ, œÑ‚Çê) and slerp(q‚ÇÇ, q‚ÇÉ, œÑ·µ¶) will be continuous, but the derivative will be discontinuous when moving from the first pair to the second.  See squad for a more continuous curve.\n\nIf unflip=true is passed as a keyword, and the input quaternions are more anti-parallel than parallel, the sign of q‚ÇÇ will be flipped before the result is computed.\n\nSee also slerp‚àÇslerp‚àÇœÑ, to simultaneously evaluate this function and its derivative with respect to œÑ, or slerp‚àÇslerp to evaluate this function and its derivative with respect to each parameter of the input.\n\n\n\n\n\n","category":"method"},{"location":"functions_of_time/#Quaternionic.slerp‚àÇslerp-Tuple{Rotor, Rotor, Real}","page":"Functions of time","title":"Quaternionic.slerp‚àÇslerp","text":"slerp‚àÇslerp(q‚ÇÅ, q‚ÇÇ, œÑ)\n\nReturn the value and gradient of slerp.\n\nThe gradient is with respect to each of the input arguments in turn, with each quaternion regarded as a series of four arguments.  That is, a total of 10 quaternions will be returned:\n\nbeginaligned\n  big\n    quad mathrmslerp(q‚ÇÅ q‚ÇÇ œÑ) \n    quad fracpartialpartial q‚ÇÅw mathrmslerp(q‚ÇÅ q‚ÇÇ œÑ) \n    quad fracpartialpartial q‚ÇÅx mathrmslerp(q‚ÇÅ q‚ÇÇ œÑ) \n    quad fracpartialpartial q‚ÇÅy mathrmslerp(q‚ÇÅ q‚ÇÇ œÑ) \n    quad fracpartialpartial q‚ÇÅz mathrmslerp(q‚ÇÅ q‚ÇÇ œÑ) \n    quad fracpartialpartial q‚ÇÇw mathrmslerp(q‚ÇÅ q‚ÇÇ œÑ) \n    quad fracpartialpartial q‚ÇÇx mathrmslerp(q‚ÇÅ q‚ÇÇ œÑ) \n    quad fracpartialpartial q‚ÇÇy mathrmslerp(q‚ÇÅ q‚ÇÇ œÑ) \n    quad fracpartialpartial q‚ÇÇz mathrmslerp(q‚ÇÅ q‚ÇÇ œÑ) \n    quad fracpartialpartial tau mathrmslerp(q‚ÇÅ q‚ÇÇ œÑ) \n  big\nendaligned\n\nFor convenience, this will be a 4-tuple with the slerp as the first element, the first four components of the derivative, followed by the next four components of the derivative, followed by the last component of the derivative.\n\nSee also slerp for just the value, and slerp‚àÇslerp‚àÇœÑ for just the value and the derivative with respect to œÑ.\n\nExamples\n\njulia> (q1, q2), œÑ = randn(RotorF64, 2), rand();\n\njulia> s, ‚àÇs‚àÇq‚ÇÅ, ‚àÇs‚àÇq‚ÇÇ, ‚àÇs‚àÇœÑ = slerp‚àÇslerp(q‚ÇÅ, q‚ÇÇ, œÑ);\n\n\n\n\n\n\n","category":"method"},{"location":"functions_of_time/#Quaternionic.slerp‚àÇslerp‚àÇœÑ-Tuple{Rotor, Rotor, Real}","page":"Functions of time","title":"Quaternionic.slerp‚àÇslerp‚àÇœÑ","text":"slerp‚àÇslerp‚àÇœÑ(q‚ÇÅ, q‚ÇÇ, œÑ)\n\nReturn the value and time-derivative of slerp.\n\nSee also slerp‚àÇslerp, which returns the value and all of the derivatives of slerp.\n\n\n\n\n\n","category":"method"},{"location":"functions_of_time/#Quaternionic.squad!-Tuple{AbstractVector{<:Rotor}, Union{Nothing, AbstractVector{<:QuatVec}}, Union{Nothing, AbstractVector{<:Quaternion}}, AbstractVector{<:Rotor}, AbstractVector{<:Real}, AbstractVector{<:Real}}","page":"Functions of time","title":"Quaternionic.squad!","text":"squad!(Rout, Œ©‚Éóout, RÃáout, Rin, tin, tout; [unflip=false], [validate=false])\nsquad!(Rout, Rin, tin, tout; [unflip=false], [validate=false])\n\nIn-place evaluation of \"Spherical QUADrangular interpolation\".  Note that this is intended mostly as a utility function; the squad is more user-friendly.  However, for efficiency, this function may be preferable.\n\nThe first three arrays will be modified in place, and must have the same length as tout.  Their elements must be Rotor, QuatVec, and Quaternion, respectively.  Optionally, either or both of Œ©‚Éóout and RÃáout maybe nothing, in which case they will not be computed.\n\nSee also squad.\n\n\n\n\n\n","category":"method"},{"location":"functions_of_time/#Quaternionic.squad-Union{Tuple{T}, Tuple{AbstractArray{Rotor{T}, 1}, AbstractVector{<:Real}, AbstractVector{<:Real}}} where T","page":"Functions of time","title":"Quaternionic.squad","text":"squad(Rin, tin, tout; [kwargs...])\n\n\"Spherical QUADrangle interpolation\" of the input Rotors Rin with corresponding times tin, to the output times tout.\n\nThis is a slightly generalized version of Shoemake's \"spherical B√©zier curves\", to allow for time steps of varying sizes.\n\nThe input Rin and tin must be vectors of the same length.  The output tout may be either a single real number or a vector of real numbers.  Both tin and tout are assumed to be sorted, and tout is assumed to be contained entirely within tin; no extrapolation will be done.\n\nSee also squad! for in-place versions of this function.\n\nKeyword arguments\n\nIf unflip=true is passed as a keyword, the unflip function will be applied to Rin.\n\nIf validate=true is passed as a keyword, the time ordering of the input tin and tout will be tested to ensure that no extrapolation will be done.\n\nIf compute_angular_velocity=true is passed as a keyword, the return value will be a tuple.  The first element of the tuple will be a vector of Rotors as before, but the second element will be a vector of QuatVecs representing the angular velocity.\n\nIf compute_derivative=true is passed as a keyword, the return value will be a tuple.  The first element of the tuple will be a vector of Rotors as before, but the last element will be a vector of Quaternions representing the time-derivative of the rotors.  Note that if compute_angular_velocity=true, this tuple will have three elements.\n\n\n\n\n\n","category":"method"},{"location":"functions_of_time/#Quaternionic.squad_control_points-Tuple{AbstractVector{<:Rotor}, AbstractVector{<:AbstractFloat}, Int64}","page":"Functions of time","title":"Quaternionic.squad_control_points","text":"squad_control_points(R::AbstractVector{Rotor}, t::AbstractVector{<:AbstractFloat}, i::Int)\n\nThis is a helper function for the squad routines, returning the control points between one pair of input rotors.\n\nThe expressions for A and B (assuming all indices are valid) are\n\nbeginaligned\nA_i = R_i expleft\n  frac14\n  left\n    logleft(barR_i-1 R_iright) fract_i+1 - t_i t_i - t_i-1\n    - logleft(barR_i R_i+1right)\n  right\nright\n\nB_i = R_i+1 expleft\n  -frac14\n  left\n    logleft(barR_i+1 R_i+2right) fract_i+1 - t_i t_i+2 - t_i+1\n    - logleft(barR_i R_i+1right)\n  right\nright\nendaligned\n\nThese expressions will be invalid for A_mathrmbegin, A_mathrmend, B_mathrmend-1, and B_mathrmend, because they all involve out-of-bounds indices of R_i.  We can simply extend the input R values by linearly extrapolating, which results in the following simplified results:\n\nbeginaligned\nA_mathrmbegin = R_mathrmbegin \nA_mathrmend = R_mathrmend \nB_mathrmend-1 = R_mathrmend \nB_mathrmend = R_mathrmend barR_mathrmend-1 R_mathrmend \n                 = 2left(R_mathrmendcdot R_mathrmend-1right) R_mathrmend - R_mathrmend-1\nendaligned\n\n\n\n\n\n","category":"method"},{"location":"functions_of_time/#Quaternionic.squad‚àÇsquad‚àÇt-NTuple{7, Any}","page":"Functions of time","title":"Quaternionic.squad‚àÇsquad‚àÇt","text":"squad‚àÇsquad‚àÇt(q·µ¢, A, B, q·µ¢‚Çä‚ÇÅ, ta, tb, t)\n\nCompute the value and time-derivative of squad.\n\nThis is primarily an internal helper function, taking various parameters computed within the squad function.  This will be used to compute the derivative of squad when the angular velocity is also requested.  To actually obtain the derivative, simply pass the relevant keyword to the squad function.\n\n\n\n\n\n","category":"method"},{"location":"functions_of_time/#Quaternionic.unflip-Tuple{AbstractArray{<:AbstractQuaternion}}","page":"Functions of time","title":"Quaternionic.unflip","text":"unflip(q, [dim=1])\nunflip!(q, [dim=1])\n\nFlip the signs of successive quaternions along dimension dim so that they are as continuous as possible.\n\nIf q represents a series of rotations, the sign of each element is arbitrary. However, for certain purposes ‚Äî such as interpolation and differentiation ‚Äî the continuity of the quaternions matters, and so we want the quaternions to be as continuous as possible without changing the rotations that they represent.\n\nExamples\n\njulia> q = [imx, -imx, imx, -imx];\n\njulia> unflip(q)\n4-element Vector{QuatVec{Int64}}:\n  + 1ùê¢ + 0ùê£ + 0ùê§\n  + 1ùê¢ + 0ùê£ + 0ùê§\n  + 1ùê¢ + 0ùê£ + 0ùê§\n  + 1ùê¢ + 0ùê£ + 0ùê§\n\n\n\n\n\n","category":"method"},{"location":"functions_of_time/","page":"Functions of time","title":"Functions of time","text":"Note that gradients can also be calculated automatically using ForwardDiff.jl.[2] For example, we could compute the derivative of slerp with respect to the y component of the first input quaternion as","category":"page"},{"location":"functions_of_time/","page":"Functions of time","title":"Functions of time","text":"‚àÇslerp‚àÇq‚ÇÅy(q‚ÇÅ, q‚ÇÇ, œÑ) = ForwardDiff.derivative(œµ->slerp(q‚ÇÅ+œµ*imy, q‚ÇÇ, œÑ), 0)","category":"page"},{"location":"functions_of_time/","page":"Functions of time","title":"Functions of time","text":"This is equal to","category":"page"},{"location":"functions_of_time/","page":"Functions of time","title":"Functions of time","text":"s, ‚àÇs‚àÇt = slerp‚àÇslerp(q‚ÇÅ, q‚ÇÇ, œÑ)\n‚àÇs‚àÇt[3]","category":"page"},{"location":"functions_of_time/","page":"Functions of time","title":"Functions of time","text":"though slerp‚àÇslerp computes the value and all derivatives of slerp simultaneously, and does at least as fast as most AD systems would. Nonetheless, it is useful to know that ForwardDiff can process functions involving Quaternionic methods.","category":"page"},{"location":"functions_of_time/","page":"Functions of time","title":"Functions of time","text":"[2]: There is also support for using other AD systems via ChainRulesCore.  Those are somewhat more complicated than just using ForwardDiff, so there may be cases where the support is incomplete or incorrect.  Please open an issue (or Pull Request) if you find such cases.","category":"page"},{"location":"functions_of_time/#Angular-velocity","page":"Functions of time","title":"Angular velocity","text":"","category":"section"},{"location":"functions_of_time/","page":"Functions of time","title":"Functions of time","text":"Given a quaternionic function of time q(t), we can ‚Äî in principle ‚Äî differentiate it to find dotq(t).  This is related to the more familiar  angular velocity vecomega by the equation","category":"page"},{"location":"functions_of_time/","page":"Functions of time","title":"Functions of time","text":"vecomega = 2 dotq q^-1","category":"page"},{"location":"functions_of_time/","page":"Functions of time","title":"Functions of time","text":"While dotq(t) can certainly be useful, it \"lives\" in a four-dimensional space, which means that it takes a little more work to relate to our three-dimensional space.  On the other hand, the direction of vecomega represents the instantaneous axis of rotation in our three-dimensional space, and its magnitude describes the rate of rotation about that axis.  More importantly, many results from physics describe rotations in terms of vecomega, rather than dotq(t).  So generally, we need a way to go from q(t) to vecomega(t) ‚Äî and back.","category":"page"},{"location":"functions_of_time/","page":"Functions of time","title":"Functions of time","text":"The details of this process and some examples are discussed in full in this paper.","category":"page"},{"location":"functions_of_time/","page":"Functions of time","title":"Functions of time","text":"Taking q(t) and obtaining vecomega(t) is fairly straightforward: one simply needs to obtain dotq(t) and apply the equation above.  If q(t) is known analytically, it may be possible to compute dotq directly (as in the example from Sec. 6.2 of the paper).  But ordinarily, this is a difficult task.  For numerical functions automatic differentiation can be used to obtain a numerical result for dotq (see below).  Or, if q is discretely sampled, squad (with the relevant keyword arguments) can be used to find the derivative of the interpolant at any instant and/or the corresponding angular velocity.","category":"page"},{"location":"functions_of_time/","page":"Functions of time","title":"Functions of time","text":"Going the other way, obtaining q(t) from vecomega(t), is more delicate ‚Äî though still possible.  It requires integrating the ordinary differential equation","category":"page"},{"location":"functions_of_time/","page":"Functions of time","title":"Functions of time","text":"dotq = frac12 vecomega q","category":"page"},{"location":"functions_of_time/","page":"Functions of time","title":"Functions of time","text":"which is just a rearrangement of the equation above to solve for dotq. Standard theorems on differential equations tell us that this equation has a solution for q(t) as long as we know vecomega as a function of time (and possibly of q, but not dotq), and supply an initial value for q at some instant of time.  Note that the paper noted above found that integrating this equation without any restriction on the norm of q is generally the most accurate and efficient choice.  However, with loose integration tolerances, numerical error may result in the output q(t) having norm significantly different from 1.  In this case, to use q as a rotation, you can normalize the result, or simply apply it by \"true\" conjugation with the inverse as in","category":"page"},{"location":"functions_of_time/","page":"Functions of time","title":"Functions of time","text":"q vecv q^-1","category":"page"},{"location":"functions_of_time/","page":"Functions of time","title":"Functions of time","text":"rather than using barq in the last factor.","category":"page"},{"location":"functions_of_time/","page":"Functions of time","title":"Functions of time","text":"If DifferentialEquations.jl is available, we can solve the ODE with code like this:","category":"page"},{"location":"functions_of_time/","page":"Functions of time","title":"Functions of time","text":"using Quaternionic\nusing DifferentialEquations\n\n# Make up some simple problem to solve\nŒ©‚Éó = randn(QuatVecF64)\nœâ‚Éó(t) = Œ©‚Éó\nq‚ÇÄ = randn(RotorF64)\ntspan = (0.0, 100.0)\n\n# Construct the ODE and `ODEProblem`\nangular_velocity_ode(q, œâ‚Éó, t) = œâ‚Éó(t) * q / 2\nangular_velocity_problem = ODEProblem(angular_velocity_ode, quaternion(q‚ÇÄ), tspan, œâ‚Éó)\n\n# Now, solve it\nq = solve(angular_velocity_problem, Vern9(), abstol=1e-12, reltol=0)","category":"page"},{"location":"functions_of_time/","page":"Functions of time","title":"Functions of time","text":"Here, we have constructed a very simple œâ‚Éó function ‚Äî which can actually be integrated analytically ‚Äî but it could be any callable that returns a QuatVec (or Quaternion).  Note that the initial condition q‚ÇÄ has to be a Quaternion on input to ODEProblem because DifferentialEquations.jl tries to construct a zero element of that type, which is impossible for a Rotor. This initial condition is also used for the output type and ‚Äî as mentioned above ‚Äî numerical errors will tend to move the norm away from 1, so a Rotor would not make sense anyway.  The choices of Vern9 and abstol=1e-12 here are quite stringent, and may be overkill for many problems.  It is recommended to set reltol=0 in all cases.","category":"page"},{"location":"functions_of_time/","page":"Functions of time","title":"Functions of time","text":"The q that results from solve contains the time steps q.t at which the solution was found along with the solution values q.u at each of those time steps, but can also be used as a function of time to compute the value q(t) at an arbitrary time in tspan.  In this simple case, we can compute the exact value of, and compare it to the result of integration:","category":"page"},{"location":"functions_of_time/","page":"Functions of time","title":"Functions of time","text":"q_exact = @. exp([Œ©‚Éó] * q.t / 2) * q‚ÇÄ\nmaximum(distance.(q.u, q_exact))","category":"page"},{"location":"functions_of_time/","page":"Functions of time","title":"Functions of time","text":"Typical numbers for this maximum error are roughly 1e-14, though they increase as tspan is increased.","category":"page"},{"location":"functions_of_time/","page":"Functions of time","title":"Functions of time","text":"Also note that this simple version involves allocations at each time step.  If this is problematic, it should be easy to define in-place updating versions of œâ‚Éó and angular_velocity_ode to eliminate allocations, using vectors to hold the numbers instead of quaternions, and an expression like this for the ODE:","category":"page"},{"location":"functions_of_time/","page":"Functions of time","title":"Functions of time","text":"    dqdt[1] = (q[2]*œâ‚Éót[2] + q[3]*œâ‚Éót[3] + q[4]*œâ‚Éót[4]) / -2\n    dqdt[2] = (q[1]*œâ‚Éót[2] - q[3]*œâ‚Éót[4] + q[4]*œâ‚Éót[3]) / 2\n    dqdt[3] = (q[1]*œâ‚Éót[3] + q[2]*œâ‚Éót[4] - q[4]*œâ‚Éót[2]) / 2\n    dqdt[4] = (q[1]*œâ‚Éót[4] - q[2]*œâ‚Éót[3] + q[3]*œâ‚Éót[2]) / 2","category":"page"},{"location":"functions_of_time/","page":"Functions of time","title":"Functions of time","text":"There is a particularly useful complicated but analytic example available here:","category":"page"},{"location":"functions_of_time/","page":"Functions of time","title":"Functions of time","text":"Modules = [Quaternionic]\nPages   = [\"examples.jl\"]","category":"page"},{"location":"functions_of_time/#Quaternionic.precessing_nutating_example","page":"Functions of time","title":"Quaternionic.precessing_nutating_example","text":"precessing_nutating_example([Œ©‚Çí], [Œ©‚Çö], [Œ±], [Œ±Ãá], [ŒΩ], [R‚ÇÄ])\n\nReturn an exact quaternionic function of time representing nutating precessional orbital motion, as described in Sec. 6.2 of this paper.  This example is useful because it provides physically realistic but very complicated motion, while still being simple to code up and differentiate analytically.\n\nThe output represents the rotation of the line joining the orbiting bodies and their angular velocity.  The following are the input parameters, along with their default values and physical interpretations:\n\nŒ©‚Çí=2œÄ/1_000: The orbital frequency\nŒ©‚Çö=2œÄ/10_000: The precessional frequency\nŒ±=œÄ/8: The opening angle of the precession cone at t=0\nŒ±Ãá=2Œ±/100_000: The rate of opening of the precession cone\nŒΩ=œÄ/80: The angle of nutation\nR‚ÇÄ=exp(-3Œ±*imx/10): Overall rotation of the system\n\nThe default values are chosen to be typical of a (potentially) real precessing binary black hole system shortly before merger.\n\nThe returned objects are three functions of time: R, œâ‚Éó, and RÃá, which return the orientation as a Rotor, followed by the angular velocity as a QuatVec, and the time-derivative of R as a Quaternion.\n\nExample\n\njulia> R, œâ‚Éó, RÃá = precessing_nutating_example();\n\njulia> R(12.34)\nrotor(0.9944579779058746 + 0.09804177421238346ùê¢ - 0.0008485045352531196ùê£ + 0.03795287510453948ùê§)\njulia> œâ‚Éó(345.67)\n + 0.0004634300734286701ùê¢ - 0.0007032818419003175ùê£ + 0.006214814810035088ùê§\njulia> œµ = 1e-6; (R(œµ) - R(-œµ)) / 2œµ  # Approximate derivative at t=0\n-3.8491432263754177e-7 + (3.9080960689830135e-6)ùê¢ - (6.861695854245622e-5)ùê£ + 0.003076329202503836ùê§\njulia> RÃá(0)\n-3.849124099815341e-7 + (3.9080812828476746e-6)ùê¢ - (6.861695854245653e-5)ùê£ + 0.003076329202503835ùê§\n\n\n\n\n\n","category":"function"},{"location":"functions_of_time/","page":"Functions of time","title":"Functions of time","text":"Because this is an analytic solution, we know that R(t) and œâ‚Éó(t) output by this function are consistent with each other to within numerical accuracy.  We can check that our integration scheme agrees:","category":"page"},{"location":"functions_of_time/","page":"Functions of time","title":"Functions of time","text":"R, œâ‚Éó, ·πò = precessing_nutating_example()\nangular_velocity_ode(q, œâ‚Éó, t) = œâ‚Éó(t) * q / 2\ntspan = (0., 100_000.)\nangular_velocity_problem = ODEProblem(angular_velocity_ode, quaternion(R(tspan[1])), tspan, œâ‚Éó)\nq = solve(angular_velocity_problem, Vern9(), abstol=1e-12, reltol=0);","category":"page"},{"location":"functions_of_time/","page":"Functions of time","title":"Functions of time","text":"To check the difference between the analytic R and the integrated q.u, we evaluate","category":"page"},{"location":"functions_of_time/","page":"Functions of time","title":"Functions of time","text":"julia> maximum(distance.(R.(q.t), RotorF64.(q.u)))\n3.655365559565175e-13","category":"page"},{"location":"functions_of_time/","page":"Functions of time","title":"Functions of time","text":"The maximum error is consistent with time-stepping error, so we can have confidence that other œâ‚Éó functions would be correctly integrated also.","category":"page"},{"location":"functions_of_time/#Minimal-rotation","page":"Functions of time","title":"Minimal rotation","text":"","category":"section"},{"location":"functions_of_time/","page":"Functions of time","title":"Functions of time","text":"One common problem arises when a system must be rotated to align some axis with some direction, while the rotation of the system about that axis is irrelevant.  To be specific, suppose we want to rotate our basis vectors hatx haty hatz so that hatz points in a particular direction.  A naive approach may be to determine the direction in terms of spherical coordinates (theta phi), and then use the rotation determined by Euler angles (alpha beta gamma) = (phi theta 0).  However, as with most applications of Euler angles, this is a terrible idea.  The resulting orientation will be extremely sensitive to the direction whenever it happens to be near the poles.  In such cases, the angular velocity of the system will be very high ‚Äî potentially infinite, in principle.","category":"page"},{"location":"functions_of_time/","page":"Functions of time","title":"Functions of time","text":"A slightly better approach would be to use (alpha beta gamma) = (phi theta -phi), which is the most direct rotation from the z axis to the point given by (theta phi), and behaves better in the limit of small theta.  However, this only works for rotations directly from the z axis; the result depends on the choice of coordinates, and is not the best choice for tracking general motion of the target axis.","category":"page"},{"location":"functions_of_time/","page":"Functions of time","title":"Functions of time","text":"Fortunately, it is possible to take any rotor R_mathrmaxis(t) that aligns the axis correctly, and compute another rotation that also aligns the axis, but has the smallest possible angular velocity.  This is called the \"minimal rotation\".  The general problem is discussed (by way of a very specific physical situation) in detail in Sec. III and Appendix B of this paper.  Essentially, we solve the equation","category":"page"},{"location":"functions_of_time/","page":"Functions of time","title":"Functions of time","text":"dotgamma = 2 leftdotR_mathrmaxis ùê§ barR_mathrmaxis\nright_w","category":"page"},{"location":"functions_of_time/","page":"Functions of time","title":"Functions of time","text":"(where the subscript w just takes the scalar component) for gamma(t). We then construct the rotor","category":"page"},{"location":"functions_of_time/","page":"Functions of time","title":"Functions of time","text":"R(t) = R_mathrmaxis(t) expleftgamma(t) ùê§  2 right","category":"page"},{"location":"functions_of_time/","page":"Functions of time","title":"Functions of time","text":"This rotor also aligns the axis correctly, but otherwise has the smallest possible angular velocity.  Here, R_mathrmaxis may be constructed in any convenient way, including using spherical coordinates or even Euler angles; the resulting R(t) will be independent of such poor life choices.","category":"page"},{"location":"manual/#Quaternionic-functions","page":"Basics","title":"Quaternionic functions","text":"","category":"section"},{"location":"manual/","page":"Basics","title":"Basics","text":"From AbstractQuaternion{T} we define three subtypes:","category":"page"},{"location":"manual/","page":"Basics","title":"Basics","text":"Quaternion{T}, which is an element of the general algebra of quaternions over any T<:Real.\nRotor{T}, which is an element of the multiplicative group of unit quaternions, and is interpreted as mapping to a rotation.  The magnitude is assumed to be 1 (though, for efficiency, this is not generally confirmed), and the sign may be freely changed in certain cases.\nQuatVec{T}, which is an element of the additive group of quaternions with 0 scalar part; a \"pure vector\" quaternion.","category":"page"},{"location":"manual/","page":"Basics","title":"Basics","text":"For simplicity, almost every function in this package is defined for general Quaternions, so you may not need any other type.  However, it can frequently be more accurate and more efficient to use the other subtypes where relevant.","category":"page"},{"location":"manual/#Constructors,-constants,-and-conversions","page":"Basics","title":"Constructors, constants, and conversions","text":"","category":"section"},{"location":"manual/","page":"Basics","title":"Basics","text":"At the most basic level, Quaternion{T} mimics Complex{T} as closely as possible, including the behavior of most functions in Base.  The Rotor{T} and QuatVec{T} subtypes behave very similarly, except that most of their constructors automatically impose the constraints that the norm is 1 and the scalar component is 0, respectively.  Also note that when a certain operation is not defined for either of those subtypes, the functions will usually convert to a general Quaternion automatically.","category":"page"},{"location":"manual/","page":"Basics","title":"Basics","text":"To create new Quaternions interactively, it is typically most convenient to use the constants imx, imy, and imz ‚Äî or equivalently ùê¢, ùê£, and ùê§ ‚Äî multiplied by appropriate factors and added together.  For programmatic work, it is more common to use the Quaternion function ‚Äî which takes all four components, the three vector components, or just the one scalar component, and creates a new Quaternion of the type implied by the arguments.  You can also specify the type, as in Quaternion{Float64}(...).  Type conversions with promote, widen, float, etc., work as expected.","category":"page"},{"location":"manual/","page":"Basics","title":"Basics","text":"Modules = [Quaternionic]\nPages   = [\"quaternion.jl\"]\nOrder   = [:module, :type, :constant, :function, :macro]","category":"page"},{"location":"manual/#Quaternionic.QuatVec","page":"Basics","title":"Quaternionic.QuatVec","text":"QuatVec{T<:Number} <: Number\n\nPure-vector quaternion with elements of type T.  These objects can be significantly faster and more accurate in certain operations than general Quaternions.\n\nQuatVecF16, QuatVecF32 and QuatVecF64 are aliases for QuatVec{Float16}, QuatVec{Float32} and QuatVec{Float64} respectively.  See also Quaternion and Rotor.\n\nThe functions\n\nquatvec(w, x, y, z)\nquatvec(x, y, z)\nquatvec(w)\n\ncreate a new QuatVec with the given components (where the components are as described in Quaternion), except that the scalar argument w is always set to 0.\n\nExamples\n\njulia> quatvec(1, 2, 3, 4)\n + 2ùê¢ + 3ùê£ + 4ùê§\njulia> quatvec(quaternion(1, 2, 3, 4))\n + 2ùê¢ + 3ùê£ + 4ùê§\njulia> quatvec(2, 3, 4)\n + 2ùê¢ + 3ùê£ + 4ùê§\njulia> quatvec(1)\n + 0ùê¢ + 0ùê£ + 0ùê§\n\n\n\n\n\n","category":"type"},{"location":"manual/#Quaternionic.Quaternion","page":"Basics","title":"Quaternionic.Quaternion","text":"Quaternion{T<:Number} <: Number\n\nQuaternionic number type with elements of type T.\n\nQuaternionF16, QuaternionF32 and QuaternionF64 are aliases for Quaternion{Float16}, Quaternion{Float32} and Quaternion{Float64} respectively.  See also Rotor and QuatVec.\n\nThe functions\n\nquaternion(w, x, y, z)\nquaternion(x, y, z)\nquaternion(w)\n\ncreate a new quaternion with the given components.  The argument w is the scalar component, and x, y, and z are the corresponding \"vector\" components.  If any of these arguments is missing, it will be set to zero.  The type of the returned quaternion will be inferred from the input arguments, or can be specified, by passing the type parameter T as above.\n\nNote that the constants imx, imy, and imz can also be used like the complex im to create new Quaternion object.\n\nExamples\n\njulia> quaternion(1, 2, 3, 4)\n1 + 2ùê¢ + 3ùê£ + 4ùê§\njulia> Quaternion{Float64}(1, 2, 3, 4)\n1.0 + 2.0ùê¢ + 3.0ùê£ + 4.0ùê§\njulia> quaternion(1.0, 2.0, 3.0, 4.0)\n1.0 + 2.0ùê¢ + 3.0ùê£ + 4.0ùê§\njulia> quaternion(2, 3, 4)\n0 + 2ùê¢ + 3ùê£ + 4ùê§\njulia> quaternion(1)\n1 + 0ùê¢ + 0ùê£ + 0ùê§\n\n\n\n\n\n","category":"type"},{"location":"manual/#Quaternionic.Rotor","page":"Basics","title":"Quaternionic.Rotor","text":"Rotor{T<:Number} <: Number\n\nQuaternion of unit magnitude with elements of type T.  These objects can be significantly faster and more accurate in certain operations representing rotations.\n\nA rotor is typically considered to be an element of the group mathrmSpin(3)  mathrmSU(2), which can be thought of as the subgroup of quaternions with norm 1.  They are particularly useful as representations of rotations because a rotor R acts on a vector vecv by \"conjugation\" as\n\nvecv = R vecv R^-1\n\n(which can be represented in code as R * v / R or, more efficiently, as R(v)).  This operation preserves the inner product between any two vectors conjugated in this way, and so is a rotation.  Note that, because there are two factors of R here, the sign of R does not affect the result.  Therefore, mathrmSpin(3) forms a double cover of the rotation group mathrmSO(3).  For this reason, it will occasionally be useful to disregard or arbitrarily change the sign of a Rotor (as in distance functions) ‚Äî though this is not generally the default, and may cause problems if the input rotors change sign when the corresponding rotations are not so different (cf. unflip).\n\nRotorF16, RotorF32 and RotorF64 are aliases for Rotor{Float16}, Rotor{Float32} and Rotor{Float64} respectively.  See also Quaternion and QuatVec.\n\nThe functions\n\nrotor(w, x, y, z)\nrotor(w)\n\ncreate a new rotor with the given components (where the components are as described in Quaternion), automatically normalizing them on input.  Note that this normalization step is the key difference between the Rotor and rotor functions; if you would like to bypass normalization, you can call\n\nRotor{T}(w, x, y, z)\nRotor{T}(w)\n\nin the same way as rotor, and w, x, y, z will be converted to type T.  Alternatively, you can call\n\nRotor{T}(v)\n\nwhere v<:AbstractArray can be converted to an SVector{4, T}.  If you want to handle the normalization step, you can use normalize.\n\nHowever, once a Rotor is created, its norm will often be assumed to be precisely 1.  So if its true norm is significantly different, you will likely see weird results ‚Äî including vectors with very different lengths after \"rotation\" by a non-unit Rotor.\n\nNote that simply creating a Quaternion that happens to have norm 1 does not make it a Rotor.  However, you can pass such a Quaternion to the rotor function and get the desired result.\n\nExamples\n\njulia> rotor(1, 2, 3, 4)\nrotor(0.18257418583505536 + 0.3651483716701107ùê¢ + 0.5477225575051661ùê£ + 0.7302967433402214ùê§)\njulia> rotor(quaternion(1, 2, 3, 4))\nrotor(0.18257418583505536 + 0.3651483716701107ùê¢ + 0.5477225575051661ùê£ + 0.7302967433402214ùê§)\njulia> Rotor{Float16}(1, 2, 3, 4)\nrotor(1.0 + 2.0ùê¢ + 3.0ùê£ + 4.0ùê§)\njulia> normalize(Rotor{Float16}(1, 2, 3, 4))\nrotor(0.1826 + 0.3652ùê¢ + 0.548ùê£ + 0.7305ùê§)\njulia> rotor(1.0)\nrotor(1.0 + 0.0ùê¢ + 0.0ùê£ + 0.0ùê§)\n\n\n\n\n\n","category":"type"},{"location":"manual/#Quaternionic.imx","page":"Basics","title":"Quaternionic.imx","text":"imx\nùê¢\n\nThe quaternionic unit associated with rotation about the x axis.  Can also be entered as Unicode bold ùê¢ (which can be input as \\bfi<tab>).\n\nNote that ‚Äî just as im is a Complex{Bool} ‚Äî imx is a QuatVec{Bool}, and as soon as you multiply by a scalar of any other number type (e.g., a Float64) it will be promoted to a QuatVec of that number type, and once you add a scalar it will be promoted to a Quaternion.\n\nSee also imy and imz.\n\nExamples\n\njulia> imx * imx\n-1 + 0ùê¢ + 0ùê£ + 0ùê§\njulia> 1.2imx\n + 1.2ùê¢ + 0.0ùê£ + 0.0ùê§\njulia> 1.2 + 3.4imx\n1.2 + 3.4ùê¢ + 0.0ùê£ + 0.0ùê§\njulia> 1.2 + 3.4ùê¢\n1.2 + 3.4ùê¢ + 0.0ùê£ + 0.0ùê§\n\n\n\n\n\n","category":"constant"},{"location":"manual/#Quaternionic.imy","page":"Basics","title":"Quaternionic.imy","text":"imy\nùê£\n\nThe quaternionic unit associated with rotation about the y axis.  Can also be entered as Unicode bold ùê£ (which can be input as \\bfj<tab>).\n\nNote that ‚Äî just as im is a Complex{Bool} ‚Äî imy is a QuatVec{Bool}, and as soon as you multiply by a scalar of any other number type (e.g., a Float64) it will be promoted to a QuatVec of that number type, and once you add a scalar it will be promoted to a Quaternion.\n\nSee also imx and imz.\n\nExamples\n\njulia> imy * imy\n-1 + 0ùê¢ + 0ùê£ + 0ùê§\njulia> 1.2imy\n + 0.0ùê¢ + 1.2ùê£ + 0.0ùê§\njulia> 1.2 + 3.4imy\n1.2 + 0.0ùê¢ + 3.4ùê£ + 0.0ùê§\njulia> 1.2 + 3.4ùê£\n1.2 + 0.0ùê¢ + 3.4ùê£ + 0.0ùê§\n\n\n\n\n\n","category":"constant"},{"location":"manual/#Quaternionic.imz","page":"Basics","title":"Quaternionic.imz","text":"imz\nùê§\n\nThe quaternionic unit associated with rotation about the z axis.  Can also be entered as Unicode bold ùê§ (which can be input as \\bfk<tab>).\n\nNote that ‚Äî just as im is a Complex{Bool} ‚Äî imz is a QuatVec{Bool}, and as soon as you multiply by a scalar of any other number type (e.g., a Float64) it will be promoted to a QuatVec of that number type, and once you add a scalar it will be promoted to a Quaternion.\n\nSee also imx and imy.\n\nExamples\n\njulia> imz * imz\n-1 + 0ùê¢ + 0ùê£ + 0ùê§\njulia> 1.2imz\n + 0.0ùê¢ + 0.0ùê£ + 1.2ùê§\njulia> 1.2 + 3.4imz\n1.2 + 0.0ùê¢ + 0.0ùê£ + 3.4ùê§\njulia> 1.2 + 3.4ùê§\n1.2 + 0.0ùê¢ + 0.0ùê£ + 3.4ùê§\n\n\n\n\n\n","category":"constant"},{"location":"manual/#Number-functions-from-Base","page":"Basics","title":"Number functions from Base","text":"","category":"section"},{"location":"manual/","page":"Basics","title":"Basics","text":"The standard Number functions that work for Complex, such as isfinite, iszero, etc., should work analogously for Quaternion.  The hash, read, and write functions are also implemented.  As noted in the Examples, broadcasting to each component is also implemented via broadcasted.","category":"page"},{"location":"manual/","page":"Basics","title":"Basics","text":"Modules = [Quaternionic]\nPages   = [\"base.jl\"]","category":"page"},{"location":"manual/#Algebra-and-mathematical-functions","page":"Basics","title":"Algebra and mathematical functions","text":"","category":"section"},{"location":"manual/","page":"Basics","title":"Basics","text":"Along with the basic binary operators, the essential mathematical functions like conj, abs, abs2, exp, log, etc., are implemented.  Most of these functions are found in the Base module, and are simply overloaded methods of functions that should also be familiar from Complex types.  Note that we use a slightly different interpretation of angle for Quaternion, compared to Complex.  We also have absvec and abs2vec, which are not useful in a Complex context, but compute the relevant quantities for the \"vector\" component of a Quaternion.","category":"page"},{"location":"manual/","page":"Basics","title":"Basics","text":"Modules = [Quaternionic]\nPages   = [\"algebra.jl\", \"math.jl\"]","category":"page"},{"location":"manual/#Base.conj-Tuple{Q} where Q<:AbstractQuaternion","page":"Basics","title":"Base.conj","text":"conj(q)\n\nReturn the quaternion conjugate, which flips the sign of each \"vector\" component.\n\nExamples\n\njulia> conj(quaternion(1,2,3,4))\n1 - 2ùê¢ - 3ùê£ - 4ùê§\n\n\n\n\n\n","category":"method"},{"location":"manual/#LinearAlgebra.:‚ãÖ-Tuple{AbstractQuaternion, AbstractQuaternion}","page":"Basics","title":"LinearAlgebra.:‚ãÖ","text":"p ‚ãÖ q\n\nEvaluate the inner (\"dot\") product between two quaternions.  Equal to the scalar part of p * conj(q).\n\nNote that this function is not very commonly used, except as a quick way to determine whether the two quaternions are more anti-parallel than parallel, for functions like unflip.\n\n\n\n\n\n","category":"method"},{"location":"manual/#Quaternionic.:√ó-Tuple{QuatVec, QuatVec}","page":"Basics","title":"Quaternionic.:√ó","text":"a √ó b\n\nReturn the cross product of two pure-vector quaternions.  Equal to ¬Ω of the commutator product a*b-b*a.\n\n\n\n\n\n","category":"method"},{"location":"manual/#Quaternionic.:√óÃÇ-Tuple{QuatVec, QuatVec}","page":"Basics","title":"Quaternionic.:√óÃÇ","text":"a √óÃÇ b\n\nReturn the direction of the cross product between a and b; the normalized vector along a√ób ‚Äî unless the magnitude is zero, in which case the zero vector is returned.\n\n\n\n\n\n","category":"method"},{"location":"manual/#Quaternionic.normalize-Tuple{AbstractQuaternion}","page":"Basics","title":"Quaternionic.normalize","text":"normalize(q)\n\nReturn a copy of this quaternion, normalized.\n\nNote that this returns the same type as the input quaternion.  If you want to convert to a Rotor, just call rotor(q), which includes a normalization step.\n\n\n\n\n\n","category":"method"},{"location":"manual/#Base.abs-Tuple{AbstractQuaternion}","page":"Basics","title":"Base.abs","text":"abs(q)\n\nSquare-root of the sum the squares of the components of the quaternion\n\nThis function uses Julia's built-in hypot function to avoid overflow and underflow.\n\nExamples\n\njulia> abs(quaternion(1,2,4,10))\n11.0\n\n\n\n\n\n","category":"method"},{"location":"manual/#Base.abs2-Tuple{AbstractQuaternion}","page":"Basics","title":"Base.abs2","text":"abs2(q)\n\nSum the squares of the components of the quaternion\n\nExamples\n\njulia> abs2(quaternion(1,2,4,10))\n121\n\n\n\n\n\n","category":"method"},{"location":"manual/#Base.angle-Union{Tuple{Quaternion{T}}, Tuple{T}} where T","page":"Basics","title":"Base.angle","text":"angle(q)\n\nPhase angle in radians of the rotation represented by this quaternion.\n\nNote that this may be different from your interpretation of the angle of a complex number in an important way.  Because quaternions act on vectors by conjugation ‚Äî as in q*v*conj(q) ‚Äî there are two copies of q involved in that expression; in some sense, a quaternion acts \"twice\".  Therefore, this angle may be twice what you expect from an analogy with complex numbers ‚Äî dpending on how you interpret the correspondence between complex numbers and quaternions.  Also, while rotations in the complex plane have a natural choice of axis (the positive z direction), that is not the case for quaternions, which means that the sign of this angle is arbitrary, and we always choose it to be positive.\n\nExamples\n\njulia> Œ∏=1.2;\n\njulia> R=exp(Œ∏ * imz / 2);\n\njulia> angle(R)\n1.2\n\n\n\n\n\n\n","category":"method"},{"location":"manual/#Base.exp-Union{Tuple{Quaternion{T}}, Tuple{T}} where T","page":"Basics","title":"Base.exp","text":"exp(q)\n\nExponential of a quaternion\n\nExamples\n\njulia> exp(imx*œÄ/4)  # Rotation through œÄ/2 (note the extra 1/2) about the x axis\nrotor(0.7071067811865476 + 0.7071067811865475ùê¢ + 0.0ùê£ + 0.0ùê§)\n\n\n\n\n\n","category":"method"},{"location":"manual/#Base.log-Union{Tuple{Quaternion{T}}, Tuple{T}} where T","page":"Basics","title":"Base.log","text":"log(q)\n\nLogarithm of a quaternion.\n\nAs with the usual complex logarithm, the quaternion logarithm has multiple branches, though the quaternion branches are three-dimensional: for any unit \"vector\" quaternion qÃÇ, you could add any integer multiple of 2œÄqÃÇ to the result of this function and still get the same result after exponentiating (within numerical accuracy).  This function is the principal logarithm.\n\nThis function has discontinuous (and fairly arbitrary) behavior along the negative real axis: if the \"vector\" components of the quaternion are precisely zero and the scalar component is negative, the returned quaternion will have scalar component log(-q[1]), but will also have a z component of œÄ.  The choice of the z direction is arbitrary; the \"vector\" component of the returned quaternion could be œÄ times any unit vector.\n\nNote that q may be either a Quaternion or a Rotor.  If it is a Quaternion, this function does not assume that it has unit norm, so the scalar component of the returned value will generally be nonzero unless the input has precisely unit magnitude (which is impossible with Float64 about 52.07% of the time due to finite machine precision), and the return type is a Quaternion.  If the input is a Rotor, a QuatVec is returned, which has scalar part exactly 0.\n\nExamples\n\njulia> log(exp(1.2imy))\n + 0.0ùê¢ + 1.2ùê£ + 0.0ùê§\n\njulia> log(quaternion(exp(7)))\n7.0 + 0.0ùê¢ + 0.0ùê£ + 0.0ùê§\n\njulia> log(quaternion(-exp(7)))\n7.0 + 0.0ùê¢ + 0.0ùê£ + 3.141592653589793ùê§\n\nNotes\n\nThis function uses an accurate algorithm for finding the logarithm.  For simplicity, we will assume that the input quaternion is a unit quaternion, so that the logarithm will be a pure vector vecv, which we write as vhatv, where v is just the scalar norm. Note that, because of the periodicity of the exp function, we can assume that v in 0 pi and, in particular, sin(v) geq 0.  Now, expand the exponential as\n\nexpleft(vecvright) = expleft(v hatvright) = cos(v) + hatv sin(v)\n\nThe input to this function is the right-hand side, but we do not yet know its decomposition into v and hatv.  But we can find cos(v) as the scalar part of the input, and sin(v) as the absvec (since we know that sin(v) geq 0).  Then, we can compute v = mathrmatan(sin(v) cos(v)).  And finally, we simply multiply the vector part of the input by v  sin(v) to obtain the logarithm.  This factor is given accurately by invsinc(v) whenever v leq pi2.\n\nWhen that condition is not satisfied (which also implies cos(v)0, we can rewrite the problem as\n\nexpleft(v hatvright) = cos(v) + hatv sin(v) = -cos(v-pi) - hatv sin(v-pi)\n= -cos(v) - hatv sin(v)\n\nHere, we want to multiply the vector component by -v  sin(v) = -(v+pi)  sin(v). Note that we can easily compute v = mathrmatan(sin(v) -cos(v)).  This algorithm is surprisingly accurate, even when v is extremely close to pi, which implies that the vector part of the input is extremely small.\n\nThe only special case remaining to handle is when cos(v)  0 but sin(v) is identically zero.  In this case, we could throw an error, but this is not usually helpful. Instead, we arbitrarily choose to return pi z.\n\nFinally, we can return to our assumption that the input has unit magnitude.  In the preceding, this didn't matter because we only computed v as the ratio of the scalar part and the magnitude of the vector part, so the overall magnitude cancelled out.  So that part of the computation remains unchanged.  Instead, we note that for scalar s, we have\n\nexpleft(s + vecvright) = expleft(sright) expleft(vecvright)\n\nso the logarithm is just the sum of the logarithms of the scalar and vector parts.\n\n\n\n\n\n","category":"method"},{"location":"manual/#Base.sqrt-Tuple{T} where T<:AbstractQuaternion","page":"Basics","title":"Base.sqrt","text":"sqrt(q)\n\nSquare-root of a quaternion.\n\nThe general formula whenever the denominator is nonzero is\n\nsqrtq = fracq + q sqrt2q + 2q1\n\nThis can be proven by expanding q as q[1] + vec(q) and multiplying the expression above by itself.\n\nNote that whenever the vector part is zero and the scalar part is negative, the solution is not unique (and the denominator above is zero), because it necessarily involves the square-root of -1, of which there are infinitely many in the space of quaternions.  In this case, we arbitrarily choose the vector part of the result to be in the z direction.  A reasonable alternative would be to throw an error; instead it is left to the user to check for that condition.\n\nExamples\n\njulia> q = quaternion(1.2, 3.4, 5.6, 7.8);\n\njulia> sqrtq = ‚àöq;\n\njulia> sqrtq^2 ‚âà q\ntrue\n\njulia> ‚àöquaternion(4.0)\n2.0 + 0.0ùê¢ + 0.0ùê£ + 0.0ùê§\n\njulia> ‚àöquaternion(-4.0)\n0.0 + 0.0ùê¢ + 0.0ùê£ + 2.0ùê§\n\nNotes\n\nThis function uses an algorithm for finding the square root that is very accurate (typically achieving the correct result to within machine precision) for most values.  However, naive application of the formula above can lead to catastrophic cancellation when the scalar part is negative and significantly larger in magnitude to the vector part.  Therefore, when q[1]  < 0, we transform the problem into the case where q[1] > 0 as\n\nsqrtq = barsqrt-barq sqrt-1\n\nwhere the bar denotes quaternionic conjugation, and we interpret sqrt-1 to be a unit imaginary that commutes with q.  The obvious candidate is the normalized vector part of q if the vector part is nonzero; otherwise, as noted above, we arbitrarily choose it to be the unit vector in z direction.  The calculation of sqrt-barq can use the naive approach, and the result is still accurate to within machine precision.\n\n\n\n\n\n","category":"method"},{"location":"manual/#Quaternionic.abs2vec-Tuple{AbstractQuaternion}","page":"Basics","title":"Quaternionic.abs2vec","text":"abs2vec(q)\n\nSum the squares of the \"vector\" components of the quaternion\n\nExamples\n\njulia> abs2vec(quaternion(1,2,3,6))\n49\n\n\n\n\n\n","category":"method"},{"location":"manual/#Quaternionic.absvec-Tuple{AbstractQuaternion}","page":"Basics","title":"Quaternionic.absvec","text":"absvec(q)\n\nSquare-root of the sum of the squares of the \"vector\" components of the quaternion.\n\nThis function uses Julia's built-in hypot function to avoid overflow and underflow.\n\nExamples\n\njulia> absvec(quaternion(1,2,3,6))\n7.0\n\n\n\n\n\n","category":"method"},{"location":"manual/#Random-quaternions","page":"Basics","title":"Random quaternions","text":"","category":"section"},{"location":"manual/","page":"Basics","title":"Basics","text":"It is frequently convenient to construct random Quaternion objects, which can be done just as with other types by passing the desired output type to the randn function.  The rand function is not overloaded, because there would be no geometric significance to such a Quaternion; randn results are independent of the orientation of the basis used to define the quaternions. Note that it is possible to get random rotors and vectors by passing the appropriate types to the randn function.","category":"page"},{"location":"manual/","page":"Basics","title":"Basics","text":"Modules = [Quaternionic]\nPages   = [\"random.jl\"]","category":"page"},{"location":"manual/#Base.randn-Union{Tuple{T}, Tuple{Random.AbstractRNG, Type{<:AbstractQuaternion{T}}}} where T<:AbstractFloat","page":"Basics","title":"Base.randn","text":"randn([rng=default_rng()], T=Quaternion{Float64}, [dims...])\n\nGenerate a normally distributed random quaternion of type T with mean 0 and standard deviation of norm 1.  Optionally generate an array of such quaternions.  This module currently provides an implementation for the types QuaternionF16, QuaternionF32, and QuaternionF64 (the default).  The values are drawn from the spherically symmetric quaternionic normal distribution of variance 1 (corresponding to each component having independent normal distribution with mean zero and variance 1/4).\n\nNote that this function works with Quaternion{BigFloat}, even though Base.randn does not work with BigFloat on Julia <1.9; for earlier versions, we just use the Box-Muller transform to obtain the desired result.\n\nIf the quaternion type passed in is Rotor, the result will be normalized correctly. Because the distribution is spherically symmetric, the result is a truly random rotation.\n\nIf the quaternion type is QuatVec, the result will have a 0 scalar component, and the vector will have mean 0 standard deviation of norm 1.\n\nExamples\n\njulia> randn(QuaternionF64)\n0.4336736009756228 - 0.45087190792840853ùê¢ - 0.24723937675211696ùê£ - 0.4514571469326208ùê§\njulia> randn(QuaternionF16, 2, 2)\n2√ó2 Matrix{QuaternionF16}:\n   0.4321 + 1.105ùê¢ + 0.2664ùê£ - 0.1359ùê§   0.064 + 0.9263ùê¢ - 0.4138ùê£ + 0.05505ùê§\n 0.2512 - 0.2585ùê¢ - 0.2803ùê£ - 0.00964ùê§  -0.1256 + 0.1848ùê¢ + 0.03607ùê£ - 0.752ùê§\n\n\n\n\n\n","category":"method"},{"location":"manual/#Conversions","page":"Basics","title":"Conversions","text":"","category":"section"},{"location":"manual/","page":"Basics","title":"Basics","text":"It can sometimes be useful to convert between quaternions and other representations.  Most of these functions are named to_<representation> and have a corresponding from_<representation> function.  Furthermore, most convert to/from representations of rotations.  While rotations are not the only useful application of quaternions, they are probably the most common.  The only conversions that are not specifically related to rotations are to_float_array and from_float_array.","category":"page"},{"location":"manual/","page":"Basics","title":"Basics","text":"Modules = [Quaternionic]\nPages   = [\"conversion.jl\"]","category":"page"},{"location":"manual/#Quaternionic.from_euler_angles-Tuple{Any, Any, Any}","page":"Basics","title":"Quaternionic.from_euler_angles","text":"from_euler_angles(Œ±, Œ≤, Œ≥)\n\nCome over from the dark side.\n\nAssumes the Euler angles correspond to the quaternion R via\n\nR = exp(Œ±ùê§/2) * exp(Œ≤ùê£/2) * exp(Œ≥ùê§/2)\n\nwhere ùê£ and ùê§ rotate about the fixed y and z axes, respectively, so this reprents an initial rotation (in the positive sense) through an angle Œ≥ about the axis z, followed by a rotation through Œ≤ about the axis y, and a final rotation through Œ± about the axis z.  This is equivalent to performing an initial rotation through Œ± about the axis z, followed by a rotation through Œ≤ about the rotated axis y, followed by a rotation through Œ≥ about the twice-rotated axis z. The angles are naturally assumed to be in radians.\n\nNOTE: Before opening an issue reporting something \"wrong\" with this function, be sure to read all of this page, especially the very last section about opening issues or pull requests.\n\nSee Also\n\nto_euler_angles: Convert quaternion to Euler angles\nto_euler_phases: Convert quaternion to Euler phases\nfrom_euler_phases: Create quaternion from Euler phases\n\n\n\n\n\n","category":"method"},{"location":"manual/#Quaternionic.from_euler_phases-Tuple{Any, Any, Any}","page":"Basics","title":"Quaternionic.from_euler_phases","text":"from_euler_phases(z‚Çê, z·µ¶, z·µß)\nfrom_euler_phases(z)\n\nReturn the quaternion corresponding to these Euler phases.\n\nInterpreting the input quaternion as a rotation (though its normalization scales out), we can define the complex Euler phases from the Euler angles (Œ±, Œ≤, Œ≥) as\n\nz‚Çê ‚âî exp(i*Œ±)\nz·µ¶ ‚âî exp(i*Œ≤)\nz·µß ‚âî exp(i*Œ≥)\n\nThese are more useful geometric quantites than the angles themselves ‚Äî being involved in computing spherical harmonics and Wigner's ùîá matrices ‚Äî and can be computed from the components of the corresponding quaternion algebraically (without the use of transcendental functions).\n\nParameters\n\nz::Vector{Complex{T}}: complex vector of length 3, representing the complex phases (z‚Çê, z·µ¶, z·µß) in that order.\n\nReturns\n\nR::Quaternion{T}\n\nSee Also\n\nto_euler_phases: Convert quaternion to Euler phases\nto_euler_angles: Convert quaternion to Euler angles\nfrom_euler_angles: Create quaternion from Euler angles\n\n\n\n\n\n","category":"method"},{"location":"manual/#Quaternionic.from_float_array-Union{Tuple{AbstractArray{T}}, Tuple{T}} where T<:Number","page":"Basics","title":"Quaternionic.from_float_array","text":"from_float_array(A)\n\nReinterpret a float array as an array of quaternions\n\nThe input array must have an initial dimension whose size is 4, because successive indices in that dimension will be considered successive components of the output quaternion.\n\nNote that this returns a view of the original data [via reinterpret(reshape,...)] only if the base type of the input array isbitstype; otherwise, a new array of Quaternions must be created, and the memory copied.\n\nSee also to_float_array.\n\n\n\n\n\n","category":"method"},{"location":"manual/#Quaternionic.from_rotation_matrix-Tuple{AbstractMatrix}","page":"Basics","title":"Quaternionic.from_rotation_matrix","text":"from_rotation_matrix(‚Ñõ)\n\nConvert 3x3 rotation matrix to quaternion.\n\nAssuming the 3x3 matrix ‚Ñõ rotates a vector v according to\n\nv' = ‚Ñõ * v,\n\nwe can also express this rotation in terms of a quaternion R such that\n\nv' = R * v * R‚Åª¬π.\n\nThis function returns that quaternion, using Bar-Itzhack's algorithm (version 3) to allow for non-orthogonal matrices.  J. Guidance, Vol. 23, No. 6, p. 1085\n\nnote: Note\nIf you want to use this function for matrices with elements of types other than Float64 or Float32, you will need to (install and) import GenericLinearAlgebra first.  The reason is that this function computes the eigen-decomposition of ‚Ñõ, which is only available for more generic float types via that package.  Note that you will want at least version 0.3.11 of GenericLinearAlgebra because previous versions had a bug.\n\n\n\n\n\n","category":"method"},{"location":"manual/#Quaternionic.from_spherical_coordinates-Tuple{Any, Any}","page":"Basics","title":"Quaternionic.from_spherical_coordinates","text":"from_spherical_coordinates(Œ∏, œï)\n\nReturn a rotor corresponding to these spherical coordinates.\n\nConsidering (Œ∏, œï) as a point n on the sphere, we can also construct a quaternion that rotates the z axis onto that point.  Here, we use the standard commonly used in physics: Œ∏ represents the \"polar angle\" between the z axis and the direction n, while œï represents the \"azimuthal angle\" between the x axis and the projection of n into the x-y plane. Both angles must be given in radians.\n\n\n\n\n\n","category":"method"},{"location":"manual/#Quaternionic.to_euler_angles-Tuple{AbstractQuaternion}","page":"Basics","title":"Quaternionic.to_euler_angles","text":"to_euler_angles(R)\n\nOpen Pandora's Box.\n\nIf somebody is trying to make you use Euler angles, tell them no, and walk away, and go and tell your mum.\n\nYou don't want to use Euler angles.  They are awful.  Stay away.  It's one thing to convert from Euler angles to quaternions; at least you're moving in the right direction.  But to go the other way?!  It's just not right.\n\nAssumes the Euler angles correspond to the quaternion R via\n\nR = exp(Œ±ùê§/2) * exp(Œ≤ùê£/2) * exp(Œ≥ùê§/2)\n\nwhere ùê£ and ùê§ rotate about the fixed y and z axes, respectively, so this reprents an initial rotation (in the positive sense) through an angle Œ≥ about the axis z, followed by a rotation through Œ≤ about the axis y, and a final rotation through Œ± about the axis z.  This is equivalent to performing an initial rotation through Œ± about the axis z, followed by a rotation through Œ≤ about the rotated axis y, followed by a rotation through Œ≥ about the twice-rotated axis z. The angles are naturally assumed to be in radians.\n\nNOTE: Before opening an issue reporting something \"wrong\" with this function, be sure to read all of this page, especially the very last section about opening issues or pull requests.\n\nReturns\n\nŒ±Œ≤Œ≥::Vector{T}\n\nRaises\n\nAllHell if you try to actually use Euler angles, when you could have been using quaternions like a sensible person.\n\nSee Also\n\nfrom_euler_angles: Create quaternion from Euler angles\nto_euler_phases: Convert quaternion to Euler phases\nfrom_euler_phases: Create quaternion from Euler phases\n\n\n\n\n\n","category":"method"},{"location":"manual/#Quaternionic.to_euler_phases-Union{Tuple{AbstractQuaternion{T}}, Tuple{T}} where T","page":"Basics","title":"Quaternionic.to_euler_phases","text":"to_euler_phases(q)\n\nConvert input quaternion to complex phases of Euler angles\n\nInterpreting the input quaternion as a rotation (though its normalization scales out), we can define the complex Euler phases from the Euler angles (Œ±, Œ≤, Œ≥) as\n\nz‚Çê ‚âî exp(i*Œ±)\nz·µ¶ ‚âî exp(i*Œ≤)\nz·µß ‚âî exp(i*Œ≥)\n\nThese are more useful geometric quantites than the angles themselves ‚Äî being involved in computing spherical harmonics and Wigner's ùîá matrices ‚Äî and can be computed from the components of the corresponding quaternion algebraically (without the use of transcendental functions).\n\nNote that to_euler_phases!(z, q) is supported for backwards compatibility, but because this function returns an SVector, there is probably no advantage to the in-place approach.\n\nReturns\n\nz::SVector{Complex{T}}: complex phases (z‚Çê, z·µ¶, z·µß) in that order.\n\nSee Also\n\nfrom_euler_phases: Create quaternion from Euler phases\nto_euler_angles: Convert quaternion to Euler angles\nfrom_euler_angles: Create quaternion from Euler angles\n\n\n\n\n\n","category":"method"},{"location":"manual/#Quaternionic.to_float_array-Union{Tuple{AbstractArray{<:AbstractQuaternion{T}}}, Tuple{T}} where T<:Number","page":"Basics","title":"Quaternionic.to_float_array","text":"to_float_array(A)\n\nView a quaternion array as an array of numbers\n\nThe output array will have an extra initial dimension whose size is 4, because successive indices in that dimension correspond to successive components of the quaternion.\n\nNote that this returns a view of the original data only if the base type of the input array isbitstype; otherwise, a new array of that type must be created, and the memory copied.\n\nSee also from_float_array.\n\n\n\n\n\n","category":"method"},{"location":"manual/#Quaternionic.to_rotation_matrix-Tuple{Q} where Q<:AbstractQuaternion","page":"Basics","title":"Quaternionic.to_rotation_matrix","text":"to_rotation_matrix(q)\n\nConvert quaternion to 3x3 rotation matrix.\n\nAssuming the quaternion R rotates a vector v according to\n\nv' = R * v * R‚Åª¬π,\n\nwe can also express this rotation in terms of a 3x3 matrix ‚Ñõ such that\n\nv' = ‚Ñõ * v.\n\nThis function returns that matrix.\n\n\n\n\n\n","category":"method"},{"location":"manual/#Quaternionic.to_spherical_coordinates-Tuple{Q} where Q<:AbstractQuaternion","page":"Basics","title":"Quaternionic.to_spherical_coordinates","text":"to_spherical_coordinates(q)\n\nReturn the spherical coordinates corresponding to this quaternion.\n\nWe can treat the quaternion as a transformation taking the z axis to some direction n.  This direction can be described in terms of spherical coordinates (Œ∏, œï).  Here, we use the standard commonly used in physics: Œ∏ represents the \"polar angle\" between the z axis and the direction n, while œï represents the \"azimuthal angle\" between the x axis and the projection of n into the x-y plane.  Both angles are given in radians.\n\n\n\n\n\n","category":"method"},{"location":"manual/#Distances","page":"Basics","title":"Distances","text":"","category":"section"},{"location":"manual/","page":"Basics","title":"Basics","text":"There are several ways of measuring the \"distance\" between two quaternions: d(q_1 q_2).  Fundamentally, any comparison between two quaternions q_1 and q_2 must make use of a binary operation, for which there are two obvious choices: addition or multiplication.  For either choice, we operate on q_1 and the appropriate inverse (either additive or multiplicative) of q_2.  That is, d should be a function of either q_1 - q_2 or q_1q_2.[1]","category":"page"},{"location":"manual/","page":"Basics","title":"Basics","text":"[1]: For q_1q_2, we are dealing with the multiplicative group of quaternions, which does not include 0, so we will assume that no quaternion involved in such a function can be 0.","category":"page"},{"location":"manual/","page":"Basics","title":"Basics","text":"Now, we also have a number of criteria we would like any distance function to satisfy.  For any quaternions q_1 and q_2 and any unit quaternion q_3, we require","category":"page"},{"location":"manual/","page":"Basics","title":"Basics","text":"real-valued: d(q_1 q_2) in mathbbR\nsymmetry: d(q_1 q_2) = d(q_2 q_1)\ninvariance: d(q_3 q_1 q_3 q_2) = d(q_1 q_2) = d(q_1 q_3 q_2 q_3)\nidentity: d(q_1 q_1) = 0\npositive-definiteness: d(q_1 q_2)  0 whenever q_1  q_2","category":"page"},{"location":"manual/","page":"Basics","title":"Basics","text":"(Of course, it should be noted that these criteria all hold in the exact case; when using floating-point numbers, they will likely be violated near edge cases.)","category":"page"},{"location":"manual/","page":"Basics","title":"Basics","text":"It is not hard to see that these criteria can be satisfied by any of","category":"page"},{"location":"manual/","page":"Basics","title":"Basics","text":"abs(q‚ÇÅ - q‚ÇÇ)\nabs2(q‚ÇÅ - q‚ÇÇ)\nabs(log(q‚ÇÅ / q‚ÇÇ))\nabs2(log(q‚ÇÅ / q‚ÇÇ)","category":"page"},{"location":"manual/","page":"Basics","title":"Basics","text":"If q_1 and q_2 are interpreted as rotations, we frequently don't care about their signs, and just want the smallest distance between them, for any choice of sign.  Furthermore, in the multiplicative case, the log functions will involve calculation of the log of the magnitudes of the quaternions, which should be 1.  In this case, we relax the \"positive-definiteness\" criterion to allow d(q_1 q_2) to equal zero when q_1 and q_2 are related by a nonzero scalar multiple.","category":"page"},{"location":"manual/","page":"Basics","title":"Basics","text":"For Rotor types, the latter two multiplicative options are most relevant, while for other types the additive options are more relevant.  These are the default behaviors of the distance and distance2 functions.","category":"page"},{"location":"manual/","page":"Basics","title":"Basics","text":"Modules = [Quaternionic]\nPages   = [\"distance.jl\"]","category":"page"},{"location":"manual/#Quaternionic.distance-Tuple{AbstractQuaternion, AbstractQuaternion}","page":"Basics","title":"Quaternionic.distance","text":"distance(q‚ÇÅ, q‚ÇÇ)\ndistance2(q‚ÇÅ, q‚ÇÇ)\n\nMeasure the \"distance\" between two quaternions, or the squared distance with distance2.\n\nBy default, this function just returns the natural measure in the additive group of quaternions:\n\nabs2(q‚ÇÅ - q‚ÇÇ)\n\nIf both arguments are Rotors, the function returns the natural measure in the rotation group, which is roughly\n\nabs2(log(q‚ÇÅ / q‚ÇÇ))\n\nNote that for Rotors, this method is (efficiently) independent of the scaling of q‚ÇÅ and q‚ÇÇ, including up to factors of -1, as is appropriate for the rotation group.\n\nExamples\n\njulia> distance(imx, imy)\n1.4142135623730951\njulia> distance(rotor(imx), rotor(imy))\n1.5707963267948966\njulia> distance(imz, -imz)\n2.0\njulia> distance(rotor(imz), rotor(-imz))\n0.0\n\n\n\n\n\n","category":"method"},{"location":"manual/#Alignment","page":"Basics","title":"Alignment","text":"","category":"section"},{"location":"manual/","page":"Basics","title":"Basics","text":"There are many ways to optimize alignment with rotations.  In particular, we can seek the optimal rotation that takes one set of points onto a corresponding set of points, or the optimal quaternion that takes one set of quaternions onto a corresponding set of quaternions.  In both cases, the \"optimal\" value depends on the metric being used.  The simplest and most robust results are obtained when the metric is the standard Euclidean metric (in the case of points), or the magnitude of the difference (in the case of quaternions).  Here, we assume that QuatVecs represent points, and any other type of quaternion should be treated as rotors.","category":"page"},{"location":"manual/","page":"Basics","title":"Basics","text":"Modules = [Quaternionic]\nPages   = [\"alignment.jl\"]","category":"page"},{"location":"manual/#Quaternionic.align-Tuple{AbstractArray{<:QuatVec}, AbstractArray{<:QuatVec}, AbstractArray{<:Real}}","page":"Basics","title":"Quaternionic.align","text":"align(a‚Éó, b‚Éó, [w])\n\nSolve Wahba's problem, finding a rotation that aligns the set of points a‚Éó to a corresponding set of points b‚Éó by minimizing the distance between the first set and the rotated second set.\n\nHere, a‚Éó and b‚Éó must be equally sized arrays of QuatVecs.  If present, w must be an equally sized array of real numbers; if not, it is taken to be 1. We define the loss function\n\nL(‚Ñõ)  Œ£·µ¢ w·µ¢ a·µ¢ - ‚Ñõ b·µ¢¬≤\n\nwhere ‚Ñõ is a rotation operator, and return the quaternion corresponding to the optimal ‚Ñõ that minimizes this function.\n\nNote that it is possible that the points do not uniquely determine a rotation ‚Äî as when one or both sets of points is rotationally symmetric.  In that case, the loss function L(‚Ñõ) will still be minimized and the points will still be optimally aligned by the output quaternion, but that quaternion will not be unique.\n\nNotes\n\nIn their book Fundamentals of Spacecraft Attitude Determination and Control (2014), Markley and Crassidis say that \"Davenport‚Äôs method remains the best method for solving Wahba‚Äôs problem\". This method provides the optimal quaternion as the dominant eigenvector (the one with the largest eigenvalue) of a certain matrix.  We start by defining the supplementary matrix\n\nS  Œ£·µ¢ w·µ¢ a·µ¢ b·µ¢·µÄ\n\nand vector\n\ns  beginbmatrix\nS‚ÇÇ‚ÇÉ-S‚ÇÉ‚ÇÇ \nS‚ÇÉ‚ÇÅ-S‚ÇÅ‚ÇÉ \nS‚ÇÅ‚ÇÇ-S‚ÇÇ‚ÇÅ\nendbmatrix\n\nThen the key matrix is\n\nM  beginbmatrix\nS + S·µÄ - (mathrmtrS) I‚ÇÉ  s \ns·µÄ  mathrmtrS\nendbmatrix\n\nIt is possible for this matrix to have degenerate eigenvalues, corresponding to cases where the points do not uniquely determine the rotation, as described above.\n\n\n\n\n\n","category":"method"},{"location":"manual/#Quaternionic.align-Tuple{Any, Any, Any}","page":"Basics","title":"Quaternionic.align","text":"align(A, B, [w])\n\nFind a Rotor that aligns the set of rotors A to a corresponding set B by minimizing the distance between the first set and the rotated second set.\n\nHere, A and B must be equally sized arrays of AbstractQuaternions.  If present, w must be an equally sized array of real numbers; if not, it is taken to be 1.  We define the loss function\n\nL(R)  Œ£·µ¢ w·µ¢ A·µ¢ - R B·µ¢¬≤\n\nwhere R is a Rotor, and return the quaternion corresponding to the optimal R that minimizes this function.\n\nNote that it is possible that the input data do not uniquely determine a rotor, which will happen when sum below is zero.  When this happens, the result will contain NaNs, but no error will be raised.  When the sum is very close to ‚Äî but not exactly ‚Äî zero, the accuracy of the result will be limited.  However, the loss function will not depend strongly on the result in that case.\n\nBe aware that this function is sensitive to the signs of the input quaternions.  See the unflip function for one way to avoid problems related to signs.\n\nNotes\n\nWe can ensure that the loss function is minimized by multiplying R by an exponential, differentiating with respect to the argument of the exponential, and setting that argument to 0.  This derivative should be 0 at the minimum.  We have\n\n‚±º Œ£·µ¢ w·µ¢ A·µ¢ - expv‚±º R B·µ¢¬≤    2  e‚±º R Œ£·µ¢ w·µ¢ B·µ¢ A·µ¢ ‚ÇÄ\n\nwhere ‚Üí denotes taking v‚±º0, the symbol ‚ÇÄ denotes taking the scalar part, and e‚±º is the unit quaternionic vector in the j direction.  The only way for this quantity to be zero for each choice of j is if\n\nR Œ£·µ¢ w·µ¢ B·µ¢ A·µ¢\n\nis itself a pure scalar.  This, in turn, can only happen if either (1) the sum is 0 or (2) if R is proportional to the conjugate of the sum:\n\nR  Œ£·µ¢ w·µ¢ A·µ¢ B·µ¢\n\nNow, since we want R to be a rotor, we simply define it to be the normalized sum.\n\n\n\n\n\n","category":"method"},{"location":"#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Quaternions for Julia","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The goal of this package is to provide a simple but flexible and complete implementation of quaternions, without restricting the interpretation of quaternions to being rotations ‚Äî while also providing extensive support for rotations ‚Äî along with thorough testing, documentation, and integration with the rest of Julia.  Wherever possible, standard functions that work with Complex will also work with Quaternion.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"In addition to a basic Quaternion{T} type, we also have Rotor{T} and QuatVec{T} specializations, which can improve the accuracy and efficiency of certain applications.  Each of these can be defined over any T<:Number; in addition to the standard primitive types (Float64, etc.), BigFloat and Symbolics.Num are tested extensively.","category":"page"},{"location":"#Examples","page":"Introduction","title":"Examples","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"There are numerous ways to construct a Quaternion ‚Äî the simplest being to just give the components:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"julia> using Quaternionic\n\njulia> q = quaternion(1.0, 2.0, 3.0, 4.0)\n1.0 + 2.0ùê¢ + 3.0ùê£ + 4.0ùê§\n\njulia> p = quaternion(4, 3, 2, 1)\n4 + 3ùê¢ + 2ùê£ + 1ùê§","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"For convenience, you can also pass a vector that will be unpacked for you:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"julia> c = [1.0, 2.0, 3.0, 4.0];\n\njulia> q = quaternion(c)\n1.0 + 2.0ùê¢ + 3.0ùê£ + 4.0ùê§","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Though, if the vector has the wrong number of elements, a MethodError will be raised.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Each quaternion type is parametrized by the types of its components (which are promoted to be all the same type).  Any subtype of Number is allowed, and is detected automatically.  For example, above q has type Quaternion{Float64}, while p has type Quaternion{Int64}.[1] The base type may be given explicitly if desired, to override the detected type:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"julia> r = Quaternion{Float64}(4, 3, 2, 1)\n4.0 + 3.0ùê¢ + 2.0ùê£ + 1.0ùê§","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The various Float and Int types work well, as do BigFloat, and the Num type from Symbolics.jl. In particular, we can use symbolic expressions as components:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"julia> using Quaternionic, Symbolics\n\njulia> @variables a b c d e;\n\njulia> quaternion(a-b, b*c, c/d, d+e)\na - b + b*cùê¢ + (c / d)ùê£ + (d + e)ùê§","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"In analogy with the complex types, the aliases QuaternionF64, QuaternionF32, and QuaternionF16 are provided, as well as the constants imx, imy, and imz, and (for copy-paste convenience) the aliases ùê¢, ùê£, and ùê§ (as Unicode bold characters):","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"julia> QuaternionF64\nQuaternionF64 (alias for Quaternion{Float64})\njulia> 0.1 + 2.3imx + 4.5imz\n0.1 + 2.3ùê¢ + 0.0ùê£ + 4.5ùê§\njulia> 0.1 + 2.3ùê¢ + 0.0ùê£ + 4.5ùê§\n0.1 + 2.3ùê¢ + 0.0ùê£ + 4.5ùê§","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"As with the complex im, the result of multiplying imx, etc., with any real number will be a quaternion with the type of the other number.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"[1]: Note that, mathematically speaking, quaternions can only be defined over a field, which necessarily cannot be an integer type (because the multiplicative inverse of an integer is not generally an integer).  Nonetheless, it is possible to define a Quaternion{<:Integer}, which should behave as expected.  However, many functions (such as exp, log, etc.)  will then return a Quaternion of some different type, just as is the case for Complex{<:Integer}.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"It is also possible to construct random quaternions using randn with a Quaternion type.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"julia> randn(QuaternionF64)\n-0.17986445341174084 + 0.5436042462142929ùê¢ - 0.20979480846942436ùê£ + 0.3594549687329696ùê§\n\njulia> randn(RotorF32)\nrotor(0.18842402 - 0.30743068ùê¢ + 0.92128336ùê£ + 0.14567046ùê§)","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Each component of the quaternion is chosen from a normal distribution with mean 0 and standard deviation 1, which means that the resulting quaternion will have an equal probability of being in any direction ‚Äî the probability distribution is \"isotropic\".  This is, for example, and good way of choosing a random direction:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"julia> normalize(randn(QuatVecF64))\n - 0.3018853063494534ùê¢ + 0.4571280910615297ùê£ - 0.8365997670169042ùê§","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Note that we have called normalize to obtain a unit vector in an random direction.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Components of the quaternion are stored as a four-element static array (even for QuatVec):","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"julia> components(q)\n4-element StaticArraysCore.SVector{4, Float64} with indices SOneTo(4):\n 1.0\n 2.0\n 3.0\n 4.0","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Those components can be indexed directly, just like an ordinary array:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"julia> q[1], q[2], q[3], q[4]\n(1.0, 2.0, 3.0, 4.0)\njulia> q[2:4]\n3-element Vector{Float64}:\n 2.0\n 3.0\n 4.0\njulia> q[[3, 2]]\n2-element Vector{Float64}:\n 3.0\n 2.0","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"For convenience, the scalar and vector components can also be accessed in analogy with complex numbers as","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"julia> real(q)\n1.0\njulia> imag(q)\n3-element view(::StaticArraysCore.SVector{4, Float64}, 2:4) with eltype Float64:\n 2.0\n 3.0\n 4.0","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Alternatively, and slightly less efficiently, various parts can be accessed as fields:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"julia> q[1], q[2], q[3], q[4]\n(1.0, 2.0, 3.0, 4.0)\njulia> q.vec\n3-element Vector{Float64}:\n 2.0\n 3.0\n 4.0\njulia> q.re\n1.0\njulia> q.im\n3-element Vector{Float64}:\n 2.0\n 3.0\n 4.0","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Again, however, these field accesses incur a slight overhead, so it's more efficient to treat the quaternion as an array and use indexing.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Functions may also be broadcast to each component of a Quaternion.  For example, this can be particularly helpful when simplifying Symbolics expressions:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"julia> @variables q[1:4];  # Defines q[1] through q[4] as symbolic variables\n\njulia> Q = quaternion(q...);\n\njulia> simplify.(Q * imz * conj(Q))\n0 + (2q[1]*q[3] + 2q[2]*q[4])ùê¢ + (-2q[1]*q[2] + 2q[3]*q[4])ùê£ + (q[1]^2 - (q[2]^2) - (q[3]^2) + q[4]^2)ùê§","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"(Though, note that you probably want to use Q(imz) instead of the last expression, when using floating-point numbers, for efficiency reasons.)","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The basic algebraic operations work as you would expect:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"julia> p + q\n5.0 + 5.0ùê¢ + 5.0ùê£ + 5.0ùê§\njulia> p - q\n3.0 + 1.0ùê¢ - 1.0ùê£ - 3.0ùê§\njulia> p * q\n-12.0 + 16.0ùê¢ + 4.0ùê£ + 22.0ùê§\njulia> q * p  # Note the non-commutativity\n-12.0 + 6.0ùê¢ + 24.0ùê£ + 12.0ùê§\njulia> q / p\n0.6666666666666666 + 0.3333333333333333ùê¢ + 0.0ùê£ + 0.6666666666666666ùê§","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Essential mathematical functions familiar from complex math, such as conj, abs, abs2, log, exp, etc., are also available.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Also note that one of the more useful quaternion operations is group conjugation or \"sandwiching\".  This is the operation that allows a Rotor to actually rotate a QuatVec.  For a rotor R and vector v, this is expressed mathematically as","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"v = R v R^-1 = R v barR","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Here, the first equality is the usual definition of conjugation of v by R, while the second equality stems from the fact that for a rotor, R^-1 = barR.  This second operation is sometimes referred to as \"sandwiching\" or \"‚àó-conjugation\" (when working in a ‚àó-algebra) to distinguish it from the more usual group conjugation involving the inverse.  It is this second version that is implemented here by using Quaternions or Rotors as functions.  For a Q of either type, and a v<:QuatVec, we have","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Q * v * conj(Q) ‚âà Q(v)","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"In particular, Q(v) (the right-hand side) is about twice as efficient as performing the conjugation and two multiplications explicitly (the left-hand side).","category":"page"},{"location":"#References","page":"Introduction","title":"References","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Several of the algorithms implemented here are ‚Äî as far as I know ‚Äî original to this package, including exp, log, and sqrt.  But important contributions came from a number of sources, including the notes by Dantam [1] and Kahan [2].  More advanced functions of time were developed in Boyle et al. [3] and Boyle [4].","category":"page"},{"location":"#Bibliography","page":"Introduction","title":"Bibliography","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"N.¬†Dantam. Quaternion Computation (Institute for Robotics and Intelligent Machines, Georgia Institute of Technology, Atlanta, GA, Oct 2014).\n\n\n\nW.¬†Kahan. Miscalculating Area and Angles of a Needle-like Triangle (University of California, Berkeley, Berkeley, CA, Sep 2014).\n\n\n\nM.¬†Boyle, R.¬†Owen and H.¬†P.¬†Pfeiffer. Geometric approach to the precession of compact binaries. Phys.¬†Rev.¬†D 84, 124011 (2011), arXiv:1110.2965 [gr-qc].\n\n\n\nM.¬†Boyle. The Integration of Angular Velocity. Advances¬†in¬†Applied¬†Clifford¬†Algebras 27, 2345‚Äì2374 (2017), arXiv:1604.08139 [gr-qc].\n\n\n\n","category":"page"}]
}
