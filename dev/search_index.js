var documenterSearchIndex = {"docs":
[{"location":"functions_of_time/#Functions-of-time","page":"Functions of time","title":"Functions of time","text":"","category":"section"},{"location":"functions_of_time/","page":"Functions of time","title":"Functions of time","text":"When using quaternions to represent rotations and orientations, we frequently model dynamical systems, which means that the quaternions must be regarded as functions of time.  The preceding functions can all be applied at each instant of time, but we also need to be deal with the change of quaternions over time, for which there are several important techniques:","category":"page"},{"location":"functions_of_time/","page":"Functions of time","title":"Functions of time","text":"Interpolation ‚Äî Taking discretely sampled quaternionic time series and interpolating to different samples, and possibly differentiating.\nAngular velocity ‚Äî Both differentiation of a quaternionic function of time to get angular velocity, and integration of angular velocity to get an orientation as a function of time.\nMinimal rotation ‚Äî Finding the least dynamical motion that can achieve pointing in a certain direction.\nDerivatives and gradients ‚Äî Thanks to the chain rule, differentiating many nontrivial quaternionic functions of time will also involve differentiating with respect to components of quaternionic arguments.","category":"page"},{"location":"functions_of_time/#Interpolation","page":"Functions of time","title":"Interpolation","text":"","category":"section"},{"location":"functions_of_time/","page":"Functions of time","title":"Functions of time","text":"Component-wise interpolation of quaternions does not generally yield good results when the quaternions are interpreted as rotations.  The basic reason is that rotations correspond to unit quaternions, but component-wise interpolation does not respect this constraint.  There are two specialized functions for dealing with this problem.  The first is slerp, which is an abbreviation of \"Spherical Linear intERPolation\", and is the direct analog of standard linear interpolation of functions ‚Ñù ‚Üí ‚Ñù.  The second is squad, which is an abbreviation of \"Spherical QUADrangle interpolation\", and is more analogous to cubic interpolation by B√©zier splines. The first is relatively fast but has discontinuous first derivatives at the input points, while the second is somewhat slower but has continuous first and second derivatives.","category":"page"},{"location":"functions_of_time/","page":"Functions of time","title":"Functions of time","text":"In both cases, it is important for extraneous sign flips to be eliminated before passing quaternions to the interpolating functions.  For this purpose, there is the unflip utility function, which can also be called automatically by passing the corresponding keywords to slerp and squad.","category":"page"},{"location":"functions_of_time/","page":"Functions of time","title":"Functions of time","text":"As noted below, slerp can also be simultaneously evaluated and differentiated analytically with slerp‚àÇslerp‚àÇœÑ (or automatically with ForwardDiff).  While, squad and its derivative can be evaluated with squad‚àÇsquad‚àÇt, this is a relatively low-level function; it is easier to use the relevant keyword arguments to squad.","category":"page"},{"location":"functions_of_time/","page":"Functions of time","title":"Functions of time","text":"Modules = [Quaternionic]\nPages   = [\"interpolation.jl\"]","category":"page"},{"location":"functions_of_time/#Quaternionic.slerp-Union{Tuple{R2}, Tuple{R1}, Tuple{R1, R2, Real}} where {R1<:Union{Quaternion, Rotor}, R2<:Union{Quaternion, Rotor}}","page":"Functions of time","title":"Quaternionic.slerp","text":"slerp(q‚ÇÅ, q‚ÇÇ, œÑ; [unflip=false])\n\n\"Spherical Linear intERPolation\" of a pair of quaternions.\n\nThe result of a \"slerp\" is given by\n\n    (q‚ÇÇ / q‚ÇÅ)^œÑ * q‚ÇÅ\n\nWhen œÑ is 0, this evaluates to q‚ÇÅ; when œÑ is 1, this evaluates to q‚ÇÇ; for any other values the result varies between the two.\n\nNote that applying this to successive pairs of quaternions as in slerp(q‚ÇÅ, q‚ÇÇ, œÑ‚Çê) and slerp(q‚ÇÇ, q‚ÇÉ, œÑ·µ¶) will be continuous, but the derivative will be discontinuous when moving from the first pair to the second.  See squad for a more continuous curve.\n\nIf unflip=true is passed as a keyword, and the input quaternions are more anti-parallel than parallel, the sign of q‚ÇÇ will be flipped before the result is computed.\n\nSee also slerp‚àÇslerp‚àÇœÑ, to simultaneously evaluate this function and its derivative with respect to œÑ, or slerp‚àÇslerp to evaluate this function and its derivative with respect to each parameter of the input.\n\n\n\n\n\n","category":"method"},{"location":"functions_of_time/#Quaternionic.squad!-Tuple{AbstractVector{var\"#s60\"} where var\"#s60\"<:Rotor, Union{Nothing, AbstractVector{var\"#s61\"} where var\"#s61\"<:QuatVec}, Union{Nothing, AbstractVector{var\"#s62\"} where var\"#s62\"<:Quaternion}, AbstractVector{var\"#s63\"} where var\"#s63\"<:Rotor, AbstractVector{var\"#s64\"} where var\"#s64\"<:Real, AbstractVector{var\"#s65\"} where var\"#s65\"<:Real}","page":"Functions of time","title":"Quaternionic.squad!","text":"squad!(Rout, Œ©‚Éóout, RÃáout, Rin, tin, tout; [unflip=false], [validate=false])\nsquad!(Rout, Rin, tin, tout; [unflip=false], [validate=false])\n\nIn-place evaluation of \"Spherical QUADrangular interpolation\".  Note that this is intended mostly as a utility function; the squad is more user-friendly.  However, for efficiency, this function may be preferable.\n\nThe first three arrays will be modified in place, and must have the same length as tout.  Their elements must be Rotor, QuatVec, and Quaternion, respectively.  Optionally, either or both of Œ©‚Éóout and RÃáout maybe nothing, in which case they will not be computed.\n\nSee also squad.\n\n\n\n\n\n","category":"method"},{"location":"functions_of_time/#Quaternionic.squad-Union{Tuple{T}, Tuple{AbstractArray{Rotor{T}, 1}, AbstractVector{var\"#s64\"} where var\"#s64\"<:Real, AbstractVector{var\"#s63\"} where var\"#s63\"<:Real}} where T","page":"Functions of time","title":"Quaternionic.squad","text":"squad(Rin, tin, tout; [kwargs...])\n\n\"Spherical QUADrangle interpolation\" of the input Rotors Rin with corresponding times tin, to the output times tout.\n\nThis is a slightly generalized version of Shoemake's \"spherical B√©zier curves\", to allow for time steps of varying sizes.\n\nThe input Rin and tin must be vectors of the same length.  The output tout may be either a single real number or a vector of real numbers.  Both tin and tout are assumed to be sorted, and tout is assumed to be contained entirely within tin; no extrapolation will be done.\n\nSee also squad! for in-place versions of this function.\n\nKeyword arguments\n\nIf unflip=true is passed as a keyword, the unflip function will be applied to Rin.\n\nIf validate=true is passed as a keyword, the time ordering of the input tin and tout will be tested to ensure that no extrapolation will be done.\n\nIf compute_angular_velocity=true is passed as a keyword, the return value will be a tuple.  The first element of the tuple will be a vector of Rotors as before, but the second element will be a vector of QuatVecs representing the angular velocity.\n\nIf compute_derivative=true is passed as a keyword, the return value will be a tuple.  The first element of the tuple will be a vector of Rotors as before, but the last element will be a vector of Quaternions representing the time-derivative of the rotors.  Note that if compute_angular_velocity=true, this tuple will have three elements.\n\n\n\n\n\n","category":"method"},{"location":"functions_of_time/#Quaternionic.squad_control_points-Tuple{AbstractVector{var\"#s10\"} where var\"#s10\"<:Rotor, AbstractVector{var\"#s9\"} where var\"#s9\"<:AbstractFloat, Int64}","page":"Functions of time","title":"Quaternionic.squad_control_points","text":"squad_control_points(R::AbstractVector{Rotor}, t::AbstractVector{<:AbstractFloat}, i::Int)\n\nThis is a helper function for the squad routines, returning the control points between one pair of input rotors.\n\nThe expressions for A and B (assuming all indices are valid) are\n\nbeginaligned\nA_i = R_i expleft\n  frac14\n  left\n    logleft(barR_i-1 R_iright) fract_i+1 - t_i t_i - t_i-1\n    - logleft(barR_i R_i+1right)\n  right\nright\n\nB_i = R_i+1 expleft\n  -frac14\n  left\n    logleft(barR_i+1 R_i+2right) fract_i+1 - t_i t_i+2 - t_i+1\n    - logleft(barR_i R_i+1right)\n  right\nright\nendaligned\n\nThese expressions will be invalid for A_mathrmbegin, A_mathrmend, B_mathrmend-1, and B_mathrmend, because they all involve out-of-bounds indices of R_i.  We can simply extend the input R values by linearly extrapolating, which results in the following simplified results:\n\nbeginaligned\nA_mathrmbegin = R_mathrmbegin \nA_mathrmend = R_mathrmend \nB_mathrmend-1 = R_mathrmend \nB_mathrmend = R_mathrmend barR_mathrmend-1 R_mathrmend \n                 = 2left(R_mathrmendcdot R_mathrmend-1right) R_mathrmend - R_mathrmend-1\nendaligned\n\n\n\n\n\n","category":"method"},{"location":"functions_of_time/#Quaternionic.unflip-Tuple{AbstractArray{var\"#s8\", N} where {var\"#s8\"<:AbstractQuaternion, N}}","page":"Functions of time","title":"Quaternionic.unflip","text":"unflip(q, [dim=1])\nunflip!(q, [dim=1])\n\nFlip the signs of successive quaternions along dimension dim so that they are as continuous as possible.\n\nIf q represents a series of rotations, the sign of each element is arbitrary. However, for certain purposes ‚Äî such as interpolation and differentiation ‚Äî the continuity of the quaternions matters, and so we want the quaternions to be as continuous as possible without changing the rotations that they represent.\n\nExamples\n\njulia> q = [imx, -imx, imx, -imx];\n\njulia> unflip(q)\n4-element Vector{QuatVec{Int64}}:\n 0 + 1ùê¢ + 0ùê£ + 0ùê§\n 0 + 1ùê¢ + 0ùê£ + 0ùê§\n 0 + 1ùê¢ + 0ùê£ + 0ùê§\n 0 + 1ùê¢ + 0ùê£ + 0ùê§\n\n\n\n\n\n","category":"method"},{"location":"functions_of_time/#Angular-velocity","page":"Functions of time","title":"Angular velocity","text":"","category":"section"},{"location":"functions_of_time/","page":"Functions of time","title":"Functions of time","text":"Given a quaternionic function of time q(t), we can ‚Äî in principle ‚Äî differentiate it to find dotq(t).  This is related to the more familiar  angular velocity vecomega by the equation","category":"page"},{"location":"functions_of_time/","page":"Functions of time","title":"Functions of time","text":"vecomega = 2 dotq q^-1","category":"page"},{"location":"functions_of_time/","page":"Functions of time","title":"Functions of time","text":"While dotq(t) can certainly be useful, it \"lives\" in a four-dimensional space, which means that it takes a little more work to relate to our three-dimensional space.  On the other hand, the direction of vecomega represents the instantaneous axis of rotation in our three-dimensional space, and its magnitude describes the rate of rotation about that axis.  More importantly, many results from physics describe rotations in terms of vecomega, rather than dotq(t).  So generally, we need a way to go from q(t) to vecomega(t) ‚Äî and back.","category":"page"},{"location":"functions_of_time/","page":"Functions of time","title":"Functions of time","text":"The details of this process and some examples are discussed in full in this paper.","category":"page"},{"location":"functions_of_time/","page":"Functions of time","title":"Functions of time","text":"Taking q(t) and obtaining vecomega(t) is fairly straightforward: one simply needs to obtain dotq(t) and apply the equation above.  If q(t) is known analytically, it may be possible to compute dotq directly (as in the example from Sec. 6.2 of the paper).  But ordinarily, this is a difficult task.  For numerical functions automatic differentiation can be used to obtain a numerical result for dotq (see below).  Or, if q is discretely sampled, squad (with the relevant keyword arguments) can be used to find the derivative of the interpolant at any instant and/or the corresponding angular velocity.","category":"page"},{"location":"functions_of_time/","page":"Functions of time","title":"Functions of time","text":"Going the other way, obtaining q(t) from vecomega(t), is more delicate ‚Äî though still possible.  It requires integrating the ordinary differential equation","category":"page"},{"location":"functions_of_time/","page":"Functions of time","title":"Functions of time","text":"dotq = frac12 vecomega q","category":"page"},{"location":"functions_of_time/","page":"Functions of time","title":"Functions of time","text":"which is just a rearrangement of the equation above to solve for dotq. Standard theorems on differential equations tell us that this equation has a solution for q(t) as long as we know vecomega as a function of time (and possibly of q, but not dotq), and supply an initial value for q at some instant of time.  Note that the paper noted above found that integrating this equation without any restriction on the norm of q is generally the most accurate and efficient choice.  However, with loose integration tolerances, numerical error may result in the output q(t) having norm significantly different from 1.  In this case, to use q as a rotation, you can normalize the result, or simply apply it by \"true\" conjugation with the inverse as in","category":"page"},{"location":"functions_of_time/","page":"Functions of time","title":"Functions of time","text":"q vecv q^-1","category":"page"},{"location":"functions_of_time/","page":"Functions of time","title":"Functions of time","text":"rather than using barq in the last factor.","category":"page"},{"location":"functions_of_time/","page":"Functions of time","title":"Functions of time","text":"If DifferentialEquations.jl is available, we can solve the ODE with code like this:","category":"page"},{"location":"functions_of_time/","page":"Functions of time","title":"Functions of time","text":"using Quaternionic\nusing DifferentialEquations\n\n# Make up some simple problem to solve\nŒ©‚Éó = randn(QuatVecF64)\nœâ‚Éó(t) = Œ©‚Éó\nq‚ÇÄ = randn(RotorF64)\ntspan = (0.0, 100.0)\n\n# Construct the ODE and `ODEProblem`\nangular_velocity_ode(q, œâ‚Éó, t) = œâ‚Éó(t) * q / 2\nangular_velocity_problem = ODEProblem(angular_velocity_ode, Quaternion(q‚ÇÄ), tspan, œâ‚Éó)\n\n# Now, solve it\nq = solve(angular_velocity_problem, Vern9(), abstol=1e-12, reltol=0)","category":"page"},{"location":"functions_of_time/","page":"Functions of time","title":"Functions of time","text":"Here, we have constructed a very simple œâ‚Éó function ‚Äî which can actually be integrated analytically ‚Äî but it could be any callable that returns a QuatVec (or Quaternion).  Note that the initial condition q‚ÇÄ has to be a Quaternion on input to ODEProblem because DifferentialEquations.jl tries to construct a zero element of that type, which is impossible for a Rotor. This initial condition is also used for the output type and ‚Äî as mentioned above ‚Äî numerical errors will tend to move the norm away from 1, so a Rotor would not make sense anyway.  The choices of Vern9 and abstol=1e-12 here are quite stringent, and may be overkill for many problems.  It is recommended to set reltol=0 in all cases.","category":"page"},{"location":"functions_of_time/","page":"Functions of time","title":"Functions of time","text":"The q that results from solve contains the time steps q.t at which the solution was found along with the solution values q.u at each of those time steps, but can also be used as a function of time to compute the value q(t) at an arbitrary time in tspan.  In this simple case, we can compute the exact value of, and compare it to the result of integration:","category":"page"},{"location":"functions_of_time/","page":"Functions of time","title":"Functions of time","text":"q_exact = @. exp([Œ©‚Éó] * q.t / 2) * q‚ÇÄ\nmaximum(distance.(q.u, q_exact))","category":"page"},{"location":"functions_of_time/","page":"Functions of time","title":"Functions of time","text":"Typical numbers for this maximum error are roughly 1e-14, though they increase as tspan is increased.","category":"page"},{"location":"functions_of_time/","page":"Functions of time","title":"Functions of time","text":"Also note that this simple version involves allocations at each time step.  If this is problematic, it should be easy to define in-place updating versions of œâ‚Éó and angular_velocity_ode to eliminate allocations, using vectors to hold the numbers instead of quaternions, and an expression like this for the ODE:","category":"page"},{"location":"functions_of_time/","page":"Functions of time","title":"Functions of time","text":"    dqdt[1] = (q[2]*œâ‚Éót[2] + q[3]*œâ‚Éót[3] + q[4]*œâ‚Éót[4]) / -2\n    dqdt[2] = (q[1]*œâ‚Éót[2] - q[3]*œâ‚Éót[4] + q[4]*œâ‚Éót[3]) / 2\n    dqdt[3] = (q[1]*œâ‚Éót[3] + q[2]*œâ‚Éót[4] - q[4]*œâ‚Éót[2]) / 2\n    dqdt[4] = (q[1]*œâ‚Éót[4] - q[2]*œâ‚Éót[3] + q[3]*œâ‚Éót[2]) / 2","category":"page"},{"location":"functions_of_time/","page":"Functions of time","title":"Functions of time","text":"There is a particularly useful complicated but analytic example available here:","category":"page"},{"location":"functions_of_time/","page":"Functions of time","title":"Functions of time","text":"Modules = [Quaternionic]\nPages   = [\"examples.jl\"]","category":"page"},{"location":"functions_of_time/#Quaternionic.precessing_nutating_example","page":"Functions of time","title":"Quaternionic.precessing_nutating_example","text":"precessing_nutating_example([Œ©‚Çí], [Œ©‚Çö], [Œ±], [Œ±Ãá], [ŒΩ], [R‚ÇÄ])\n\nReturn an exact quaternionic function of time representing nutating precessional orbital motion, as described in Sec. 6.2 of this paper.  This example is useful because it provides physically realistic but very complicated motion, while still being simple to code up and differentiate analytically.\n\nThe output represents the rotation of the line joining the orbiting bodies and their angular velocity.  The following are the input parameters, along with their default values and physical interpretations:\n\nŒ©‚Çí=2œÄ/1_000: The orbital frequency\nŒ©‚Çö=2œÄ/10_000: The precessional frequency\nŒ±=œÄ/8: The opening angle of the precession cone at t=0\nŒ±Ãá=2Œ±/100_000: The rate of opening of the precession cone\nŒΩ=œÄ/80: The angle of nutation\nR‚ÇÄ=exp(-3Œ±*imx/10): Overal rotation of the system\n\nThe default values are chosen to be typical of a (potentially) real precessing binary black hole system shortly before merger.\n\nThe returned objects are three functions of time: R, œâ‚Éó, and RÃá, which return the orientation as a Rotor, followed by the angular velocity as a QuatVec, and the time-derivative of R as a Quaternion.\n\nExample\n\njulia> R, œâ‚Éó, RÃá = precessing_nutating_example();\n\njulia> R(12.34)\n0.9944579779058746 + 0.09804177421238346ùê¢ - 0.00084850453525312ùê£ + 0.03795287510453948ùê§\njulia> œâ‚Éó(345.67)\n0.0 + 0.00046343007342867023ùê¢ - 0.0007032818419003181ùê£ + 0.006214814810035088ùê§\njulia> œµ = 1e-6; (R(œµ) - R(-œµ)) / 2œµ  # Approximate derivative at t=0\n-3.8491432263754177e-7 + (3.9080960689830135e-6)ùê¢ - (6.861695854245619e-5)ùê£ + 0.003076329202503836ùê§\njulia> RÃá(0)\n-3.8491240998153413e-7 + (3.9080812828476746e-6)ùê¢ - (6.861695854245637e-5)ùê£ + 0.0030763292025038354ùê§\n\n\n\n\n\n","category":"function"},{"location":"functions_of_time/","page":"Functions of time","title":"Functions of time","text":"Because this is an analytic solution, we know that R(t) and œâ‚Éó(t) output by this function are consistent with each other to within numerical accuracy.  We can check that our integration scheme agrees:","category":"page"},{"location":"functions_of_time/","page":"Functions of time","title":"Functions of time","text":"R, œâ‚Éó, ·πò = precessing_nutating_example()\nangular_velocity_ode(q, œâ‚Éó, t) = œâ‚Éó(t) * q / 2\ntspan = (0., 100_000.)\nangular_velocity_problem = ODEProblem(angular_velocity_ode, Quaternion(R(tspan[1])), tspan, œâ‚Éó)\nq = solve(angular_velocity_problem, Vern9(), abstol=1e-12, reltol=0);","category":"page"},{"location":"functions_of_time/","page":"Functions of time","title":"Functions of time","text":"To check the difference between the analytic R and the integrated q.u, we evaluate","category":"page"},{"location":"functions_of_time/","page":"Functions of time","title":"Functions of time","text":"julia> maximum(distance.(R.(q.t), RotorF64.(q.u)))\n3.655365559565175e-13","category":"page"},{"location":"functions_of_time/","page":"Functions of time","title":"Functions of time","text":"The maximum error is consistent with time-stepping error, so we can have confidence that other œâ‚Éó functions would be correctly integrated also.","category":"page"},{"location":"functions_of_time/#Minimal-rotation","page":"Functions of time","title":"Minimal rotation","text":"","category":"section"},{"location":"functions_of_time/","page":"Functions of time","title":"Functions of time","text":"One common problem arises when a system must be rotated to align some axis with some direction, though the rotation of the system about that axis is irrelevant.  To be specific, suppose we want to rotate our basis vectors hatx haty hatz so that hatz points in a particular direction.  A naive approach may be to determine the direction in terms of spherical coordinates (theta phi), and then use the rotation determined by Euler angles (alpha beta gamma) = (phi theta 0).  However, as with most applications of Euler angles, this is a terrible idea.  The resulting orientation will be extremely sensitive to the direction whenever it happens to be near the poles.  In such cases, the angular velocity of the system will be very high ‚Äî potentially infinite, in principle.","category":"page"},{"location":"functions_of_time/","page":"Functions of time","title":"Functions of time","text":"Fortunately, it is possible to take any rotor R_mathrmaxis(t) that aligns the axis correctly, and compute another rotation that also aligns the axis, but has the smallest possible angular velocity.  This is called the \"minimal rotation\".  The general problem is discussed (by way of a very specific physical situation) in detail in Sec. III and Appendix B of this paper.  Essentially, we solve the equation","category":"page"},{"location":"functions_of_time/","page":"Functions of time","title":"Functions of time","text":"dotgamma = 2 leftdotR_mathrmaxis ùê§ barR_mathrmaxis\nright_w","category":"page"},{"location":"functions_of_time/","page":"Functions of time","title":"Functions of time","text":"(where the subscript w just takes the scalar component) for gamma(t). We then construct the rotor","category":"page"},{"location":"functions_of_time/","page":"Functions of time","title":"Functions of time","text":"R(t) = R_mathrmaxis(t) expleftgamma(t) ùê§  2 right","category":"page"},{"location":"functions_of_time/","page":"Functions of time","title":"Functions of time","text":"This rotor also aligns the axis correctly, but otherwise has the smallest possible angular velocity.  Here, R_mathrmaxis may be constructed in any convenient way, including using spherical coordinates; the resulting R(t) will be independent of such poor life choices.","category":"page"},{"location":"functions_of_time/#Derivatives-and-gradients","page":"Functions of time","title":"Derivatives and gradients","text":"","category":"section"},{"location":"functions_of_time/","page":"Functions of time","title":"Functions of time","text":"It can be very useful to compute the derivative of various functions with respect to their arguments ‚Äî for example, when computing angular velocity of a squad interpolant, one needs to use the chain rule, and therefore needs each of the derivatives of exp, log, etc.  Here, we provide the essential (nontrivial) derivatives, treating each quaternionic argument as a series of four real arguments.  For each input argument, the output is generally a quaternion; interpreting those outputs as also being a series of four real quantities, these derivatives could also be thought of as Jacobian matrices of the relevant functions, though the actual return types are collections of Quaternion objects.","category":"page"},{"location":"functions_of_time/","page":"Functions of time","title":"Functions of time","text":"Because of massive simplifications that result when using the right types, these derivatives are more strict about input types than the main functions themselves.  For example, the derivatives of exp are defined only for QuatVec arguments; the derivatives of log are defined only for Rotor arguments; etc.","category":"page"},{"location":"functions_of_time/","page":"Functions of time","title":"Functions of time","text":"Note that gradients can also be calculated automatically using ForwardDiff.jl.[2] For example, we could compute the derivative of slerp with respect to the y component of the first input quaternion as","category":"page"},{"location":"functions_of_time/","page":"Functions of time","title":"Functions of time","text":"‚àÇslerp‚àÇq‚ÇÅy(q‚ÇÅ, q‚ÇÇ, œÑ) = ForwardDiff.derivative(œµ->slerp(q‚ÇÅ+œµ*imy, q‚ÇÇ, œÑ), 0)","category":"page"},{"location":"functions_of_time/","page":"Functions of time","title":"Functions of time","text":"This is equal to","category":"page"},{"location":"functions_of_time/","page":"Functions of time","title":"Functions of time","text":"slerp‚àÇslerp(q‚ÇÅ, q‚ÇÇ, œÑ)[2][3]","category":"page"},{"location":"functions_of_time/","page":"Functions of time","title":"Functions of time","text":"though slerp‚àÇslerp computes the value and all derivatives of slerp simultaneously, and does at least as fast as ‚Äî and likely faster than ‚Äî most AD systems would.  Nonetheless, it is useful to know that ForwardDiff can process functions involving Quaternionic methods.","category":"page"},{"location":"functions_of_time/","page":"Functions of time","title":"Functions of time","text":"[2]: As of this writing, Zygote.jl does not work.  I'm not sure why, but I'm guessing it's related to Zygote's troubles with complex numbers.  I don't really understand AD terminology, but this comment suggests forward-mode AD is better for this kind of thing anyway.  In any case, pull requests for improving this package's interaction with AD are certainly welcome.","category":"page"},{"location":"functions_of_time/","page":"Functions of time","title":"Functions of time","text":"Modules = [Quaternionic]\nPages   = [\"gradients.jl\"]","category":"page"},{"location":"functions_of_time/#Quaternionic.exp‚àÇexp-Tuple{QuatVec}","page":"Functions of time","title":"Quaternionic.exp‚àÇexp","text":"exp‚àÇexp(Z::QuatVec)\n\nReturn the value and gradient of exp(Z) with respect to the components of Z.\n\nSee ‚àÇexp for more explanation of the components of the gradient.\n\nExamples\n\njulia> e, ‚àÇe = exp‚àÇexp(randn(QuatVecF64));\n\n\n\n\n\n\n","category":"method"},{"location":"functions_of_time/#Quaternionic.log‚àÇlog-Tuple{Rotor}","page":"Functions of time","title":"Quaternionic.log‚àÇlog","text":"log‚àÇlog(Z::Rotor)\n\nReturn the value and gradient of log(Z) with respect to the components of Z.\n\nSee ‚àÇlog for more explanation of the components of the gradient.\n\nExamples\n\njulia> l, ‚àÇl = log‚àÇlog(randn(RotorF64));\n\n\n\n\n\n\n","category":"method"},{"location":"functions_of_time/#Quaternionic.slerp‚àÇslerp-Tuple{Rotor, Rotor, Real}","page":"Functions of time","title":"Quaternionic.slerp‚àÇslerp","text":"slerp‚àÇslerp(q‚ÇÅ, q‚ÇÇ, œÑ)\n\nReturn the value and gradient of slerp.\n\nThe gradient is with respect to each of the input arguments in turn, with each quaternion regarded as a series of four arguments.  That is, a total of 10 quaternions will be returned:\n\nbeginaligned\n  big\n    quad mathrmslerp(q‚ÇÅ q‚ÇÇ œÑ) \n    quad fracpartialpartial q‚ÇÅw mathrmslerp(q‚ÇÅ q‚ÇÇ œÑ) \n    quad fracpartialpartial q‚ÇÅx mathrmslerp(q‚ÇÅ q‚ÇÇ œÑ) \n    quad fracpartialpartial q‚ÇÅy mathrmslerp(q‚ÇÅ q‚ÇÇ œÑ) \n    quad fracpartialpartial q‚ÇÅz mathrmslerp(q‚ÇÅ q‚ÇÇ œÑ) \n    quad fracpartialpartial q‚ÇÇw mathrmslerp(q‚ÇÅ q‚ÇÇ œÑ) \n    quad fracpartialpartial q‚ÇÇx mathrmslerp(q‚ÇÅ q‚ÇÇ œÑ) \n    quad fracpartialpartial q‚ÇÇy mathrmslerp(q‚ÇÅ q‚ÇÇ œÑ) \n    quad fracpartialpartial q‚ÇÇz mathrmslerp(q‚ÇÅ q‚ÇÇ œÑ) \n    quad fracpartialpartial tau mathrmslerp(q‚ÇÅ q‚ÇÇ œÑ) \n  big\nendaligned\n\nFor convenience, this will be a 4-tuple with the slerp as the first element, the first four components of the derivative, followed by the next four components of the derivative, followed by the last component of the derivative.\n\nSee also slerp for just the value, and slerp‚àÇslerp‚àÇœÑ for just the value and the derivative with respect to œÑ.\n\nExamples\n\njulia> (q1, q2), œÑ = randn(RotorF64, 2), rand();\n\njulia> s, ‚àÇs‚àÇq‚ÇÅ, ‚àÇs‚àÇq‚ÇÇ, ‚àÇs‚àÇœÑ = slerp‚àÇslerp(q‚ÇÅ, q‚ÇÇ, œÑ);\n\n\n\n\n\n\n","category":"method"},{"location":"functions_of_time/#Quaternionic.slerp‚àÇslerp‚àÇœÑ-Tuple{Rotor, Rotor, Real}","page":"Functions of time","title":"Quaternionic.slerp‚àÇslerp‚àÇœÑ","text":"slerp‚àÇslerp‚àÇœÑ(q‚ÇÅ, q‚ÇÇ, œÑ)\n\nReturn the value and time-derivative of slerp.\n\nSee also slerp‚àÇslerp, which returns the value and all of the derivatives of slerp.\n\n\n\n\n\n","category":"method"},{"location":"functions_of_time/#Quaternionic.squad‚àÇsquad‚àÇt-NTuple{7, Any}","page":"Functions of time","title":"Quaternionic.squad‚àÇsquad‚àÇt","text":"squad‚àÇsquad‚àÇt(q·µ¢, A, B, q·µ¢‚Çä‚ÇÅ, ta, tb, t)\n\nCompute the value and time-derivative of squad.\n\nThis is primarily an internal helper function, taking various parameters computed within the squad function.  This will be used to compute the derivative of squad when the angular velocity is also requested.  To actually obtain the derivative, simply pass the relevant keyword to the squad function.\n\n\n\n\n\n","category":"method"},{"location":"functions_of_time/#Quaternionic.‚àÇexp-Tuple{QuatVec}","page":"Functions of time","title":"Quaternionic.‚àÇexp","text":"‚àÇexp(Z::QuatVec)\n\nReturn the gradient of exp(Z) with respect to the components of Z.\n\nThe result includes \"off-shell\" components of the gradient, meaning that even though a scalar component of Z would not be allowed for a QuatVec, we measure the gradient in that direction anyway.  That is, the first element of the returned vector of quaternions is\n\nbeginaligned\n  leftfracpartial partial Z_w exp(Z) right_Z_w=0\nendaligned\n\nNote that, even though exp(::QuatVec) is a Rotor, the derivative (and therefore each element of the result) is a general Quaternion.\n\nSee also ‚àÇlog for a similar function, as well as exp‚àÇexp for a function to compute the value along with the gradient.\n\nExamples\n\njulia> ‚àÇexp‚àÇw, ‚àÇexp‚àÇx, ‚àÇexp‚àÇy, ‚àÇexp‚àÇz = ‚àÇexp(randn(QuatVecF64));\n\n\n\n\n\n\n","category":"method"},{"location":"functions_of_time/#Quaternionic.‚àÇlog-Tuple{Rotor}","page":"Functions of time","title":"Quaternionic.‚àÇlog","text":"‚àÇlog(Z::Rotor)\n\nReturn the gradient of log(Z) with respect to the components of Z.\n\nThe result includes \"off-shell\" components of the gradient, meaning that even though change of Z in a direction that changes its norm would not be allowed for a Rotor, we measure the gradient in that direction anyway.  That is, the elements of the returned vector of quaternions is\n\nbeginaligned\n  left\n    fracpartial partial Z_w log(Z)\n    fracpartial partial Z_x log(Z)\n    fracpartial partial Z_y log(Z)\n    fracpartial partial Z_z log(Z)\n  right\nendaligned\n\nNote that, even though log(::Rotor) is a QuatVec, the derivative (and therefore each element of the result) is a general Quaternion.\n\nSee also ‚àÇexp for a similar function, as well as log‚àÇlog for a function to compute the value along with the gradient.\n\nExamples\n\njulia> ‚àÇlog‚àÇw, ‚àÇlog‚àÇx, ‚àÇlog‚àÇy, ‚àÇlog‚àÇz = ‚àÇlog(randn(QuatVecF64));\n\n\n\n\n\n\n","category":"method"},{"location":"manual/#Quaternionic-functions","page":"Basics","title":"Quaternionic functions","text":"","category":"section"},{"location":"manual/","page":"Basics","title":"Basics","text":"From AbstractQuaternion{T} we define three subtypes:","category":"page"},{"location":"manual/","page":"Basics","title":"Basics","text":"Quaternion{T}, which is an element of the general algebra of quaternions over any T<:Real.\nRotor{T}, which is an element of the multiplicative group of unit quaternions, and is interpreted as mapping to a rotation.  The magnitude is assumed to be 1 (though, for efficiency, this is not generally confirmed), and the sign may be freely changed in certain cases.\nQuatVec{T}, which is an element of the additive group of quaternions with 0 scalar part; a \"pure vector\" quaternion.","category":"page"},{"location":"manual/","page":"Basics","title":"Basics","text":"For simplicity, almost every function in this package is defined for general Quaternions, so you may not need any other type.  However, it can frequently be more accurate and more efficient to use the other subtypes where relevant.","category":"page"},{"location":"manual/#Constructors,-constants,-and-conversions","page":"Basics","title":"Constructors, constants, and conversions","text":"","category":"section"},{"location":"manual/","page":"Basics","title":"Basics","text":"At the most basic level, Quaternion{T} mimics Complex{T} as closely as possible, including the behavior of most functions in Base.  The Rotor{T} and QuatVec{T} subtypes behave very similarly, except that most of their constructors automatically impose the constraints that the norm is 1 and the scalar component is 0, respectively.  Also note that when a certain operation is not defined for either of those subtypes, the functions will usually convert to a general Quaternion automatically.","category":"page"},{"location":"manual/","page":"Basics","title":"Basics","text":"To create new Quaternions interactively, it is typically most convenient to use the constants imx, imy, and imz ‚Äî or equivalently ùê¢, ùê£, and ùê§ ‚Äî multiplied by appropriate factors and added together.  For programmatic work, it is more common to use the Quaternion function ‚Äî which takes all four components, the three vector components, or just the one scalar component, and creates a new Quaternion of the type implied by the arguments.  You can also specify the type, as in Quaternion{Float64}(...).  Type conversions with promote, widen, float, etc., work as expected.","category":"page"},{"location":"manual/","page":"Basics","title":"Basics","text":"Modules = [Quaternionic]\nPages   = [\"quaternion.jl\"]\nOrder   = [:module, :type, :constant, :function, :macro]","category":"page"},{"location":"manual/#Quaternionic.QuatVec","page":"Basics","title":"Quaternionic.QuatVec","text":"QuatVec{T<:Real} <: Number\n\nPure-vector quaternion with elements of type T.  These objects can be significantly faster and more accurate in certain operations than general Quaternions.\n\nQuatVecF16, QuatVecF32 and QuatVecF64 are aliases for QuatVec{Float16}, QuatVec{Float32} and QuatVec{Float64} respectively.  See also Quaternion and Rotor.\n\nThe functions\n\nQuatVec(w, x, y, z)\nQuatVec(x, y, z)\nQuatVec(w)\nQuatVec{T}(w, x, y, z)\n\ncreate a new rotor with the given components (where the components are as described in Quaternion), except that the scalar argument w is always set to 0.\n\nExamples\n\njulia> QuatVec(1, 2, 3, 4)\n0 + 2ùê¢ + 3ùê£ + 4ùê§\njulia> QuatVec(Quaternion(1, 2, 3, 4))\n0 + 2ùê¢ + 3ùê£ + 4ùê§\njulia> QuatVec(2, 3, 4)\n0 + 2ùê¢ + 3ùê£ + 4ùê§\njulia> QuatVec(1)\n0 + 0ùê¢ + 0ùê£ + 0ùê§\n\n\n\n\n\n","category":"type"},{"location":"manual/#Quaternionic.Quaternion","page":"Basics","title":"Quaternionic.Quaternion","text":"Quaternion{T<:Real} <: Number\n\nQuaternionic number type with elements of type T.\n\nQuaternionF16, QuaternionF32 and QuaternionF64 are aliases for Quaternion{Float16}, Quaternion{Float32} and Quaternion{Float64} respectively.  See also Rotor and QuatVec.\n\nThe functions\n\nQuaternion(w, x, y, z)\nQuaternion(x, y, z)\nQuaternion(w)\nQuaternion{T}(w, x, y, z)\n\ncreate a new quaternion with the given components.  The argument w is the scalar component, and x, y, and z are the corresponding \"vector\" components.  If any of these arguments is missing, it will be set to zero.  The type of the returned quaternion will be inferred from the input arguments, or can be specified, by passing the type parameter T as above.\n\nNote that the constants imx, imy, and imz can also be used like the complex im to create new Quaternion object.\n\nExamples\n\njulia> Quaternion(1, 2, 3, 4)\n1 + 2ùê¢ + 3ùê£ + 4ùê§\njulia> Quaternion{Float64}(1, 2, 3, 4)\n1.0 + 2.0ùê¢ + 3.0ùê£ + 4.0ùê§\njulia> Quaternion(1.0, 2.0, 3.0, 4.0)\n1.0 + 2.0ùê¢ + 3.0ùê£ + 4.0ùê§\njulia> Quaternion(2, 3, 4)\n0 + 2ùê¢ + 3ùê£ + 4ùê§\njulia> Quaternion(1)\n1 + 0ùê¢ + 0ùê£ + 0ùê§\n\n\n\n\n\n","category":"type"},{"location":"manual/#Quaternionic.Rotor","page":"Basics","title":"Quaternionic.Rotor","text":"Rotor{T<:Real} <: Number\n\nQuaternion of unit magnitude with elements of type T.  These objects can be significantly faster and more accurate in certain operations representing rotations.\n\nA rotor is typically considered to be an element of the group mathrmSpin(3)  mathrmSU(2), which can be thought of as the subgroup of quaternions with norm 1.  They are particularly useful as representations of rotations because a rotor R acts on a vector vecv by \"conjugation\" as\n\nvecv = R vecv R^-1\n\nThis preserves the inner product between any two vectors conjugated in this way, and so is a rotation.  Note that, because there are two factors of R here, the sign of R does not affect the result.  Therefore, mathrmSpin(3) forms a double cover of the rotation group mathrmSO(3).  For this reason, it will occasionally be useful to disregard or arbitrarily change the sign of a Rotor (as in distance functions) ‚Äî though this is not generally the default, and may cause problems if the input rotors change sign when the corresponding rotations are not so different (cf. unflip).\n\nRotorF16, RotorF32 and RotorF64 are aliases for Rotor{Float16}, Rotor{Float32} and Rotor{Float64} respectively.  See also Quaternion and QuatVec.\n\nThe functions\n\nRotor(w, x, y, z)\nRotor(x, y, z)\nRotor(w)\nRotor{T}(w, x, y, z)\n\ncreate a new rotor with the given components (where the components are as described in Quaternion), automatically normalizing them on input. If you would like to bypass this normalization step, you can call\n\nRotor{T}(v)\n\nwhere v<:AbstractArray, and can be converted to an SVector{4, T}.\n\nHowever, once a Rotor is created, its norm will always be assumed to be precisely 1.  So if its true norm is significantly different, you will like see weird results ‚Äî including vectors with very different lengths after \"rotation\" by a non-unit Rotor.\n\nNote that simply creating a Quaternion that happens to have norm 1 does not make it a Rotor.  However, you can pass such a Quaternion to the Rotor function and get the desired result.\n\nExamples\n\njulia> Rotor(1, 2, 3, 4)\n0.18257418583505536 + 0.3651483716701107ùê¢ + 0.5477225575051661ùê£ + 0.7302967433402214ùê§\njulia> Rotor(Quaternion(1, 2, 3, 4))\n0.18257418583505536 + 0.3651483716701107ùê¢ + 0.5477225575051661ùê£ + 0.7302967433402214ùê§\njulia> Rotor{Float16}(1, 2, 3, 4)\n0.1826 + 0.3652ùê¢ + 0.548ùê£ + 0.7305ùê§\njulia> Rotor(2, 3, 4)\n0.0 + 0.3713906763541037ùê¢ + 0.5570860145311556ùê£ + 0.7427813527082074ùê§\njulia> Rotor(1)\n1 + 0ùê¢ + 0ùê£ + 0ùê§\n\n\n\n\n\n","category":"type"},{"location":"manual/#Quaternionic.imx","page":"Basics","title":"Quaternionic.imx","text":"imx\n\nThe quaternionic unit associated with rotation about the x axis.  Can also be entered as Unicode bold: ùê¢.\n\nExamples\n\njulia> imx * imx\n-1 + 0ùê¢ + 0ùê£ + 0ùê§\njulia> 1.2imx\n0.0 + 1.2ùê¢ + 0.0ùê£ + 0.0ùê§\n\n\n\n\n\n","category":"constant"},{"location":"manual/#Quaternionic.imy","page":"Basics","title":"Quaternionic.imy","text":"imy\n\nThe quaternionic unit associated with rotation about the y axis.  Can also be entered as Unicode bold: ùê£.\n\nExamples\n\njulia> imy * imy\n-1 + 0ùê¢ + 0ùê£ + 0ùê§\njulia> 1.2imy\n0.0 + 0.0ùê¢ + 1.2ùê£ + 0.0ùê§\n\n\n\n\n\n","category":"constant"},{"location":"manual/#Quaternionic.imz","page":"Basics","title":"Quaternionic.imz","text":"imz\n\nThe quaternionic unit associated with rotation about the z axis.  Can also be entered as Unicode bold: ùê§.\n\nExamples\n\njulia> imz * imz\n-1 + 0ùê¢ + 0ùê£ + 0ùê§\njulia> 1.2imz\n0.0 + 0.0ùê¢ + 0.0ùê£ + 1.2ùê§\n\n\n\n\n\n","category":"constant"},{"location":"manual/#Number-functions-from-Base","page":"Basics","title":"Number functions from Base","text":"","category":"section"},{"location":"manual/","page":"Basics","title":"Basics","text":"The standard Number functions that work for Complex, such as isfinite, iszero, etc., should work analogously for Quaternion.  The hash, read, and write functions are also implemented.  As noted in the Examples, broadcasting to each component is also implemented via broadcasted.","category":"page"},{"location":"manual/","page":"Basics","title":"Basics","text":"Modules = [Quaternionic]\nPages   = [\"base.jl\"]","category":"page"},{"location":"manual/#Algebra-and-mathematical-functions","page":"Basics","title":"Algebra and mathematical functions","text":"","category":"section"},{"location":"manual/","page":"Basics","title":"Basics","text":"Along with the basic binary operators, the essential mathematical functions like conj, abs, abs2, exp, log, etc., are implemented.  Most of these functions are found in the Base module, and are simply overloaded methods of functions that should also be familiar from Complex types.  Note that we use a slightly different interpretation of angle for Quaternion, compared to Complex.  We also have absvec and abs2vec, which are not useful in a Complex context, but compute the relevant quantities for the \"vector\" component of a Quaternion.","category":"page"},{"location":"manual/","page":"Basics","title":"Basics","text":"Modules = [Quaternionic]\nPages   = [\"algebra.jl\", \"math.jl\"]","category":"page"},{"location":"manual/#Base.conj-Tuple{Q} where Q<:AbstractQuaternion","page":"Basics","title":"Base.conj","text":"conj(q)\n\nReturn the quaternion conjugate, which flips the sign of each \"vector\" component.\n\nExamples\n\njulia> conj(Quaternion(1,2,3,4))\n1 - 2ùê¢ - 3ùê£ - 4ùê§\n\n\n\n\n\n","category":"method"},{"location":"manual/#Quaternionic.:√ó-Tuple{QuatVec, QuatVec}","page":"Basics","title":"Quaternionic.:√ó","text":"a √ó b\n\nReturn the cross product of two pure-vector quaternions.  Equal to ¬Ω of the commutator product a*b-b*a.\n\n\n\n\n\n","category":"method"},{"location":"manual/#Quaternionic.:√óÃÇ-Tuple{QuatVec, QuatVec}","page":"Basics","title":"Quaternionic.:√óÃÇ","text":"a √óÃÇ b\n\nReturn the direction of the cross product between a and b; the normalized vector along a√ób ‚Äî unless the magnitude is zero, in which case the zero vector is returned.\n\n\n\n\n\n","category":"method"},{"location":"manual/#Quaternionic.:‚ãÖ-Tuple{AbstractQuaternion, AbstractQuaternion}","page":"Basics","title":"Quaternionic.:‚ãÖ","text":"p ‚ãÖ q\n\nEvaluate the inner (\"dot\") product between two quaternions.  Equal to the scalar part of p * conj(q).\n\nNote that this function is not very commonly used, except as a quick way to determine whether the two quaternions are more anti-parallel than parallel, for functions like unflip.\n\n\n\n\n\n","category":"method"},{"location":"manual/#Quaternionic.normalize-Tuple{AbstractQuaternion}","page":"Basics","title":"Quaternionic.normalize","text":"normalize(q)\n\nReturn a copy of this quaternion, normalized.\n\nNote that this returns the same type as the input quaternion.  If you want to convert to a Rotor, just call Rotor(q), which includes a normalization step.\n\n\n\n\n\n","category":"method"},{"location":"manual/#Base.abs-Tuple{AbstractQuaternion}","page":"Basics","title":"Base.abs","text":"abs(q)\n\nSquare-root of the sum the squares of the components of the quaternion\n\nExamples\n\njulia> abs(Quaternion(1,2,4,10))\n11.0\n\n\n\n\n\n","category":"method"},{"location":"manual/#Base.abs2-Tuple{AbstractQuaternion}","page":"Basics","title":"Base.abs2","text":"abs2(q)\n\nSum the squares of the components of the quaternion\n\nExamples\n\njulia> abs2(Quaternion(1,2,4,10))\n121\n\n\n\n\n\n","category":"method"},{"location":"manual/#Base.angle-Union{Tuple{Quaternion{T}}, Tuple{T}} where T","page":"Basics","title":"Base.angle","text":"angle(q)\n\nPhase angle in radians of the rotation represented by this quaternion.\n\nNote that this may be different from your interpretation of the angle of a complex number in an important way.  Because quaternions act on vectors by conjugation ‚Äî as in q*v*conj(q) ‚Äî there are two copies of q involved in that expression; in some sense, a quaternion acts \"twice\".  Therefore, this angle may be twice what you expect from an analogy with complex numbers ‚Äî dpending on how you interpret the correspondence between complex numbers and quaternions.  Also, while rotations in the complex plane have a natural choice of axis (the positive z direction), that is not the case for quaternions, which means that the sign of this angle is arbitrary, and we always choose it to be positive.\n\nExamples\n\njulia> Œ∏=1.2;\n\njulia> R=exp(Œ∏ * imz / 2);\n\njulia> angle(R)\n1.2\n\n\n\n\n\n\n","category":"method"},{"location":"manual/#Base.exp-Union{Tuple{Quaternion{T}}, Tuple{T}} where T","page":"Basics","title":"Base.exp","text":"exp(q)\n\nExponential of a quaternion\n\nExamples\n\njulia> exp(imx*œÄ/4)  # Rotation through œÄ/2 (note the extra 1/2) about the x axis\n0.7071067811865476 + 0.7071067811865475ùê¢ + 0.0ùê£ + 0.0ùê§\n\n\n\n\n\n","category":"method"},{"location":"manual/#Base.log-Union{Tuple{Quaternion{T}}, Tuple{T}} where T","page":"Basics","title":"Base.log","text":"log(q)\n\nLogarithm of a quaternion.\n\nAs with the usual complex logarithm, the quaternion logarithm has multiple branches, though the quaternion branches are three-dimensional: for any unit \"vector\" quaternion qÃÇ, you could add any integer multiple of 2œÄqÃÇ to the result of this function and still get the same result after exponentiating (within numerical accuracy).  This function is the principal logarithm.\n\nThis function has discontinuous (and fairly arbitrary) behavior along the negative real axis: if the \"vector\" components of the quaternion are precisely zero and the scalar component is negative, the returned quaternion will have scalar component log(-q.w), but will also have a z component of œÄ.  The choice of the z direction is arbitrary; the \"vector\" component of the returned quaternion could be œÄ times any unit vector.\n\nNote that this function is not specialized to unit-quaternion inputs, so the scalar component of the returned value will be nonzero unless the input has precisely unit magnitude.\n\nExamples\n\njulia> log(exp(1.2imy))\n0.0 + 0.0ùê¢ + 1.2ùê£ + 0.0ùê§\n\njulia> log(Quaternion(exp(7)))\n7.0 + 0.0ùê¢ + 0.0ùê£ + 0.0ùê§\n\njulia> log(Quaternion(-exp(7)))\n7.0 + 0.0ùê¢ + 0.0ùê£ + 3.141592653589793ùê§\n\n\n\n\n\n","category":"method"},{"location":"manual/#Base.sqrt-Union{Tuple{Quaternion{T}}, Tuple{T}} where T","page":"Basics","title":"Base.sqrt","text":"sqrt(q)\n\nSquare-root of a quaternion.\n\nThe general formula whenever the denominator is nonzero is\n\nsqrtq = fracq + q sqrt2q + 2qw\n\nThis can be proven by expanding q as q.w + q.vec and multiplying the expression above by itself.\n\nWhen the denominator is zero, this function has discontinuous (and fairly arbitrary) behavior, just as with the quaternion log function.  In this case, either all components are zero ‚Äî in which case the result is simply the zero quaternion ‚Äî or the \"vector\" components of the quaternion are precisely zero and the scalar component is negative.  If the latter is true, the denominator above will be a pure-imaginary number.  Because the quaternions come with infinitely many elements that square to -1, it is not clear which imaginary should be used, so we arbitrarily choose to set the result proportional to the z quaternion.  The choice of the z direction is arbitrary; the \"vector\" component of the returned quaternion could be in any direction.\n\nExamples\n\njulia> q = Quaternion(1.2, 3.4, 5.6, 7.8);\n\njulia> sqrtq = ‚àöq;\n\njulia> sqrtq^2 ‚âà q\ntrue\n\njulia> ‚àöQuaternion(4)\n2.0 + 0.0ùê¢ + 0.0ùê£ + 0.0ùê§\n\njulia> ‚àöQuaternion(-4)\n0.0 + 0.0ùê¢ + 0.0ùê£ + 2.0ùê§\n\n\n\n\n\n","category":"method"},{"location":"manual/#Quaternionic.abs2vec-Tuple{AbstractQuaternion}","page":"Basics","title":"Quaternionic.abs2vec","text":"abs2vec(q)\n\nSum the squares of the \"vector\" components of the quaternion\n\nExamples\n\njulia> abs2vec(Quaternion(1,2,3,6))\n49\n\n\n\n\n\n","category":"method"},{"location":"manual/#Quaternionic.absvec-Tuple{AbstractQuaternion}","page":"Basics","title":"Quaternionic.absvec","text":"absvec(q)\n\nSquare-root of the sum of the squares of the \"vector\" components of the quaternion\n\nExamples\n\njulia> absvec(Quaternion(1,2,3,6))\n7.0\n\n\n\n\n\n","category":"method"},{"location":"manual/#Random-quaternions","page":"Basics","title":"Random quaternions","text":"","category":"section"},{"location":"manual/","page":"Basics","title":"Basics","text":"It is frequently convenient to construct random Quaternion objects, which can be done just as with other types by passing the desired output type to the randn function.  The rand function is not overloaded, because there would be no geometric significance to such a Quaternion; randn results are independent of the orientation of the basis used to define the quaternions. Note that it is possible to get random rotors and vectors by passing the appropriate tyepes to the randn function.","category":"page"},{"location":"manual/","page":"Basics","title":"Basics","text":"Modules = [Quaternionic]\nPages   = [\"random.jl\"]","category":"page"},{"location":"manual/#Base.randn-Union{Tuple{T}, Tuple{Random.AbstractRNG, Type{var\"#s11\"} where var\"#s11\"<:AbstractQuaternion{T}}} where T<:AbstractFloat","page":"Basics","title":"Base.randn","text":"randn([rng=GLOBAL_RNG], T=Quaternion{Float64}, [dims...])\n\nGenerate a normally distributed random quaternion of type T with mean 0 and standard deviation of norm 1.  Optionally generate an array of such quaternions.  This module currently provides an implementation for the types QuaternionF16, QuaternionF32, and QuaternionF64 (the default).  The values are drawn from the spherically symmetric quaternionic normal distribution of variance 1 (corresponding to each component having independent normal distribution with mean zero and variance 1/4).\n\nNote that this function works with Quaternion{BigFloat}, even though Base.randn does not work with BigFloat; we just use the Box-Muller transform to obtain the desired result.\n\nIf the quaternion type passed in is Rotor, the result will be normalized correctly. Because the distribution is spherically symmetric, the result is a truly random rotation.\n\nIf the quaternion type is QuatVec, the result will have a 0 scalar component, and the vector will have mean 0 standard deviation of norm 1.\n\nExamples\n\njulia> randn(QuaternionF64)\n0.4336736009756228 - 0.45087190792840853ùê¢ - 0.24723937675211696ùê£ - 0.4514571469326208ùê§\njulia> randn(QuaternionF16, 2, 2)\n2√ó2 Matrix{QuaternionF16}:\n   0.4321 + 1.105ùê¢ + 0.2664ùê£ - 0.1359ùê§   0.064 + 0.9263ùê¢ - 0.4138ùê£ + 0.05505ùê§\n 0.2512 - 0.2585ùê¢ - 0.2803ùê£ - 0.00964ùê§  -0.1256 + 0.1848ùê¢ + 0.03607ùê£ - 0.752ùê§\n\n\n\n\n\n","category":"method"},{"location":"manual/#Conversions","page":"Basics","title":"Conversions","text":"","category":"section"},{"location":"manual/","page":"Basics","title":"Basics","text":"It can sometimes be useful to convert between quaternions and other representations.  Most of these functions are named to_<representation> and have a corresponding from_<representation> function.  Furthermore, most convert to/from representations of rotations.  While rotations are not the only useful application of quaternions, they are probably the most common.  The only conversions that are not specifically related to rotations are to_float_array and from_float_array.","category":"page"},{"location":"manual/","page":"Basics","title":"Basics","text":"Modules = [Quaternionic]\nPages   = [\"conversion.jl\"]","category":"page"},{"location":"manual/#Quaternionic.from_euler_angles-Tuple{Any, Any, Any}","page":"Basics","title":"Quaternionic.from_euler_angles","text":"from_euler_angles(Œ±, Œ≤, Œ≥)\n\nCome over from the dark side.\n\nAssumes the Euler angles correspond to the quaternion R via\n\nR = exp(Œ±ùê§/2) * exp(Œ≤ùê£/2) * exp(Œ≥ùê§/2)\n\nwhere ùê£ and ùê§ rotate about the fixed y and z axes, respectively, so this reprents an initial rotation (in the positive sense) through an angle Œ≥ about the axis z, followed by a rotation through Œ≤ about the axis y, and a final rotation through Œ± about the axis z.  This is equivalent to performing an initial rotation through Œ± about the axis z, followed by a rotation through Œ≤ about the rotated axis y, followed by a rotation through Œ≥ about the twice-rotated axis z. The angles are naturally assumed to be in radians.\n\nNOTE: Before opening an issue reporting something \"wrong\" with this function, be sure to read all of this page, especially the very last section about opening issues or pull requests.\n\nSee Also\n\nto_euler_angles: Convert quaternion to Euler angles\nto_euler_phases: Convert quaternion to Euler phases\nfrom_euler_phases: Create quaternion from Euler phases\n\n\n\n\n\n","category":"method"},{"location":"manual/#Quaternionic.from_euler_phases-Tuple{Any, Any, Any}","page":"Basics","title":"Quaternionic.from_euler_phases","text":"from_euler_phases(z‚Çê, z·µ¶, z·µß)\nfrom_euler_phases(z)\n\nReturn the quaternion corresponding to these Euler phases.\n\nInterpreting the input quaternion as a rotation (though its normalization scales out), we can define the complex Euler phases from the Euler angles (Œ±, Œ≤, Œ≥) as\n\nz‚Çê ‚âî exp(i*Œ±)\nz·µ¶ ‚âî exp(i*Œ≤)\nz·µß ‚âî exp(i*Œ≥)\n\nThese are more useful geometric quantites than the angles themselves ‚Äî being involved in computing spherical harmonics and Wigner's ùîá matrices ‚Äî and can be computed from the components of the corresponding quaternion algebraically (without the use of transcendental functions).\n\nParameters\n\nz::Vector{Complex{T}}: complex vector of length 3, representing the complex phases (z‚Çê, z·µ¶, z·µß) in that order.\n\nReturns\n\nR::Quaternion{T}\n\nSee Also\n\nto_euler_phases: Convert quaternion to Euler phases\nto_euler_angles: Convert quaternion to Euler angles\nfrom_euler_angles: Create quaternion from Euler angles\n\n\n\n\n\n","category":"method"},{"location":"manual/#Quaternionic.from_float_array-Union{Tuple{AbstractArray{T, N} where N}, Tuple{T}} where T<:Real","page":"Basics","title":"Quaternionic.from_float_array","text":"from_float_array(A)\n\nReinterpret a real array as an array of quaternions\n\nThe input array must have an initial dimension whose size is 4, because successive indices in that dimension will be considered successive components of the output quaternion.\n\nNote that this returns a view of the original data [via reinterpret(reshape,...)] only if the base type of the input array isbitstype; otherwise, a new array of Quaternions must be created, and the memory copied.\n\nSee also to_float_array.\n\n\n\n\n\n","category":"method"},{"location":"manual/#Quaternionic.from_rotation_matrix-Tuple{Any}","page":"Basics","title":"Quaternionic.from_rotation_matrix","text":"from_rotation_matrix(‚Ñõ)\n\nConvert 3x3 rotation matrix to quaternion.\n\nAssuming the 3x3 matrix ‚Ñõ rotates a vector v according to\n\nv' = ‚Ñõ * v,\n\nwe can also express this rotation in terms of a quaternion R such that\n\nv' = R * v * R‚Åª¬π.\n\nThis function returns that quaternion, using Bar-Itzhack's algorithm to allow for non-orthogonal matrices.  J. Guidance, Vol. 23, No. 6, p. 1085\n\n\n\n\n\n","category":"method"},{"location":"manual/#Quaternionic.from_spherical_coordinates-Tuple{Any, Any}","page":"Basics","title":"Quaternionic.from_spherical_coordinates","text":"from_spherical_coordinates(Œ∏, œï)\n\nReturn a rotor corresponding to these spherical coordinates.\n\nConsidering (Œ∏, œï) as a point n on the sphere, we can also construct a quaternion that rotates the z axis onto that point.  Here, we use the standard commonly used in physics: Œ∏ represents the \"polar angle\" between the z axis and the direction n, while œï represents the \"azimuthal angle\" between the x axis and the projection of n into the x-y plane. Both angles must be given in radians.\n\n\n\n\n\n","category":"method"},{"location":"manual/#Quaternionic.to_euler_angles-Tuple{AbstractQuaternion}","page":"Basics","title":"Quaternionic.to_euler_angles","text":"to_euler_angles(R)\n\nOpen Pandora's Box.\n\nIf somebody is trying to make you use Euler angles, tell them no, and walk away, and go and tell your mum.\n\nYou don't want to use Euler angles.  They are awful.  Stay away.  It's one thing to convert from Euler angles to quaternions; at least you're moving in the right direction.  But to go the other way?!  It's just not right.\n\nAssumes the Euler angles correspond to the quaternion R via\n\nR = exp(Œ±ùê§/2) * exp(Œ≤ùê£/2) * exp(Œ≥ùê§/2)\n\nwhere ùê£ and ùê§ rotate about the fixed y and z axes, respectively, so this reprents an initial rotation (in the positive sense) through an angle Œ≥ about the axis z, followed by a rotation through Œ≤ about the axis y, and a final rotation through Œ± about the axis z.  This is equivalent to performing an initial rotation through Œ± about the axis z, followed by a rotation through Œ≤ about the rotated axis y, followed by a rotation through Œ≥ about the twice-rotated axis z. The angles are naturally assumed to be in radians.\n\nNOTE: Before opening an issue reporting something \"wrong\" with this function, be sure to read all of this page, especially the very last section about opening issues or pull requests.\n\nReturns\n\nŒ±Œ≤Œ≥::Vector{T}\n\nRaises\n\nAllHell if you try to actually use Euler angles, when you could have been using quaternions like a sensible person.\n\nSee Also\n\nfrom_euler_angles: Create quaternion from Euler angles\nto_euler_phases: Convert quaternion to Euler phases\nfrom_euler_phases: Create quaternion from Euler phases\n\n\n\n\n\n","category":"method"},{"location":"manual/#Quaternionic.to_euler_phases-Union{Tuple{AbstractQuaternion{T}}, Tuple{T}} where T","page":"Basics","title":"Quaternionic.to_euler_phases","text":"to_euler_phases(q)\nto_euler_phases!(z, q)\n\nConvert input quaternion to complex phases of Euler angles\n\nInterpreting the input quaternion as a rotation (though its normalization scales out), we can define the complex Euler phases from the Euler angles (Œ±, Œ≤, Œ≥) as\n\nz‚Çê ‚âî exp(i*Œ±)\nz·µ¶ ‚âî exp(i*Œ≤)\nz·µß ‚âî exp(i*Œ≥)\n\nThese are more useful geometric quantites than the angles themselves ‚Äî being involved in computing spherical harmonics and Wigner's ùîá matrices ‚Äî and can be computed from the components of the corresponding quaternion algebraically (without the use of transcendental functions).\n\nReturns\n\nz::Vector{Complex{T}}: complex phases (z‚Çê, z·µ¶, z·µß) in that order.\n\nSee Also\n\nfrom_euler_phases: Create quaternion from Euler phases\nto_euler_angles: Convert quaternion to Euler angles\nfrom_euler_angles: Create quaternion from Euler angles\n\n\n\n\n\n","category":"method"},{"location":"manual/#Quaternionic.to_float_array-Union{Tuple{AbstractArray{var\"#s11\", N} where {var\"#s11\"<:AbstractQuaternion{T}, N}}, Tuple{T}} where T<:Real","page":"Basics","title":"Quaternionic.to_float_array","text":"to_float_array(A)\n\nView a quaternion array as an array of real numbers\n\nThe output array will have an extra initial dimension whose size is 4, because successive indices in that dimension correspond to successive components of the quaternion.\n\nNote that this returns a view of the original data only if the base type of the input array isbitstype; otherwise, a new array of that type must be created, and the memory copied.\n\nSee also from_float_array.\n\n\n\n\n\n","category":"method"},{"location":"manual/#Quaternionic.to_rotation_matrix-Tuple{Q} where Q<:AbstractQuaternion","page":"Basics","title":"Quaternionic.to_rotation_matrix","text":"to_rotation_matrix(q)\n\nConvert quaternion to 3x3 rotation matrix.\n\nAssuming the quaternion R rotates a vector v according to\n\nv' = R * v * R‚Åª¬π,\n\nwe can also express this rotation in terms of a 3x3 matrix ‚Ñõ such that\n\nv' = ‚Ñõ * v.\n\nThis function returns that matrix.\n\n\n\n\n\n","category":"method"},{"location":"manual/#Quaternionic.to_spherical_coordinates-Tuple{Q} where Q<:AbstractQuaternion","page":"Basics","title":"Quaternionic.to_spherical_coordinates","text":"to_spherical_coordinates(q)\n\nReturn the spherical coordinates corresponding to this quaternion.\n\nWe can treat the quaternion as a transformation taking the z axis to some direction n.  This direction can be described in terms of spherical coordinates (Œ∏, œï).  Here, we use the standard commonly used in physics: Œ∏ represents the \"polar angle\" between the z axis and the direction n, while œï represents the \"azimuthal angle\" between the x axis and the projection of n into the x-y plane.  Both angles are given in radians.\n\n\n\n\n\n","category":"method"},{"location":"manual/#Distances","page":"Basics","title":"Distances","text":"","category":"section"},{"location":"manual/","page":"Basics","title":"Basics","text":"There are several ways of measuring the \"distance\" between two quaternions: d(q_1 q_2).  Fundamentally, any comparison between two quaternions q_1 and q_2 must make use of a binary operation, for which there are two obvious choices: addition or multiplication.  For either choice, we operate on q_1 and the appropriate inverse (either additive or multiplicative) of q_2.  That is, d should be a function of either q_1 - q_2 or q_1q_2.[1]","category":"page"},{"location":"manual/","page":"Basics","title":"Basics","text":"[1]: For q_1q_2, we are dealing with the multiplicative group of quaternions, which does not include 0, so we will assume that no quaternion involved in such a function can be 0.","category":"page"},{"location":"manual/","page":"Basics","title":"Basics","text":"Now, we also have a number of criteria we would like any distance function to satisfy.  For any quaternions q_1 and q_2 and any unit quaternion q_3, we require","category":"page"},{"location":"manual/","page":"Basics","title":"Basics","text":"real-valued: d(q_1 q_2) in mathbbR\nsymmetry: d(q_1 q_2) = d(q_2 q_1)\ninvariance: d(q_3 q_1 q_3 q_2) = d(q_1 q_2) = d(q_1 q_3 q_2 q_3)\nidentity: d(q_1 q_1) = 0\npositive-definiteness: d(q_1 q_2)  0 whenever q_1  q_2","category":"page"},{"location":"manual/","page":"Basics","title":"Basics","text":"(Of course, it should be noted that these criteria all hold in the exact case; when using floating-point numbers, will likely be violated near edge cases.)","category":"page"},{"location":"manual/","page":"Basics","title":"Basics","text":"It is not hard to see that these criteria can be satisfied by any of","category":"page"},{"location":"manual/","page":"Basics","title":"Basics","text":"abs(q‚ÇÅ - q‚ÇÇ)\nabs2(q‚ÇÅ - q‚ÇÇ)\nabs(log(q‚ÇÅ / q‚ÇÇ))\nabs2(log(q‚ÇÅ / q‚ÇÇ)","category":"page"},{"location":"manual/","page":"Basics","title":"Basics","text":"If q_1 and q_2 are interpreted as rotations, we frequently don't care about their signs, and just want the smallest distance between them, for any choice of sign.  Furthermore, in the multiplicative case, the log functions will involve calculation of the log of the magnitudes of the quaternions, which should be 1.  In this case, we relax the \"positive-definiteness\" criterion to allow d(q_1 q_2) to equal zero when q_1 and q_2 are related by a nonzero scalar multiple.","category":"page"},{"location":"manual/","page":"Basics","title":"Basics","text":"For Rotor types, the latter two multiplicative options are most relevant, while for other types the additive options are more relevant.  These are the default behaviors of the distance and distance2 functions.","category":"page"},{"location":"manual/","page":"Basics","title":"Basics","text":"Modules = [Quaternionic]\nPages   = [\"distance.jl\"]","category":"page"},{"location":"manual/#Quaternionic.distance-Tuple{AbstractQuaternion, AbstractQuaternion}","page":"Basics","title":"Quaternionic.distance","text":"distance(q‚ÇÅ, q‚ÇÇ)\ndistance2(q‚ÇÅ, q‚ÇÇ)\n\nMeasure the \"distance\" between two quaternions, or the squared distance with distance2.\n\nBy default, this function just returns the natural measure in the additive group of quaternions:\n\nabs2(q‚ÇÅ - q‚ÇÇ)\n\nIf both arguments are Rotors, the function returns the natural measure in the rotation group, which is roughly\n\nabs2(log(q‚ÇÅ / q‚ÇÇ))\n\nNote that for Rotors, this method is (efficiently) independent of the scaling of q‚ÇÅ and q‚ÇÇ, including up to factors of -1, as is appropriate for the rotation group.\n\nExamples\n\njulia> distance(imx, imy)\n1.4142135623730951\njulia> distance(Rotor(imx), Rotor(imy))\n1.5707963267948966\njulia> distance(imz, -imz)\n2.0\njulia> distance(Rotor(imz), Rotor(-imz))\n0.0\n\n\n\n\n\n","category":"method"},{"location":"#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Quaternions for Julia","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The goal of this package is to provide a simple but flexible and complete implementation of quaternions, without restricting the interpretation of quaternions to being rotations ‚Äî while also providing extensive support for rotations ‚Äî along with thorough testing, documentation, and integration with the rest of Julia.  Wherever possible, standard functions that work with Complex will also work with Quaternion.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"In addition to a basic Quaternion{T} type, we also have Rotor{T} and QuatVec{T} specializations, which can improve the accuracy and efficiency of certain applications.  Each of these can be defined over any T<:Real; in addition to the standard primitive types (Float64, etc.), BigFloat and Symbolics.Num are tested extensively.","category":"page"},{"location":"#Examples","page":"Introduction","title":"Examples","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"There are numerous ways to construct a Quaternion ‚Äî the simplest being to just give the components:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"julia> using Quaternionic\n\njulia> q = Quaternion(1.0, 2.0, 3.0, 4.0)\n1.0 + 2.0ùê¢ + 3.0ùê£ + 4.0ùê§\njulia> p = Quaternion(4, 3, 2, 1)\n4 + 3ùê¢ + 2ùê£ + 1ùê§","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Each quaternion type is parametrized by the types of its components (which are promoted to be all the same type).  Any subtype of Real is allowed, and is detected automatically.  For example, q has type Quaternion{Float64}, while p has type Quaternion{Int64}.[1] The base type may be given explicitly if desired, to override the detected type:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"julia> r = Quaternion{Float64}(4, 3, 2, 1)\n4.0 + 3.0ùê¢ + 2.0ùê£ + 1.0ùê§","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The various Float and Int types work well, as do BigFloat, and the Num type from Symbolics.jl. In particular, we can use symbolic expressions as components:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"julia> using Quaternionic, Symbolics\n\njulia> @variables a b c d e;\n\njulia> Quaternion(a-b, b*c, c/d, d+e)\na - b + b*cùê¢ + (c*(d^-1))ùê£ + (d + e)ùê§","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"It is also possible to construct random quaternions using randn with a Quaternion type. In analogy with the complex types, the aliases QuaternionF64, QuaternionF32, and QuaternionF16 are provided, as well as the constants imx, imy, and imz, and (for copy-paste convenience) the aliases ùê¢, ùê£, and ùê§ (as Unicode bold characters):","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"julia> QuaternionF64\nQuaternionF64 (alias for Quaternion{Float64})\njulia> 0.1 + 2.3imx + 4.5imz\n0.1 + 2.3ùê¢ + 0.0ùê£ + 4.5ùê§\njulia> 0.1 + 2.3ùê¢ + 0.0ùê£ + 4.5ùê§\n0.1 + 2.3ùê¢ + 0.0ùê£ + 4.5ùê§","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"As with the complex im, the result of multiplying imx, etc., with any real number will be a quaternion with the type of the other number.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"[1]: Note that, mathematically speaking, quaternions can only be defined over a field, which necessarily cannot be an integer type (because the multiplicative inverse of an integer is not generally an integer).  Nonetheless, it is possible to define a Quaternion{<:Integer}, which should behave as expected.  However, many functions (such as exp, log, etc.)  will then return a Quaternion of some different type, just as is the case for Complex{<:Integer}.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Components of a quaternion can be accessed as fields:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"julia> q.w, q.x, q.y, q.z\n(1.0, 2.0, 3.0, 4.0)","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"You can also extract the \"vector\" component (the last three elements) as","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"julia> q.vec\n3-element Vector{Float64}:\n 2.0\n 3.0\n 4.0","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"For convenience, the scalar and vector components can also be accessed in analogy with complex numbers as","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"julia> q.re\n1.0\njulia> q.im\n3-element Vector{Float64}:\n 2.0\n 3.0\n 4.0\njulia> real(q)\n1.0\njulia> imag(q)\n3-element Vector{Float64}:\n 2.0\n 3.0\n 4.0","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"It is also possible to index an individual Quaternion just as you would an array (of length 4):","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"julia> q[1]\n1.0\njulia> q[[3, 2]]\n2-element Vector{Float64}:\n 3.0\n 2.0","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Functions may also be broadcast to each component of a Quaternion.  For example, this can be particularly helpful when simplifying Symbolics expressions:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"julia> @variables q[1:4];\n\njulia> Q = Quaternion(q...);\n\njulia> simplify.(Q * imz * conj(Q))\n0 + (2q[1]*q[3] + 2q[2]*q[4])ùê¢ + (2q[3]*q[4] - 2q[1]*q[2])ùê£ + (q[1]^2 + q[4]^2 - (q[2]^2) - (q[3]^2))ùê§","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The basic algebraic operations work as you would expect:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"julia> p + q\n5.0 + 5.0ùê¢ + 5.0ùê£ + 5.0ùê§\njulia> p - q\n3.0 + 1.0ùê¢ - 1.0ùê£ - 3.0ùê§\njulia> p * q\n-12.0 + 16.0ùê¢ + 4.0ùê£ + 22.0ùê§\njulia> q * p  # Note the non-commutativity\n-12.0 + 6.0ùê¢ + 24.0ùê£ + 12.0ùê§\njulia> q / p\n0.6666666666666666 + 0.3333333333333333ùê¢ + 0.0ùê£ + 0.6666666666666666ùê§","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Essential mathematical functions familiar from complex math, such as conj, abs, abs2, log, exp, etc., are also available.","category":"page"},{"location":"#Contents","page":"Introduction","title":"Contents","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Depth = 4","category":"page"},{"location":"#Function-list","page":"Introduction","title":"Function list","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"The following list contains the public functions inside the Quaternionic module.  Note that there are also many standard math functions defined for Quaternions that live in the Base module, as noted above.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Modules = [Quaternionic]","category":"page"}]
}
