<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Quaternionic.jl · Quaternionic.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">Quaternionic.jl</span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Quaternionic.jl</a><ul class="internal"><li><a class="tocitem" href="#Functions"><span>Functions</span></a></li><li><a class="tocitem" href="#Index"><span>Index</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Quaternionic.jl</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Quaternionic.jl</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/moble/Quaternionic.jl/blob/master/docs/src/index.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Quaternionic.jl"><a class="docs-heading-anchor" href="#Quaternionic.jl">Quaternionic.jl</a><a id="Quaternionic.jl-1"></a><a class="docs-heading-anchor-permalink" href="#Quaternionic.jl" title="Permalink"></a></h1><p><em>Quaternions for Julia</em></p><p>The goal of this package is to provide a simple but flexible and complete implementation of quaternions, without restricting the interpretation of quaternions to being rotations, but also providing extensive support for rotations.</p><p>There are numerous ways to construct a <a href="#Quaternionic.Quaternion"><code>Quaternion</code></a> — the simplest being to just give the components:</p><pre><code class="language-julia-repl">julia&gt; using Quaternionic

julia&gt; q = Quaternion(1.0, 2.0, 3.0, 4.0)
1.0 + 2.0𝐢 + 3.0𝐣 + 4.0𝐤
julia&gt; p = Quaternion(4, 3, 2, 1)
4 + 3𝐢 + 2𝐣 + 1𝐤</code></pre><p>Each quaternion type is parametrized by the types of its components (which are promoted to be all the same type).  Any subtype of <code>Real</code> is allowed, and is detected automatically.  For example, <code>q</code> has type <code>Quaternion{Float64}</code>, while <code>p</code> has type <code>Quaternion{Int64}</code>.<sup class="footnote-reference"><a id="citeref-1" href="#footnote-1">[1]</a></sup> The base type may be given explicitly if desired, to override the detected type:</p><pre><code class="language-julia-repl">julia&gt; r = Quaternion{Float64}(4, 3, 2, 1)
4.0 + 3.0𝐢 + 2.0𝐣 + 1.0𝐤</code></pre><p>The various <code>Float</code> and <code>Int</code> types work well, as do <code>BigFloat</code>, and the <a href="https://symbolics.juliasymbolics.org/v0.1/manual/variables/#A-note-about-functions-restricted-to-Numbers-1"><code>Num</code> type from <code>Symbolics.jl</code></a>. In particular, we can use symbolic expressions as components:</p><pre><code class="language-julia-repl">julia&gt; using Quaternionic, Symbolics

julia&gt; @variables a b c d e;

julia&gt; Quaternion(a-b, b*c, c/d, d+e)
a - b + b*c𝐢 + {c*(d^-1)}𝐣 + {d + e}𝐤</code></pre><p>It is also possible to construct random quaternions using <a href="#Base.randn-Union{Tuple{T}, Tuple{Random.AbstractRNG, Type{Quaternion{T}}}} where T&lt;:AbstractFloat"><code>randn</code></a> with a <code>Quaternion</code> type. In analogy with the complex types, the aliases <code>QuaternionF64</code>, <code>QuaternionF32</code>, and <code>QuaternionF16</code> are provided, as well as the constants <code>imx</code>, <code>imy</code>, and <code>imz</code>, and (for copy-paste convenience) the aliases 𝐢, 𝐣, and 𝐤 (as Unicode bold characters):</p><pre><code class="language-julia-repl">julia&gt; QuaternionF64
QuaternionF64 (alias for Quaternion{Float64})
julia&gt; 0.1 + 2.3imx + 4.5imz
0.1 + 2.3𝐢 + 0.0𝐣 + 4.5𝐤
julia&gt; 0.1 + 2.3𝐢 + 0.0𝐣 + 4.5𝐤
0.1 + 2.3𝐢 + 0.0𝐣 + 4.5𝐤</code></pre><p>As with the complex <code>im</code>, the result of multiplying <code>imx</code>, etc., with any real number will be a quaternion with the type of the other number.</p><p>Components of a quaternion can be accessed as fields:</p><pre><code class="language-julia-repl">julia&gt; q.w, q.x, q.y, q.z
(1.0, 2.0, 3.0, 4.0)</code></pre><p>You can also extract the &quot;vector&quot; component (the last three elements) as</p><pre><code class="language-julia-repl">julia&gt; q.vec
3-element Vector{Float64}:
 2.0
 3.0
 4.0</code></pre><p>For convenience, the scalar and vector components can also be accessed in analogy with complex numbers as</p><pre><code class="language-julia-repl">julia&gt; q.re
1.0
julia&gt; q.im
3-element Vector{Float64}:
 2.0
 3.0
 4.0</code></pre><p>The basic algebraic operations work as you would expect:</p><pre><code class="language-julia-repl">julia&gt; p + q
5.0 + 5.0𝐢 + 5.0𝐣 + 5.0𝐤
julia&gt; p - q
3.0 + 1.0𝐢 - 1.0𝐣 - 3.0𝐤
julia&gt; p * q
-12.0 + 16.0𝐢 + 4.0𝐣 + 22.0𝐤
julia&gt; q * p  # Note the non-commutativity
-12.0 + 6.0𝐢 + 24.0𝐣 + 12.0𝐤
julia&gt; q / p
0.6666666666666666 + 0.3333333333333333𝐢 + 0.0𝐣 + 0.6666666666666666𝐤</code></pre><p>Several essential mathematical functions are also available, including</p><ul><li><a href="#Base.abs-Tuple{Quaternion}"><code>abs</code></a></li><li><a href="#Base.abs2-Tuple{Quaternion}"><code>abs2</code></a></li><li><a href="#Base.conj-Tuple{Quaternion}"><code>conj</code></a></li><li><a href="#Base.exp-Union{Tuple{Quaternion{T}}, Tuple{T}} where T"><code>exp</code></a></li><li><a href="#Base.log-Union{Tuple{Quaternion{T}}, Tuple{T}} where T"><code>log</code></a></li><li><a href="#Base.sqrt-Union{Tuple{Quaternion{T}}, Tuple{T}} where T"><code>sqrt</code></a></li><li><a href="#Base.angle-Tuple{Quaternion}"><code>angle</code></a></li></ul><h2 id="Functions"><a class="docs-heading-anchor" href="#Functions">Functions</a><a id="Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Quaternionic.imx" href="#Quaternionic.imx"><code>Quaternionic.imx</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia">imx</code></pre><p>The quaternionic unit associated with rotation about the <code>x</code> axis.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; imx * imx
-1 + 0𝐢 + 0𝐣 + 0𝐤
julia&gt; 1.2imx
0.0 + 1.2𝐢 + 0.0𝐣 + 0.0𝐤</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/Quaternionic.jl/blob/4061d5b9f2aa84f4e3678f8c4c6e445578a31766/src/Quaternionic.jl#L111-L123">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quaternionic.imy" href="#Quaternionic.imy"><code>Quaternionic.imy</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia">imy</code></pre><p>The quaternionic unit associated with rotation about the <code>y</code> axis.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; imy * imy
-1 + 0𝐢 + 0𝐣 + 0𝐤
julia&gt; 1.2imy
0.0 + 0.0𝐢 + 1.2𝐣 + 0.0𝐤</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/Quaternionic.jl/blob/4061d5b9f2aa84f4e3678f8c4c6e445578a31766/src/Quaternionic.jl#L126-L138">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quaternionic.imz" href="#Quaternionic.imz"><code>Quaternionic.imz</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia">imz</code></pre><p>The quaternionic unit associated with rotation about the <code>z</code> axis.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; imz * imz
-1 + 0𝐢 + 0𝐣 + 0𝐤
julia&gt; 1.2imz
0.0 + 0.0𝐢 + 0.0𝐣 + 1.2𝐤</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/Quaternionic.jl/blob/4061d5b9f2aa84f4e3678f8c4c6e445578a31766/src/Quaternionic.jl#L141-L153">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quaternionic.Quaternion" href="#Quaternionic.Quaternion"><code>Quaternionic.Quaternion</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Quaternion{T&lt;:Real} &lt;: Number</code></pre><p>Quaternionic number type with elements of type <code>T</code>.</p><p><code>QuaternionF16</code>, <code>QuaternionF32</code> and <code>QuaternionF64</code> are aliases for <code>Quaternion{Float16}</code>, <code>Quaternion{Float32}</code> and <code>Quaternion{Float64}</code> respectively.</p><p>See also: <a href="#Quaternionic.Quaternion"><code>Quaternion</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/Quaternionic.jl/blob/4061d5b9f2aa84f4e3678f8c4c6e445578a31766/src/Quaternionic.jl#L18-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quaternionic.Quaternion-NTuple{4, Real}" href="#Quaternionic.Quaternion-NTuple{4, Real}"><code>Quaternionic.Quaternion</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Quaternion(w, x, y, z)
Quaternion(x, y, z)
Quaternion(w)
Quaternion(:z)
Quaternion{T}(w, x, y, z)</code></pre><p>Creates a new quaternion with the given components.  The first argument <code>w</code> is the scalar component, and <code>x</code>, <code>y</code>, and <code>z</code> are the corresponding &quot;vector&quot; components.  The type of the returned quaternion will be inferred from the input arguments.  If numeric arguments are missing, they will be set to zero. It is also possible to pass one of the symbols <code>:w</code>, <code>:x</code>, <code>:y</code>, or <code>:z</code> to obtain a unit vector (by default, with eltype <code>Float64</code>) along the corresponding direction.  It is also possible to specify the element type <code>T</code>, by passing the type parameter as usual.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; Quaternion(1, 2, 3, 4)
1 + 2𝐢 + 3𝐣 + 4𝐤
julia&gt; Quaternion{Float64}(1, 2, 3, 4)
1.0 + 2.0𝐢 + 3.0𝐣 + 4.0𝐤
julia&gt; Quaternion(1.0, 2.0, 3.0, 4.0)
1.0 + 2.0𝐢 + 3.0𝐣 + 4.0𝐤
julia&gt; Quaternion(2, 3, 4)
0 + 2𝐢 + 3𝐣 + 4𝐤
julia&gt; Quaternion(1)
1 + 0𝐢 + 0𝐣 + 0𝐤
julia&gt; Quaternion(:z)
0.0 + 0.0𝐢 + 0.0𝐣 + 1.0𝐤
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/Quaternionic.jl/blob/4061d5b9f2aa84f4e3678f8c4c6e445578a31766/src/Quaternionic.jl#L35-L68">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.abs-Tuple{Quaternion}" href="#Base.abs-Tuple{Quaternion}"><code>Base.abs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">abs(q)</code></pre><p>Square-root of the sum the squares of the components of the quaternion</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; abs(Quaternion(1,2,4,10))
11.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/Quaternionic.jl/blob/4061d5b9f2aa84f4e3678f8c4c6e445578a31766/src/Quaternionic.jl#L344-L354">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.abs2-Tuple{Quaternion}" href="#Base.abs2-Tuple{Quaternion}"><code>Base.abs2</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">abs2(q)</code></pre><p>Sum the squares of the components of the quaternion</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; abs2(Quaternion(1,2,4,10))
121</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/Quaternionic.jl/blob/4061d5b9f2aa84f4e3678f8c4c6e445578a31766/src/Quaternionic.jl#L331-L341">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.angle-Tuple{Quaternion}" href="#Base.angle-Tuple{Quaternion}"><code>Base.angle</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">angle(q)</code></pre><p>Phase angle in radians of the rotation represented by this quaternion.</p><p>Note that this may be different from your interpretation of the angle of a complex number in an important way.  Because quaternions act on vectors by conjugation — as in <code>q*v*conj(q)</code> — there are <em>two</em> copies of <code>q</code> involved in that expression; in some sense, a quaternion acts &quot;twice&quot;.  Therefore, this angle may be twice what you expect from an analogy with complex numbers — dpending on how you interpret the correspondence between complex numbers and quaternions.  Also, while rotations in the complex plane have a natural choice of axis (the positive <code>z</code> direction), that is not the case for quaternions, which means that the sign of this angle is arbitrary, and we always choose it to be positive.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; θ=1.2;

julia&gt; R=exp(θ * Quaternion(:z) / 2);

julia&gt; angle(R)
1.2
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/Quaternionic.jl/blob/4061d5b9f2aa84f4e3678f8c4c6e445578a31766/src/Quaternionic.jl#L550-L576">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.conj-Tuple{Quaternion}" href="#Base.conj-Tuple{Quaternion}"><code>Base.conj</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">conj(q)</code></pre><p>Return the quaternion conjugate, which flips the sign of each &quot;vector&quot; component.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; conj(Quaternion(1,2,3,4))
1 - 2𝐢 - 3𝐣 - 4𝐤</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/Quaternionic.jl/blob/4061d5b9f2aa84f4e3678f8c4c6e445578a31766/src/Quaternionic.jl#L317-L328">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.exp-Union{Tuple{Quaternion{T}}, Tuple{T}} where T" href="#Base.exp-Union{Tuple{Quaternion{T}}, Tuple{T}} where T"><code>Base.exp</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">exp(q)</code></pre><p>Exponential of a quaternion</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; exp(π/4*Quaternion(:x))  # Rotation by π/2 about the x axis
0.7071067811865476 + 0.7071067811865475𝐢 + 0.0𝐣 + 0.0𝐤</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/Quaternionic.jl/blob/4061d5b9f2aa84f4e3678f8c4c6e445578a31766/src/Quaternionic.jl#L447-L457">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.log-Union{Tuple{Quaternion{T}}, Tuple{T}} where T" href="#Base.log-Union{Tuple{Quaternion{T}}, Tuple{T}} where T"><code>Base.log</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">log(q)</code></pre><p>Logarithm of a quaternion.</p><p>As with the usual complex logarithm, the quaternion logarithm has multiple branches, though the quaternion branches are three-dimensional: for any unit &quot;vector&quot; quaternion q̂, you could add any integer multiple of 2πq̂ to the result of this function and still get the same result after exponentiating (within numerical accuracy).  This function is the principal logarithm.</p><p>This function has discontinuous (and fairly arbitrary) behavior along the negative real axis: if the &quot;vector&quot; components of the quaternion are precisely zero <em>and</em> the scalar component is negative, the returned quaternion will have scalar component <code>log(-q.w)</code>, but will also have a <code>z</code> component of π.  The choice of the <code>z</code> direction is arbitrary; the &quot;vector&quot; component of the returned quaternion could be π times any unit vector.</p><p>Note that this function is not specialized to unit-quaternion inputs, so the scalar component of the returned value will be nonzero unless the input has <em>precisely</em> unit magnitude.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; log(exp(1.2Quaternion(:y)))
0.0 + 0.0𝐢 + 1.2𝐣 + 0.0𝐤

julia&gt; log(Quaternion(exp(7)))
7.0 + 0.0𝐢 + 0.0𝐣 + 0.0𝐤

julia&gt; log(Quaternion(-exp(7)))
7.0 + 0.0𝐢 + 0.0𝐣 + 3.141592653589793𝐤</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/Quaternionic.jl/blob/4061d5b9f2aa84f4e3678f8c4c6e445578a31766/src/Quaternionic.jl#L385-L419">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.randn-Union{Tuple{T}, Tuple{Random.AbstractRNG, Type{Quaternion{T}}}} where T&lt;:AbstractFloat" href="#Base.randn-Union{Tuple{T}, Tuple{Random.AbstractRNG, Type{Quaternion{T}}}} where T&lt;:AbstractFloat"><code>Base.randn</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">randn([rng=GLOBAL_RNG], [T=Quaternion{Float64}], [dims...])</code></pre><p>Generate a normally distributed random quaternion of type <code>T</code> with mean 0 and standard deviation of norm 1.  Optionally generate an <em>array</em> of such quaternions.  This module currently provides an implementation for the types <code>QuaternionF16</code>, <code>QuaternionF32</code>, and <code>QuaternionF64</code> (the default).  The values are drawn from the spherically symmetric quaternionic normal distribution of variance 1 (corresponding to each component having independent normal distribution with mean zero and variance 1/4).</p><p>See also: <a href="#Quaternionic.randn_rotor-Union{Tuple{T}, Tuple{Random.AbstractRNG, Type{T}, Tuple{Vararg{Int64, N}} where N}} where T&lt;:AbstractFloat"><code>randn_rotor</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia">julia&gt; randn(QuaternionF64)
0.4336736009756228 - 0.45087190792840853𝐢 - 0.24723937675211696𝐣 - 0.4514571469326208𝐤
julia&gt; randn(QuaternionF16, 2, 2)
2×2 Matrix{QuaternionF16}:
   0.4321 + 1.105𝐢 + 0.2664𝐣 - 0.1359𝐤   0.064 + 0.9263𝐢 - 0.4138𝐣 + 0.05505𝐤
 0.2512 - 0.2585𝐢 - 0.2803𝐣 - 0.00964𝐤  -0.1256 + 0.1848𝐢 + 0.03607𝐣 - 0.752𝐤</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/Quaternionic.jl/blob/4061d5b9f2aa84f4e3678f8c4c6e445578a31766/src/random.jl#L1-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.sqrt-Union{Tuple{Quaternion{T}}, Tuple{T}} where T" href="#Base.sqrt-Union{Tuple{Quaternion{T}}, Tuple{T}} where T"><code>Base.sqrt</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">sqrt(q)</code></pre><p>Square-root of a quaternion.</p><p>The general formula whenever the denominator is nonzero is</p><p><span>$\sqrt{q} = \frac{|q| + q} {\sqrt{2|q| + 2q.w}}$</span></p><p>This can be proven by expanding <code>q</code> as <code>q.w + q.vec</code> and multiplying the expression above by itself.</p><p>When the denominator is zero, this function has discontinuous (and fairly arbitrary) behavior, just as with the quaternion <a href="#Base.log-Union{Tuple{Quaternion{T}}, Tuple{T}} where T"><code>log</code></a> function.  In this case, either all components are zero — in which case the result is simply the zero quaternion — or the &quot;vector&quot; components of the quaternion are precisely zero and the scalar component is negative.  If the latter is true, the denominator above will be a pure-imaginary number.  Because the quaternions come with infinitely many elements that square to -1, it is not clear <em>which</em> imaginary should be used, so we arbitrarily choose to set the result proportional to the <code>z</code> quaternion.  The choice of the <code>z</code> direction is arbitrary; the &quot;vector&quot; component of the returned quaternion could be in any direction.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; q = Quaternion(1.2, 3.4, 5.6, 7.8);

julia&gt; sqrtq = √q;

julia&gt; sqrtq^2 ≈ q
true

julia&gt; √Quaternion(4)
2.0 + 0.0𝐢 + 0.0𝐣 + 0.0𝐤

julia&gt; √Quaternion(-4)
0.0 + 0.0𝐢 + 0.0𝐣 + 2.0𝐤</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/Quaternionic.jl/blob/4061d5b9f2aa84f4e3678f8c4c6e445578a31766/src/Quaternionic.jl#L480-L521">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quaternionic.abs2vec-Tuple{Quaternion}" href="#Quaternionic.abs2vec-Tuple{Quaternion}"><code>Quaternionic.abs2vec</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">abs2vec(q)</code></pre><p>Sum the squares of the &quot;vector&quot; components of the quaternion</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; abs2vec(Quaternion(1,2,3,6))
49</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/Quaternionic.jl/blob/4061d5b9f2aa84f4e3678f8c4c6e445578a31766/src/Quaternionic.jl#L357-L367">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quaternionic.absvec-Tuple{Quaternion}" href="#Quaternionic.absvec-Tuple{Quaternion}"><code>Quaternionic.absvec</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">absvec(q)</code></pre><p>Square-root of the sum of the squares of the &quot;vector&quot; components of the quaternion</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; absvec(Quaternion(1,2,3,6))
7.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/Quaternionic.jl/blob/4061d5b9f2aa84f4e3678f8c4c6e445578a31766/src/Quaternionic.jl#L370-L380">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quaternionic.as_float_array-Union{Tuple{AbstractArray{Quaternion{T}, N} where N}, Tuple{T}} where T&lt;:AbstractFloat" href="#Quaternionic.as_float_array-Union{Tuple{AbstractArray{Quaternion{T}, N} where N}, Tuple{T}} where T&lt;:AbstractFloat"><code>Quaternionic.as_float_array</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">as_float_array(A)</code></pre><p>View a quaternion array as an array of real numbers</p><p>This function is fast because no data is copied; the returned quantity is just a &quot;view&quot; of the original.  The output view will have an extra initial dimension (of size 4), but is otherwise the same shape as the input array.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/Quaternionic.jl/blob/4061d5b9f2aa84f4e3678f8c4c6e445578a31766/src/conversion.jl#L13-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quaternionic.as_quat_array-Union{Tuple{AbstractArray{T, N} where N}, Tuple{T}} where T&lt;:Real" href="#Quaternionic.as_quat_array-Union{Tuple{AbstractArray{T, N} where N}, Tuple{T}} where T&lt;:Real"><code>Quaternionic.as_quat_array</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">as_quat_array(A)</code></pre><p>View a real array as an array of quaternions</p><p>The input array must have an initial dimension whose size is divisible by four (or better yet <em>is</em> 4), because successive indices in that last dimension will be considered successive components of the output quaternion.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/Quaternionic.jl/blob/4061d5b9f2aa84f4e3678f8c4c6e445578a31766/src/conversion.jl#L1-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quaternionic.from_euler_angles-Tuple{Any, Any, Any}" href="#Quaternionic.from_euler_angles-Tuple{Any, Any, Any}"><code>Quaternionic.from_euler_angles</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">from_euler_angles(α, β, γ)</code></pre><p>Improve your life drastically.</p><p>Assumes the Euler angles correspond to the quaternion <code>R</code> via</p><pre><code class="language-none">R = exp(α 𝐤/2) * exp(β 𝐣/2) * exp(γ 𝐤/2)</code></pre><p>where 𝐣 and 𝐤 rotate about the fixed <span>$y$</span> and <span>$z$</span> axes, respectively, so this reprents an initial rotation about the <span>$z$</span> axis (in the positive sense) through an angle γ, followed by a rotation about the <span>$y$</span> axis by β, and a final rotation about the <span>$z$</span> axis by α.  This is equivalent to performing an initial rotation about <span>$z$</span> by α, followed by a rotation about <em>the rotated</em> <span>$y&#39;$</span> axis by β, followed by a rotation about <em>the twice-rotated</em> <span>$z&#39;&#39;$</span> axis by γ.  The angles naturally must be in radians for this to make any sense.</p><p>NOTE: Before opening an issue reporting something &quot;wrong&quot; with this function, be sure to read all of <a href="https://github.com/moble/quaternion/wiki/Euler-angles-are-horrible">this page</a>, <em>especially</em> the very last section about opening issues or pull requests.</p><p><strong>See Also</strong></p><ul><li><a href="#Quaternionic.to_euler_angles-Tuple{Quaternion}"><code>to_euler_angles</code></a>: Convert quaternion to Euler angles</li><li><a href="#Quaternionic.to_euler_phases-Union{Tuple{Quaternion{T}}, Tuple{T}} where T"><code>to_euler_phases</code></a>: Convert quaternion to Euler phases</li><li><a href="#Quaternionic.from_euler_phases-Tuple{Any, Any, Any}"><code>from_euler_phases</code></a>: Create quaternion from Euler phases</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/Quaternionic.jl/blob/4061d5b9f2aa84f4e3678f8c4c6e445578a31766/src/conversion.jl#L76-L102">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quaternionic.from_euler_phases-Tuple{Any, Any, Any}" href="#Quaternionic.from_euler_phases-Tuple{Any, Any, Any}"><code>Quaternionic.from_euler_phases</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">from_euler_phases(zₐ, zᵦ, zᵧ)
from_euler_phases(z)</code></pre><p>Return the quaternion corresponding to these Euler phases.</p><p>Interpreting the input quaternion as a rotation (though its normalization scales out), we can define the complex Euler phases from the Euler angles (α, β, γ) as</p><pre><code class="language-none">zₐ ≔ exp(i*α)
zᵦ ≔ exp(i*β)
zᵧ ≔ exp(i*γ)</code></pre><p>These are more useful geometric quantites than the angles themselves — being involved in computing spherical harmonics and Wigner&#39;s 𝔇 matrices — and can be computed from the components of the corresponding quaternion algebraically (without the use of transcendental functions).</p><p><strong>Parameters</strong></p><ul><li><code>z::Vector{Complex{T}}</code>: complex vector of length 3, representing the complex phases (zₐ, zᵦ, zᵧ) in that order.</li></ul><p><strong>Returns</strong></p><ul><li><code>R::Quaternion{T}</code></li></ul><p><strong>See Also</strong></p><ul><li><a href="#Quaternionic.to_euler_phases-Union{Tuple{Quaternion{T}}, Tuple{T}} where T"><code>to_euler_phases</code></a>: Convert quaternion to Euler phases</li><li><a href="#Quaternionic.to_euler_angles-Tuple{Quaternion}"><code>to_euler_angles</code></a>: Convert quaternion to Euler angles</li><li><a href="#Quaternionic.from_euler_angles-Tuple{Any, Any, Any}"><code>from_euler_angles</code></a>: Create quaternion from Euler angles</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/Quaternionic.jl/blob/4061d5b9f2aa84f4e3678f8c4c6e445578a31766/src/conversion.jl#L171-L203">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quaternionic.from_rotation_matrix-Tuple{Any}" href="#Quaternionic.from_rotation_matrix-Tuple{Any}"><code>Quaternionic.from_rotation_matrix</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">from_rotation_matrix(ℛ)</code></pre><p>Convert 3x3 rotation matrix to quaternion.</p><p>Assuming the 3x3 matrix <code>ℛ</code> rotates a vector <code>v</code> according to</p><pre><code class="language-none">v&#39; = ℛ * v,</code></pre><p>we can also express this rotation in terms of a quaternion <code>R</code> such that</p><pre><code class="language-none">v&#39; = R * v * R⁻¹.</code></pre><p>This function returns that quaternion, using Bar-Itzhack&#39;s algorithm to allow for non-orthogonal matrices.  <a href="http://dx.doi.org/10.2514/2.4654">J. Guidance, Vol. 23, No. 6, p. 1085</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/Quaternionic.jl/blob/4061d5b9f2aa84f4e3678f8c4c6e445578a31766/src/conversion.jl#L257-L273">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quaternionic.from_spherical_coordinates-Tuple{Any, Any}" href="#Quaternionic.from_spherical_coordinates-Tuple{Any, Any}"><code>Quaternionic.from_spherical_coordinates</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">from_spherical_coordinates(θ, ϕ)</code></pre><p>Return a quaternion corresponding to these spherical coordinates.</p><p>Considering (θ, ϕ) as a point <span>$n̂$</span> on the sphere, we can also construct a quaternion that rotates the <span>$z$</span> axis onto that point.  Here, we use the standard commonly used in physics: θ represents the &quot;polar angle&quot; between the <span>$z$</span> axis and the direction <span>$n̂$</span>, while ϕ represents the &quot;azimuthal angle&quot; between the <span>$x$</span> axis and the projection of <span>$n̂$</span> into the <span>$x$</span>-<span>$y$</span> plane.  Both angles must be given in radians.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/Quaternionic.jl/blob/4061d5b9f2aa84f4e3678f8c4c6e445578a31766/src/conversion.jl#L237-L248">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quaternionic.randn_rotor-Union{Tuple{T}, Tuple{Random.AbstractRNG, Type{T}, Tuple{Vararg{Int64, N}} where N}} where T&lt;:AbstractFloat" href="#Quaternionic.randn_rotor-Union{Tuple{T}, Tuple{Random.AbstractRNG, Type{T}, Tuple{Vararg{Int64, N}} where N}} where T&lt;:AbstractFloat"><code>Quaternionic.randn_rotor</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">randn_rotor([rng=GLOBAL_RNG], [T=Quaternion{Float64}], [dims...])</code></pre><p>Generate a normally distributed random quaternion of type <code>T</code> with mean 0 and norm 1. The result is spherically symmetric, and gives rise a truly random rotation.</p><p>See also: <a href="#Base.randn-Union{Tuple{T}, Tuple{Random.AbstractRNG, Type{Quaternion{T}}}} where T&lt;:AbstractFloat"><code>randn</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/Quaternionic.jl/blob/4061d5b9f2aa84f4e3678f8c4c6e445578a31766/src/random.jl#L27-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quaternionic.to_euler_angles-Tuple{Quaternion}" href="#Quaternionic.to_euler_angles-Tuple{Quaternion}"><code>Quaternionic.to_euler_angles</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">to_euler_angles(R)</code></pre><p>Open Pandora&#39;s Box.</p><p>If somebody is trying to make you use Euler angles, tell them no, and walk away, and go and tell your mum.</p><p>You don&#39;t want to use Euler angles.  They are awful.  Stay away.  It&#39;s one thing to convert from Euler angles to quaternions; at least you&#39;re moving in the right direction.  But to go the other way?!  It&#39;s just not right.</p><p>Assumes the Euler angles correspond to the quaternion <code>R</code> via</p><pre><code class="language-none">R = exp(α 𝐤/2) * exp(β 𝐣/2) * exp(γ 𝐤/2)</code></pre><p>where 𝐣 and 𝐤 rotate about the fixed <span>$y$</span> and <span>$z$</span> axes, respectively, so this reprents an initial rotation about the <span>$z$</span> axis (in the positive sense) through an angle γ, followed by a rotation about the <span>$y$</span> axis by β, and a final rotation about the <span>$z$</span> axis by α.  This is equivalent to performing an initial rotation about <span>$z$</span> by α, followed by a rotation about <em>the rotated</em> <span>$y&#39;$</span> axis by β, followed by a rotation about <em>the twice-rotated</em> <span>$z&#39;&#39;$</span> axis by γ.  The angles are naturally in radians.</p><p>NOTE: Before opening an issue reporting something &quot;wrong&quot; with this function, be sure to read all of <a href="https://github.com/moble/quaternion/wiki/Euler-angles-are-horrible">this page</a>, <em>especially</em> the very last section about opening issues or pull requests.</p><p><strong>Returns</strong></p><ul><li><code>αβγ::Vector{T}</code></li></ul><p><strong>Raises</strong></p><ul><li><code>AllHell</code> if you try to actually use Euler angles, when you could have been using quaternions like a sensible person.</li></ul><p><strong>See Also</strong></p><ul><li><a href="#Quaternionic.from_euler_angles-Tuple{Any, Any, Any}"><code>from_euler_angles</code></a>: Create quaternion from Euler angles</li><li><a href="#Quaternionic.to_euler_phases-Union{Tuple{Quaternion{T}}, Tuple{T}} where T"><code>to_euler_phases</code></a>: Convert quaternion to Euler phases</li><li><a href="#Quaternionic.from_euler_phases-Tuple{Any, Any, Any}"><code>from_euler_phases</code></a>: Create quaternion from Euler phases</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/Quaternionic.jl/blob/4061d5b9f2aa84f4e3678f8c4c6e445578a31766/src/conversion.jl#L26-L66">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quaternionic.to_euler_phases-Union{Tuple{Quaternion{T}}, Tuple{T}} where T" href="#Quaternionic.to_euler_phases-Union{Tuple{Quaternion{T}}, Tuple{T}} where T"><code>Quaternionic.to_euler_phases</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">to_euler_phases(q)
to_euler_phases!(z, q)</code></pre><p>Convert input quaternion to complex phases of Euler angles</p><p>Interpreting the input quaternion as a rotation (though its normalization scales out), we can define the complex Euler phases from the Euler angles (α, β, γ) as</p><pre><code class="language-none">zₐ ≔ exp(i*α)
zᵦ ≔ exp(i*β)
zᵧ ≔ exp(i*γ)</code></pre><p>These are more useful geometric quantites than the angles themselves — being involved in computing spherical harmonics and Wigner&#39;s 𝔇 matrices — and can be computed from the components of the corresponding quaternion algebraically (without the use of transcendental functions).</p><p><strong>Returns</strong></p><ul><li><code>z::Vector{Complex{T}}</code>: complex phases (zₐ, zᵦ, zᵧ) in that order.</li></ul><p><strong>See Also</strong></p><ul><li><a href="#Quaternionic.from_euler_phases-Tuple{Any, Any, Any}"><code>from_euler_phases</code></a>: Create quaternion from Euler phases</li><li><a href="#Quaternionic.to_euler_angles-Tuple{Quaternion}"><code>to_euler_angles</code></a>: Convert quaternion to Euler angles</li><li><a href="#Quaternionic.from_euler_angles-Tuple{Any, Any, Any}"><code>from_euler_angles</code></a>: Create quaternion from Euler angles</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/Quaternionic.jl/blob/4061d5b9f2aa84f4e3678f8c4c6e445578a31766/src/conversion.jl#L136-L163">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quaternionic.to_rotation_matrix-Tuple{Any}" href="#Quaternionic.to_rotation_matrix-Tuple{Any}"><code>Quaternionic.to_rotation_matrix</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">to_rotation_matrix(q)</code></pre><p>Convert quaternion to 3x3 rotation matrix.</p><p>Assuming the quaternion <code>R</code> rotates a vector <code>v</code> according to</p><pre><code class="language-none">v&#39; = R * v * R⁻¹,</code></pre><p>we can also express this rotation in terms of a 3x3 matrix <code>ℛ</code> such that</p><pre><code class="language-none">v&#39; = ℛ * v.</code></pre><p>This function returns that matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/Quaternionic.jl/blob/4061d5b9f2aa84f4e3678f8c4c6e445578a31766/src/conversion.jl#L296-L311">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quaternionic.to_spherical_coordinates-Tuple{Quaternion}" href="#Quaternionic.to_spherical_coordinates-Tuple{Quaternion}"><code>Quaternionic.to_spherical_coordinates</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">to_spherical_coordinates(q)</code></pre><p>Return the spherical coordinates corresponding to this quaternion.</p><p>We can treat the quaternion as a transformation taking the <span>$z$</span> axis to some direction <span>$n̂$</span>.  This direction can be described in terms of spherical coordinates (θ, ϕ).  Here, we use the standard commonly used in physics: θ represents the &quot;polar angle&quot; between the <span>$z$</span> axis and the direction <span>$n̂$</span>, while ϕ represents the &quot;azimuthal angle&quot; between the <span>$x$</span> axis and the projection of <span>$n̂$</span> into the <span>$x$</span>-<span>$y$</span> plane.  Both angles are given in radians.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/Quaternionic.jl/blob/4061d5b9f2aa84f4e3678f8c4c6e445578a31766/src/conversion.jl#L216-L227">source</a></section></article><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><ul><li><a href="#Quaternionic.imx"><code>Quaternionic.imx</code></a></li><li><a href="#Quaternionic.imy"><code>Quaternionic.imy</code></a></li><li><a href="#Quaternionic.imz"><code>Quaternionic.imz</code></a></li><li><a href="#Quaternionic.Quaternion"><code>Quaternionic.Quaternion</code></a></li><li><a href="#Quaternionic.Quaternion-NTuple{4, Real}"><code>Quaternionic.Quaternion</code></a></li><li><a href="#Quaternionic.abs2vec-Tuple{Quaternion}"><code>Quaternionic.abs2vec</code></a></li><li><a href="#Quaternionic.absvec-Tuple{Quaternion}"><code>Quaternionic.absvec</code></a></li><li><a href="#Quaternionic.as_float_array-Union{Tuple{AbstractArray{Quaternion{T}, N} where N}, Tuple{T}} where T&lt;:AbstractFloat"><code>Quaternionic.as_float_array</code></a></li><li><a href="#Quaternionic.as_quat_array-Union{Tuple{AbstractArray{T, N} where N}, Tuple{T}} where T&lt;:Real"><code>Quaternionic.as_quat_array</code></a></li><li><a href="#Quaternionic.from_euler_angles-Tuple{Any, Any, Any}"><code>Quaternionic.from_euler_angles</code></a></li><li><a href="#Quaternionic.from_euler_phases-Tuple{Any, Any, Any}"><code>Quaternionic.from_euler_phases</code></a></li><li><a href="#Quaternionic.from_rotation_matrix-Tuple{Any}"><code>Quaternionic.from_rotation_matrix</code></a></li><li><a href="#Quaternionic.from_spherical_coordinates-Tuple{Any, Any}"><code>Quaternionic.from_spherical_coordinates</code></a></li><li><a href="#Quaternionic.randn_rotor-Union{Tuple{T}, Tuple{Random.AbstractRNG, Type{T}, Tuple{Vararg{Int64, N}} where N}} where T&lt;:AbstractFloat"><code>Quaternionic.randn_rotor</code></a></li><li><a href="#Quaternionic.to_euler_angles-Tuple{Quaternion}"><code>Quaternionic.to_euler_angles</code></a></li><li><a href="#Quaternionic.to_euler_phases-Union{Tuple{Quaternion{T}}, Tuple{T}} where T"><code>Quaternionic.to_euler_phases</code></a></li><li><a href="#Quaternionic.to_rotation_matrix-Tuple{Any}"><code>Quaternionic.to_rotation_matrix</code></a></li><li><a href="#Quaternionic.to_spherical_coordinates-Tuple{Quaternion}"><code>Quaternionic.to_spherical_coordinates</code></a></li></ul><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-1"><a class="tag is-link" href="#citeref-1">1</a>Note that, mathematically speaking, quaternions can only be defined over a <a href="https://en.wikipedia.org/wiki/Field_(mathematics)#Definition">field</a>, which necessarily cannot be an integer type (because the multiplicative inverse of an integer is not generally an integer).  Nonetheless, it is possible to define a <code>Quaternion{&lt;:Integer}</code>, which should behave as expected.  However, many functions (such as <a href="#Base.exp-Union{Tuple{Quaternion{T}}, Tuple{T}} where T"><code>exp</code></a>, <a href="#Base.log-Union{Tuple{Quaternion{T}}, Tuple{T}} where T"><code>log</code></a>, etc.) will then return a <code>Quaternion</code> of some different type.</li></ul></section></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Sunday 13 June 2021 04:36">Sunday 13 June 2021</span>. Using Julia version 1.6.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
